[{"/Users/vitaliikravchenko/Sites/nova/client/src/index.tsx":"1","/Users/vitaliikravchenko/Sites/nova/client/src/serviceWorker.ts":"2","/Users/vitaliikravchenko/Sites/nova/client/src/App.tsx":"3","/Users/vitaliikravchenko/Sites/nova/client/src/charts/react.ts":"4","/Users/vitaliikravchenko/Sites/nova/client/src/charts/chart/chartFactory.ts":"5","/Users/vitaliikravchenko/Sites/nova/client/src/charts/chart/legend.ts":"6","/Users/vitaliikravchenko/Sites/nova/client/src/charts/chart/chartMappings.ts":"7","/Users/vitaliikravchenko/Sites/nova/client/src/charts/chart/themes/pastelDark.ts":"8","/Users/vitaliikravchenko/Sites/nova/client/src/charts/chart/themes/materialDark.ts":"9","/Users/vitaliikravchenko/Sites/nova/client/src/charts/chart/series/series.ts":"10","/Users/vitaliikravchenko/Sites/nova/client/src/charts/chart/themes/solarLight.ts":"11","/Users/vitaliikravchenko/Sites/nova/client/src/charts/chart/themes/solarDark.ts":"12","/Users/vitaliikravchenko/Sites/nova/client/src/charts/chart/themes/vividLight.ts":"13","/Users/vitaliikravchenko/Sites/nova/client/src/charts/chart/themes/pastelLight.ts":"14","/Users/vitaliikravchenko/Sites/nova/client/src/charts/chart/themes/vividDark.ts":"15","/Users/vitaliikravchenko/Sites/nova/client/src/charts/chart/themes/materialLight.ts":"16","/Users/vitaliikravchenko/Sites/nova/client/src/charts/chart/themes/chartTheme.ts":"17","/Users/vitaliikravchenko/Sites/nova/client/src/charts/chart/themes/darkTheme.ts":"18","/Users/vitaliikravchenko/Sites/nova/client/src/charts/util/array.ts":"19","/Users/vitaliikravchenko/Sites/nova/client/src/charts/util/object.ts":"20","/Users/vitaliikravchenko/Sites/nova/client/src/charts/util/id.ts":"21","/Users/vitaliikravchenko/Sites/nova/client/src/charts/chart/chart.ts":"22","/Users/vitaliikravchenko/Sites/nova/client/src/charts/chart/series/cartesian/cartesianSeries.ts":"23","/Users/vitaliikravchenko/Sites/nova/client/src/charts/util/padding.ts":"24","/Users/vitaliikravchenko/Sites/nova/client/src/charts/util/observable.ts":"25","/Users/vitaliikravchenko/Sites/nova/client/src/charts/chart/chartAxis.ts":"26","/Users/vitaliikravchenko/Sites/nova/client/src/charts/scene/dropShadow.ts":"27","/Users/vitaliikravchenko/Sites/nova/client/src/charts/scene/group.ts":"28","/Users/vitaliikravchenko/Sites/nova/client/src/charts/caption.ts":"29","/Users/vitaliikravchenko/Sites/nova/client/src/charts/chart/navigator/navigatorMask.ts":"30","/Users/vitaliikravchenko/Sites/nova/client/src/charts/chart/navigator/navigator.ts":"31","/Users/vitaliikravchenko/Sites/nova/client/src/charts/chart/navigator/navigatorHandle.ts":"32","/Users/vitaliikravchenko/Sites/nova/client/src/charts/chart/axis/timeAxis.ts":"33","/Users/vitaliikravchenko/Sites/nova/client/src/charts/axis.ts":"34","/Users/vitaliikravchenko/Sites/nova/client/src/charts/util/sizeMonitor.ts":"35","/Users/vitaliikravchenko/Sites/nova/client/src/charts/scene/shape/rect.ts":"36","/Users/vitaliikravchenko/Sites/nova/client/src/charts/chart/series/seriesMarker.ts":"37","/Users/vitaliikravchenko/Sites/nova/client/src/charts/scene/shape/shape.ts":"38","/Users/vitaliikravchenko/Sites/nova/client/src/charts/scene/node.ts":"39","/Users/vitaliikravchenko/Sites/nova/client/src/charts/scene/shape/text.ts":"40","/Users/vitaliikravchenko/Sites/nova/client/src/charts/scene/matrix.ts":"41","/Users/vitaliikravchenko/Sites/nova/client/src/charts/scene/bbox.ts":"42","/Users/vitaliikravchenko/Sites/nova/client/src/charts/scene/scene.ts":"43","/Users/vitaliikravchenko/Sites/nova/client/src/charts/chart/shapes/rangeSelector.ts":"44","/Users/vitaliikravchenko/Sites/nova/client/src/charts/scale/timeScale.ts":"45","/Users/vitaliikravchenko/Sites/nova/client/src/charts/scene/shape/path.ts":"46","/Users/vitaliikravchenko/Sites/nova/client/src/charts/chart/marker/circle.ts":"47","/Users/vitaliikravchenko/Sites/nova/client/src/charts/chart/shapes/rangeMask.ts":"48","/Users/vitaliikravchenko/Sites/nova/client/src/charts/chart/shapes/rangeHandle.ts":"49","/Users/vitaliikravchenko/Sites/nova/client/src/charts/util/ticks.ts":"50","/Users/vitaliikravchenko/Sites/nova/client/src/charts/util/time/format/defaultLocale.ts":"51","/Users/vitaliikravchenko/Sites/nova/client/src/charts/util/time/duration.ts":"52","/Users/vitaliikravchenko/Sites/nova/client/src/charts/util/bisect.ts":"53","/Users/vitaliikravchenko/Sites/nova/client/src/charts/util/time/year.ts":"54","/Users/vitaliikravchenko/Sites/nova/client/src/charts/util/time/month.ts":"55","/Users/vitaliikravchenko/Sites/nova/client/src/charts/util/time/week.ts":"56","/Users/vitaliikravchenko/Sites/nova/client/src/charts/util/time/day.ts":"57","/Users/vitaliikravchenko/Sites/nova/client/src/charts/util/time/hour.ts":"58","/Users/vitaliikravchenko/Sites/nova/client/src/charts/util/time/minute.ts":"59","/Users/vitaliikravchenko/Sites/nova/client/src/charts/scene/path2D.ts":"60","/Users/vitaliikravchenko/Sites/nova/client/src/charts/util/time/second.ts":"61","/Users/vitaliikravchenko/Sites/nova/client/src/charts/chart/marker/marker.ts":"62","/Users/vitaliikravchenko/Sites/nova/client/src/charts/util/time/millisecond.ts":"63","/Users/vitaliikravchenko/Sites/nova/client/src/charts/scale/continuousScale.ts":"64","/Users/vitaliikravchenko/Sites/nova/client/src/charts/util/time/format/locale.ts":"65","/Users/vitaliikravchenko/Sites/nova/client/src/charts/scene/shape/arc.ts":"66","/Users/vitaliikravchenko/Sites/nova/client/src/charts/scene/shape/line.ts":"67","/Users/vitaliikravchenko/Sites/nova/client/src/charts/util/angle.ts":"68","/Users/vitaliikravchenko/Sites/nova/client/src/charts/scene/selection.ts":"69","/Users/vitaliikravchenko/Sites/nova/client/src/charts/util/compare.ts":"70","/Users/vitaliikravchenko/Sites/nova/client/src/charts/util/time/interval.ts":"71","/Users/vitaliikravchenko/Sites/nova/client/src/charts/scene/intersection.ts":"72","/Users/vitaliikravchenko/Sites/nova/client/src/charts/interpolate/value.ts":"73","/Users/vitaliikravchenko/Sites/nova/client/src/charts/interpolate/number.ts":"74","/Users/vitaliikravchenko/Sites/nova/client/src/charts/util/time/utcWeek.ts":"75","/Users/vitaliikravchenko/Sites/nova/client/src/charts/util/time/utcYear.ts":"76","/Users/vitaliikravchenko/Sites/nova/client/src/charts/util/time/utcDay.ts":"77","/Users/vitaliikravchenko/Sites/nova/client/src/charts/util/number.ts":"78","/Users/vitaliikravchenko/Sites/nova/client/src/charts/scene/polyRoots.ts":"79","/Users/vitaliikravchenko/Sites/nova/client/src/charts/interpolate/object.ts":"80","/Users/vitaliikravchenko/Sites/nova/client/src/charts/interpolate/date.ts":"81","/Users/vitaliikravchenko/Sites/nova/client/src/charts/interpolate/array.ts":"82","/Users/vitaliikravchenko/Sites/nova/client/src/charts/interpolate/constant.ts":"83","/Users/vitaliikravchenko/Sites/nova/client/src/charts/chart/polarChart.ts":"84","/Users/vitaliikravchenko/Sites/nova/client/src/charts/chart/series/cartesian/areaSeries.ts":"85","/Users/vitaliikravchenko/Sites/nova/client/src/charts/chart/series/cartesian/scatterSeries.ts":"86","/Users/vitaliikravchenko/Sites/nova/client/src/charts/chart/series/cartesian/histogramSeries.ts":"87","/Users/vitaliikravchenko/Sites/nova/client/src/charts/chart/series/cartesian/barSeries.ts":"88","/Users/vitaliikravchenko/Sites/nova/client/src/charts/chart/series/cartesian/lineSeries.ts":"89","/Users/vitaliikravchenko/Sites/nova/client/src/charts/chart/axis/groupedCategoryAxis.ts":"90","/Users/vitaliikravchenko/Sites/nova/client/src/charts/chart/series/polar/pieSeries.ts":"91","/Users/vitaliikravchenko/Sites/nova/client/src/charts/chart/axis/categoryAxis.ts":"92","/Users/vitaliikravchenko/Sites/nova/client/src/charts/chart/axis/numberAxis.ts":"93","/Users/vitaliikravchenko/Sites/nova/client/src/charts/chart/groupedCategoryChart.ts":"94","/Users/vitaliikravchenko/Sites/nova/client/src/charts/chart/cartesianChart.ts":"95","/Users/vitaliikravchenko/Sites/nova/client/src/charts/chart/marker/util.ts":"96","/Users/vitaliikravchenko/Sites/nova/client/src/charts/chart/markerLabel.ts":"97","/Users/vitaliikravchenko/Sites/nova/client/src/charts/chart/series/polar/polarSeries.ts":"98","/Users/vitaliikravchenko/Sites/nova/client/src/charts/util/equal.ts":"99","/Users/vitaliikravchenko/Sites/nova/client/src/charts/util/string.ts":"100","/Users/vitaliikravchenko/Sites/nova/client/src/charts/scale/linearScale.ts":"101","/Users/vitaliikravchenko/Sites/nova/client/src/charts/chart/label.ts":"102","/Users/vitaliikravchenko/Sites/nova/client/src/charts/scale/bandScale.ts":"103","/Users/vitaliikravchenko/Sites/nova/client/src/charts/scene/shape/sector.ts":"104","/Users/vitaliikravchenko/Sites/nova/client/src/charts/util/color.ts":"105","/Users/vitaliikravchenko/Sites/nova/client/src/charts/layout/tree.ts":"106","/Users/vitaliikravchenko/Sites/nova/client/src/charts/scene/clipRect.ts":"107","/Users/vitaliikravchenko/Sites/nova/client/src/charts/chart/marker/plus.ts":"108","/Users/vitaliikravchenko/Sites/nova/client/src/charts/chart/marker/heart.ts":"109","/Users/vitaliikravchenko/Sites/nova/client/src/charts/chart/marker/cross.ts":"110","/Users/vitaliikravchenko/Sites/nova/client/src/charts/chart/marker/square.ts":"111","/Users/vitaliikravchenko/Sites/nova/client/src/charts/chart/marker/triangle.ts":"112","/Users/vitaliikravchenko/Sites/nova/client/src/charts/chart/marker/diamond.ts":"113","/Users/vitaliikravchenko/Sites/nova/client/src/charts/hdpiCanvas.ts":"114"},{"size":503,"mtime":1608046136178,"results":"115","hashOfConfig":"116"},{"size":5295,"mtime":1608046136178,"results":"117","hashOfConfig":"116"},{"size":5808,"mtime":1608163965183,"results":"118","hashOfConfig":"116"},{"size":1896,"mtime":1608163804173,"results":"119","hashOfConfig":"116"},{"size":16486,"mtime":1608084831551,"results":"120","hashOfConfig":"116"},{"size":13318,"mtime":1608046136161,"results":"121","hashOfConfig":"116"},{"size":23542,"mtime":1608046136160,"results":"122","hashOfConfig":"116"},{"size":526,"mtime":1608046136166,"results":"123","hashOfConfig":"116"},{"size":908,"mtime":1608046136166,"results":"124","hashOfConfig":"116"},{"size":5736,"mtime":1608046136165,"results":"125","hashOfConfig":"116"},{"size":681,"mtime":1608046136166,"results":"126","hashOfConfig":"116"},{"size":677,"mtime":1608046136166,"results":"127","hashOfConfig":"116"},{"size":529,"mtime":1608046136166,"results":"128","hashOfConfig":"116"},{"size":530,"mtime":1608046136166,"results":"129","hashOfConfig":"116"},{"size":525,"mtime":1608046136166,"results":"130","hashOfConfig":"116"},{"size":912,"mtime":1608046136166,"results":"131","hashOfConfig":"116"},{"size":18327,"mtime":1608046136165,"results":"132","hashOfConfig":"116"},{"size":2277,"mtime":1608046136166,"results":"133","hashOfConfig":"116"},{"size":3729,"mtime":1608046136172,"results":"134","hashOfConfig":"116"},{"size":4626,"mtime":1608046136173,"results":"135","hashOfConfig":"116"},{"size":332,"mtime":1608046136173,"results":"136","hashOfConfig":"116"},{"size":35706,"mtime":1608046136160,"results":"137","hashOfConfig":"116"},{"size":803,"mtime":1608046136163,"results":"138","hashOfConfig":"116"},{"size":396,"mtime":1608046136174,"results":"139","hashOfConfig":"116"},{"size":7374,"mtime":1608046136174,"results":"140","hashOfConfig":"116"},{"size":2599,"mtime":1608046136160,"results":"141","hashOfConfig":"116"},{"size":309,"mtime":1608046136169,"results":"142","hashOfConfig":"116"},{"size":2722,"mtime":1608046136169,"results":"143","hashOfConfig":"116"},{"size":2211,"mtime":1608046136158,"results":"144","hashOfConfig":"116"},{"size":812,"mtime":1608046136162,"results":"145","hashOfConfig":"116"},{"size":5109,"mtime":1608046136162,"results":"146","hashOfConfig":"116"},{"size":1259,"mtime":1608046136162,"results":"147","hashOfConfig":"116"},{"size":839,"mtime":1608046136159,"results":"148","hashOfConfig":"116"},{"size":23099,"mtime":1608082357324,"results":"149","hashOfConfig":"116"},{"size":2263,"mtime":1608046136174,"results":"150","hashOfConfig":"116"},{"size":6649,"mtime":1608046136171,"results":"151","hashOfConfig":"116"},{"size":1241,"mtime":1608046136165,"results":"152","hashOfConfig":"116"},{"size":11888,"mtime":1608046136171,"results":"153","hashOfConfig":"116"},{"size":18851,"mtime":1608046136170,"results":"154","hashOfConfig":"116"},{"size":9103,"mtime":1608080946868,"results":"155","hashOfConfig":"116"},{"size":9058,"mtime":1608046136170,"results":"156","hashOfConfig":"116"},{"size":1937,"mtime":1608046136169,"results":"157","hashOfConfig":"116"},{"size":4927,"mtime":1608080946868,"results":"158","hashOfConfig":"116"},{"size":3393,"mtime":1608046136165,"results":"159","hashOfConfig":"116"},{"size":7700,"mtime":1608046136169,"results":"160","hashOfConfig":"116"},{"size":2368,"mtime":1608046136171,"results":"161","hashOfConfig":"116"},{"size":311,"mtime":1608046136161,"results":"162","hashOfConfig":"116"},{"size":3415,"mtime":1608046136165,"results":"163","hashOfConfig":"116"},{"size":3477,"mtime":1608046136165,"results":"164","hashOfConfig":"116"},{"size":2059,"mtime":1608046136175,"results":"165","hashOfConfig":"116"},{"size":782,"mtime":1608046136175,"results":"166","hashOfConfig":"116"},{"size":364,"mtime":1608046136175,"results":"167","hashOfConfig":"116"},{"size":2757,"mtime":1608046136172,"results":"168","hashOfConfig":"116"},{"size":508,"mtime":1608046136177,"results":"169","hashOfConfig":"116"},{"size":542,"mtime":1608046136176,"results":"170","hashOfConfig":"116"},{"size":1340,"mtime":1608046136177,"results":"171","hashOfConfig":"116"},{"size":649,"mtime":1608046136175,"results":"172","hashOfConfig":"116"},{"size":673,"mtime":1608046136176,"results":"173","hashOfConfig":"116"},{"size":636,"mtime":1608046136176,"results":"174","hashOfConfig":"116"},{"size":27028,"mtime":1608046136170,"results":"175","hashOfConfig":"116"},{"size":507,"mtime":1608046136177,"results":"176","hashOfConfig":"116"},{"size":991,"mtime":1608046136161,"results":"177","hashOfConfig":"116"},{"size":404,"mtime":1608046136176,"results":"178","hashOfConfig":"116"},{"size":5694,"mtime":1608046136168,"results":"179","hashOfConfig":"116"},{"size":32613,"mtime":1608046136176,"results":"180","hashOfConfig":"116"},{"size":5284,"mtime":1608046136171,"results":"181","hashOfConfig":"116"},{"size":3409,"mtime":1608046136171,"results":"182","hashOfConfig":"116"},{"size":1001,"mtime":1608046136172,"results":"183","hashOfConfig":"116"},{"size":19704,"mtime":1608046136171,"results":"184","hashOfConfig":"116"},{"size":160,"mtime":1608046136172,"results":"185","hashOfConfig":"116"},{"size":5555,"mtime":1608046136176,"results":"186","hashOfConfig":"116"},{"size":3561,"mtime":1608046136169,"results":"187","hashOfConfig":"116"},{"size":734,"mtime":1608046136167,"results":"188","hashOfConfig":"116"},{"size":135,"mtime":1608046243142,"results":"189","hashOfConfig":"116"},{"size":1164,"mtime":1608046136177,"results":"190","hashOfConfig":"116"},{"size":535,"mtime":1608046136177,"results":"191","hashOfConfig":"116"},{"size":539,"mtime":1608046136177,"results":"192","hashOfConfig":"116"},{"size":1507,"mtime":1608046136173,"results":"193","hashOfConfig":"116"},{"size":3451,"mtime":1608046136170,"results":"194","hashOfConfig":"116"},{"size":537,"mtime":1608046136167,"results":"195","hashOfConfig":"116"},{"size":261,"mtime":1608046260103,"results":"196","hashOfConfig":"116"},{"size":507,"mtime":1608046136167,"results":"197","hashOfConfig":"116"},{"size":36,"mtime":1608046136167,"results":"198","hashOfConfig":"116"},{"size":2751,"mtime":1608046136162,"results":"199","hashOfConfig":"116"},{"size":20550,"mtime":1608046136163,"results":"200","hashOfConfig":"116"},{"size":13696,"mtime":1608046136164,"results":"201","hashOfConfig":"116"},{"size":20002,"mtime":1608046136163,"results":"202","hashOfConfig":"116"},{"size":26321,"mtime":1608046136163,"results":"203","hashOfConfig":"116"},{"size":14597,"mtime":1608046136163,"results":"204","hashOfConfig":"116"},{"size":19721,"mtime":1608046136159,"results":"205","hashOfConfig":"116"},{"size":20038,"mtime":1608046136164,"results":"206","hashOfConfig":"116"},{"size":734,"mtime":1608082307391,"results":"207","hashOfConfig":"116"},{"size":1636,"mtime":1608046136159,"results":"208","hashOfConfig":"116"},{"size":1569,"mtime":1608046136160,"results":"209","hashOfConfig":"116"},{"size":9930,"mtime":1608046136159,"results":"210","hashOfConfig":"116"},{"size":1128,"mtime":1608046136162,"results":"211","hashOfConfig":"116"},{"size":3858,"mtime":1608080946868,"results":"212","hashOfConfig":"116"},{"size":1280,"mtime":1608046136164,"results":"213","hashOfConfig":"116"},{"size":2127,"mtime":1608046136173,"results":"214","hashOfConfig":"116"},{"size":1400,"mtime":1608046136175,"results":"215","hashOfConfig":"116"},{"size":1580,"mtime":1608046136168,"results":"216","hashOfConfig":"116"},{"size":467,"mtime":1608046136161,"results":"217","hashOfConfig":"116"},{"size":4501,"mtime":1608046136168,"results":"218","hashOfConfig":"116"},{"size":6727,"mtime":1608046136171,"results":"219","hashOfConfig":"116"},{"size":13658,"mtime":1608046136172,"results":"220","hashOfConfig":"116"},{"size":10749,"mtime":1608046136167,"results":"221","hashOfConfig":"116"},{"size":3263,"mtime":1608046136169,"results":"222","hashOfConfig":"116"},{"size":689,"mtime":1608046136161,"results":"223","hashOfConfig":"116"},{"size":527,"mtime":1608046136161,"results":"224","hashOfConfig":"116"},{"size":715,"mtime":1608046136161,"results":"225","hashOfConfig":"116"},{"size":508,"mtime":1608046136161,"results":"226","hashOfConfig":"116"},{"size":403,"mtime":1608046136162,"results":"227","hashOfConfig":"116"},{"size":458,"mtime":1608046136161,"results":"228","hashOfConfig":"116"},{"size":11332,"mtime":1608080962827,"results":"229","hashOfConfig":"116"},{"filePath":"230","messages":"231","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"232"},"19mf4kt",{"filePath":"233","messages":"234","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"232"},{"filePath":"235","messages":"236","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"237","messages":"238","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"239","messages":"240","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"241","usedDeprecatedRules":"232"},{"filePath":"242","messages":"243","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"232"},{"filePath":"244","messages":"245","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"232"},{"filePath":"246","messages":"247","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"232"},{"filePath":"248","messages":"249","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"232"},{"filePath":"250","messages":"251","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"232"},{"filePath":"252","messages":"253","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"232"},{"filePath":"254","messages":"255","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"232"},{"filePath":"256","messages":"257","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"232"},{"filePath":"258","messages":"259","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"232"},{"filePath":"260","messages":"261","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"232"},{"filePath":"262","messages":"263","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"232"},{"filePath":"264","messages":"265","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"232"},{"filePath":"266","messages":"267","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"268","usedDeprecatedRules":"232"},{"filePath":"269","messages":"270","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"271","usedDeprecatedRules":"232"},{"filePath":"272","messages":"273","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"232"},{"filePath":"274","messages":"275","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"232"},{"filePath":"276","messages":"277","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"278","usedDeprecatedRules":"232"},{"filePath":"279","messages":"280","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"232"},{"filePath":"281","messages":"282","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"232"},{"filePath":"283","messages":"284","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"232"},{"filePath":"285","messages":"286","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"232"},{"filePath":"287","messages":"288","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"232"},{"filePath":"289","messages":"290","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"232"},{"filePath":"291","messages":"292","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"232"},{"filePath":"293","messages":"294","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"232"},{"filePath":"295","messages":"296","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"232"},{"filePath":"297","messages":"298","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"232"},{"filePath":"299","messages":"300","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"232"},{"filePath":"301","messages":"302","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"303","usedDeprecatedRules":"232"},{"filePath":"304","messages":"305","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"232"},{"filePath":"306","messages":"307","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"232"},{"filePath":"308","messages":"309","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"232"},{"filePath":"310","messages":"311","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"312","usedDeprecatedRules":"232"},{"filePath":"313","messages":"314","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"315","usedDeprecatedRules":"232"},{"filePath":"316","messages":"317","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"232"},{"filePath":"318","messages":"319","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"232"},{"filePath":"320","messages":"321","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"232"},{"filePath":"322","messages":"323","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"232"},{"filePath":"324","messages":"325","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"232"},{"filePath":"326","messages":"327","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"328","usedDeprecatedRules":"232"},{"filePath":"329","messages":"330","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"232"},{"filePath":"331","messages":"332","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"232"},{"filePath":"333","messages":"334","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"232"},{"filePath":"335","messages":"336","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"232"},{"filePath":"337","messages":"338","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"339","usedDeprecatedRules":"232"},{"filePath":"340","messages":"341","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"232"},{"filePath":"342","messages":"343","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"232"},{"filePath":"344","messages":"345","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"232"},{"filePath":"346","messages":"347","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"232"},{"filePath":"348","messages":"349","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"232"},{"filePath":"350","messages":"351","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"232"},{"filePath":"352","messages":"353","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"232"},{"filePath":"354","messages":"355","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"232"},{"filePath":"356","messages":"357","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"232"},{"filePath":"358","messages":"359","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"232"},{"filePath":"360","messages":"361","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"232"},{"filePath":"362","messages":"363","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"232"},{"filePath":"364","messages":"365","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"232"},{"filePath":"366","messages":"367","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"368","usedDeprecatedRules":"232"},{"filePath":"369","messages":"370","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"371","usedDeprecatedRules":"232"},{"filePath":"372","messages":"373","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"232"},{"filePath":"374","messages":"375","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"232"},{"filePath":"376","messages":"377","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"232"},{"filePath":"378","messages":"379","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"380","usedDeprecatedRules":"232"},{"filePath":"381","messages":"382","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"232"},{"filePath":"383","messages":"384","errorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":2,"source":"385","usedDeprecatedRules":"232"},{"filePath":"386","messages":"387","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"232"},{"filePath":"388","messages":"389","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"390","usedDeprecatedRules":"232"},{"filePath":"391","messages":"392","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"393","usedDeprecatedRules":"232"},{"filePath":"394","messages":"395","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"232"},{"filePath":"396","messages":"397","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"232"},{"filePath":"398","messages":"399","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"232"},{"filePath":"400","messages":"401","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"232"},{"filePath":"402","messages":"403","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"232"},{"filePath":"404","messages":"405","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"406","usedDeprecatedRules":"232"},{"filePath":"407","messages":"408","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":1,"source":"409","usedDeprecatedRules":"232"},{"filePath":"410","messages":"411","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"412","usedDeprecatedRules":"232"},{"filePath":"413","messages":"414","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"415","usedDeprecatedRules":"232"},{"filePath":"416","messages":"417","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"232"},{"filePath":"418","messages":"419","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"420","usedDeprecatedRules":"232"},{"filePath":"421","messages":"422","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"423","usedDeprecatedRules":"232"},{"filePath":"424","messages":"425","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"232"},{"filePath":"426","messages":"427","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"428","usedDeprecatedRules":"232"},{"filePath":"429","messages":"430","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"431","usedDeprecatedRules":"232"},{"filePath":"432","messages":"433","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"434","usedDeprecatedRules":"232"},{"filePath":"435","messages":"436","errorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"437","usedDeprecatedRules":"232"},{"filePath":"438","messages":"439","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"232"},{"filePath":"440","messages":"441","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"232"},{"filePath":"442","messages":"443","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"232"},{"filePath":"444","messages":"445","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"232"},{"filePath":"446","messages":"447","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"232"},{"filePath":"448","messages":"449","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"232"},{"filePath":"450","messages":"451","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"232"},{"filePath":"452","messages":"453","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"454","usedDeprecatedRules":"232"},{"filePath":"455","messages":"456","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"232"},{"filePath":"457","messages":"458","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"232"},{"filePath":"459","messages":"460","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"232"},{"filePath":"461","messages":"462","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"232"},{"filePath":"463","messages":"464","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"232"},{"filePath":"465","messages":"466","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"467","usedDeprecatedRules":"232"},{"filePath":"468","messages":"469","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"470","usedDeprecatedRules":"232"},{"filePath":"471","messages":"472","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"232"},{"filePath":"473","messages":"474","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"232"},{"filePath":"475","messages":"476","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"232"},{"filePath":"477","messages":"478","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"232"},{"filePath":"479","messages":"480","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"232"},{"filePath":"481","messages":"482","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"232"},{"filePath":"483","messages":"484","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"232"},{"filePath":"485","messages":"486","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"232"},"/Users/vitaliikravchenko/Sites/nova/client/src/index.tsx",[],["487","488"],"/Users/vitaliikravchenko/Sites/nova/client/src/serviceWorker.ts",[],"/Users/vitaliikravchenko/Sites/nova/client/src/App.tsx",["489","490","491","492"],"/Users/vitaliikravchenko/Sites/nova/client/src/charts/react.ts",[],"/Users/vitaliikravchenko/Sites/nova/client/src/charts/chart/chartFactory.ts",["493","494"],"import { Chart } from \"./chart\";\nimport { Series } from \"./series/series\";\nimport { ChartAxis } from \"./chartAxis\";\nimport { LegendMarker } from \"./legend\";\nimport { ChartTheme } from \"./themes/chartTheme\";\nimport { DarkTheme } from './themes/darkTheme';\nimport { MaterialLight } from \"./themes/materialLight\";\nimport { MaterialDark } from \"./themes/materialDark\";\nimport { PastelLight } from \"./themes/pastelLight\";\nimport { PastelDark } from \"./themes/pastelDark\";\nimport { SolarLight } from \"./themes/solarLight\";\nimport { SolarDark } from \"./themes/solarDark\";\nimport { VividLight } from \"./themes/vividLight\";\nimport { VividDark } from \"./themes/vividDark\";\nimport { find } from \"../util/array\";\nimport { getValue, isObject } from \"../util/object\";\nimport {\n    CartesianChartOptions,\n    ChartOptions,\n    PolarChartOptions,\n    DerivedChartThemeOptions,\n    ChartThemeName\n} from \"./chartOptions\";\nimport mappings from './chartMappings';\nimport { CartesianChart } from \"./cartesianChart\";\nimport { PolarChart } from \"./polarChart\";\n\ntype ThemeMap = { [key in ChartThemeName | 'undefined' | 'null']?: ChartTheme };\n\nconst lightTheme = new ChartTheme();\nconst darkTheme = new DarkTheme();\n\nexport const lightThemes: ThemeMap = {\n    'undefined': lightTheme,\n    'null': lightTheme,\n    'default': lightTheme,\n    'material': new MaterialLight(),\n    'pastel': new PastelLight(),\n    'solar': new SolarLight(),\n    'vivid': new VividLight(),\n};\n\nexport const darkThemes: ThemeMap = {\n    'undefined': darkTheme,\n    'null': darkTheme,\n    'default-dark': darkTheme,\n    'material-dark': new MaterialDark(),\n    'pastel-dark': new PastelDark(),\n    'solar-dark': new SolarDark(),\n    'vivid-dark': new VividDark(),\n};\n\nexport const themes: ThemeMap = {\n    ...darkThemes,\n    ...lightThemes,\n};\n\nexport function getChartTheme(value?: string | ChartTheme | DerivedChartThemeOptions): ChartTheme {\n    if (value instanceof ChartTheme) {\n        return value;\n    }\n\n    const stockTheme = themes[value as ChartThemeName];\n\n    if (stockTheme) {\n        return stockTheme;\n    }\n\n    value = value as DerivedChartThemeOptions;\n\n    if (value.baseTheme || value.overrides || value.palette) {\n        const baseTheme: any = getChartTheme(value.baseTheme);\n\n        return new baseTheme.constructor(value);\n    }\n\n    return lightTheme;\n}\n\ntype ChartType<T> =\n    T extends CartesianChartOptions ? CartesianChart :\n    T extends PolarChartOptions ? PolarChart :\n    never;\n\nlet firstColorIndex = 0;\n\nexport abstract class ChartFactory {\n    static create<T extends ChartOptions>(options: T, container?: HTMLElement, data?: any[]): ChartType<T> {\n        options = Object.create(options); // avoid mutating user provided options\n        if (container) {\n            options.container = container;\n        }\n        if (data) {\n            options.data = data;\n        }\n        // special handling when both `autoSize` and `width` / `height` are present in the options\n        const autoSize = options && options.autoSize !== false;\n        const theme = getChartTheme(options.theme);\n        firstColorIndex = 0;\n        const chart = create(options, undefined, undefined, theme);\n        if (chart) {\n            if (autoSize) {  // `autoSize` takes precedence over `width` / `height`\n                chart.autoSize = true;\n            }\n        }\n        return chart;\n    }\n\n    static update<T extends ChartOptions>(chart: ChartType<T>, options: T, container?: HTMLElement, data?: any[]) {\n        if (!(chart && options)) {\n            return;\n        }\n        options = Object.create(options);\n        if (container) {\n            options.container = container;\n        }\n        if (data) {\n            options.data = data;\n        }\n        const autoSize = options && options.autoSize !== false;\n        const theme = getChartTheme(options.theme);\n        firstColorIndex = 0;\n        update(chart, options, undefined, theme);\n        if (autoSize) {\n            chart.autoSize = true;\n        }\n    }\n\n    static createComponent = create;\n}\n\nconst pathToSeriesTypeMap: { [key in string]: string } = {\n    'cartesian.series': 'line', // default series type for cartesian charts\n    'line.series': 'line',\n    'area.series': 'area',\n    'bar.series': 'bar',\n    'column.series': 'column',\n    'histogram.series': 'histogram',\n    'scatter.series': 'scatter',\n    'polar.series': 'pie', // default series type for polar charts\n    'pie.series': 'pie'\n};\n\nconst actualSeriesTypeMap = (() => {\n    const map: { [key in string]: string } = {};\n    const actualSeries = ['area', 'bar', 'histogram', 'line', 'pie', 'scatter'];\n    actualSeries.forEach(series => map[series] = series);\n    // Aliases:\n    map['column'] = 'bar';\n    return map;\n})();\n\nfunction create(options: any, path?: string, component?: any, theme?: ChartTheme) {\n    // Deprecate `chart.legend.item.marker.type` in integrated chart options.\n    options = Object.create(options);\n    if (component instanceof LegendMarker) {\n        if (options.type) {\n            options.shape = options.type;\n        }\n    } else {\n        options = provideDefaultType(options, path);\n        if (path) {\n            if (options.type) {\n                path = path + '.' + options.type;\n            }\n        } else {\n            path = options.type;\n        }\n    }\n\n    if (!path) {\n        return;\n    }\n\n    const mapping = getValue(mappings, path);\n\n    if (mapping) {\n        options = provideDefaultOptions(path, options, mapping, theme);\n\n        const meta = mapping.meta || {};\n        const constructorParams = meta.constructorParams || [];\n        const skipKeys = ['type', 'listeners'].concat(constructorParams);\n        // TODO: Constructor params processing could be improved, but it's good enough for current params.\n        const constructorParamValues = constructorParams\n            .map((param: any) => options[param])\n            .filter((value: any) => value !== undefined);\n\n        if (!component) {\n            component = new meta.constructor(...constructorParamValues);\n            if (theme && component instanceof Series) {\n                firstColorIndex = theme.setSeriesColors(component, options, firstColorIndex);\n            }\n        }\n\n        for (const key in options) {\n            // Process every non-special key in the config object.\n            if (skipKeys.indexOf(key) < 0) {\n                const value = options[key];\n\n                if (value && key in mapping && !(meta.setAsIs && meta.setAsIs.indexOf(key) >= 0)) {\n                    if (Array.isArray(value)) {\n                        const subComponents = value\n                            .map(config => {\n                                return create(config, path + '.' + key, undefined, theme);\n                            })\n                            .filter(instance => !!instance);\n                        component[key] = subComponents;\n                    } else {\n                        if (mapping[key] && component[key]) {\n                            // The instance property already exists on the component (e.g. chart.legend).\n                            // Simply configure the existing instance, without creating a new one.\n                            create(value, path + '.' + key, component[key], theme);\n                        } else {\n                            const subComponent = create(value, value.type ? path : path + '.' + key, undefined, theme);\n                            if (subComponent) {\n                                component[key] = subComponent;\n                            }\n                        }\n                    }\n                } else { // if (key in meta.constructor.defaults) { // prevent users from creating custom properties\n                    component[key] = value;\n                }\n            }\n        }\n\n        const listeners = options.listeners;\n        if (component && component.addEventListener && listeners) {\n            for (const key in listeners) {\n                if (listeners.hasOwnProperty(key)) {\n                    const listener = listeners[key];\n                    if (typeof listener === 'function') {\n                        component.addEventListener(key, listener);\n                    }\n                }\n            }\n        }\n\n        return component;\n    }\n}\n\nfunction update(component: any, options: any, path?: string, theme?: ChartTheme) {\n    if (!(options && isObject(options))) {\n        return;\n    }\n\n    // Deprecate `chart.legend.item.marker.type` in integrated chart options.\n    if (component instanceof LegendMarker) {\n        if (options.type) {\n            options.shape = options.type;\n        }\n    } else {\n        options = provideDefaultType(options, path);\n        if (path) {\n            if (options.type) {\n                path = path + '.' + options.type;\n            }\n        } else {\n            path = options.type;\n        }\n    }\n\n    if (!path) {\n        return;\n    }\n\n    const chart: Chart | undefined = path in mappings ? (component as Chart) : undefined;\n    const mapping = getValue(mappings, path);\n\n    if (mapping) {\n        options = provideDefaultOptions(path, options, mapping, theme);\n\n        const meta = mapping.meta || {};\n        const constructorParams = meta && meta.constructorParams || [];\n        const skipKeys = ['type'].concat(constructorParams);\n\n        for (const key in options) {\n            if (skipKeys.indexOf(key) < 0) {\n                const value = options[key];\n                const keyPath = path + '.' + key;\n\n                if (meta.setAsIs && meta.setAsIs.indexOf(key) >= 0) {\n                    component[key] = value;\n                } else {\n                    const oldValue = component[key];\n\n                    if (Array.isArray(oldValue) && Array.isArray(value)) {\n                        if (chart) {\n                            if (key === 'series') {\n                                updateSeries(component, value, keyPath, theme);\n                            } else if (key === 'axes') {\n                                updateAxes(component, value, keyPath, theme);\n                            }\n                        } else {\n                            component[key] = value;\n                        }\n                    } else if (isObject(oldValue)) {\n                        if (value) {\n                            update(oldValue, value, value.type ? path : keyPath, theme);\n                        } else if (key in options) {\n                            component[key] = value;\n                        }\n                    } else {\n                        const subComponent = isObject(value) && create(value, value.type ? path : keyPath, undefined, theme);\n                        if (subComponent) {\n                            component[key] = subComponent;\n                        } else {\n                            if (chart && options.autoSize && (key === 'width' || key === 'height')) {\n                                continue;\n                            }\n                            component[key] = value;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    if (chart) {\n        chart.layoutPending = true;\n    }\n}\n\nfunction updateSeries(chart: Chart, configs: any[], keyPath: string, theme?: ChartTheme) {\n    const allSeries = chart.series.slice();\n    let prevSeries: Series | undefined;\n    let i = 0;\n    for (; i < configs.length; i++) {\n        let config = configs[i];\n        let series = allSeries[i];\n        if (series) {\n            config = provideDefaultType(config, keyPath);\n            const type = actualSeriesTypeMap[config.type];\n            if (series.type === type) {\n                if (theme) {\n                    firstColorIndex = theme.setSeriesColors(series, config, firstColorIndex);\n                }\n                update(series, config, keyPath, theme);\n            } else {\n                const newSeries = create(config, keyPath, undefined, theme);\n                chart.removeSeries(series);\n                chart.addSeriesAfter(newSeries, prevSeries);\n                series = newSeries;\n            }\n        } else { // more new configs than existing series\n            const newSeries = create(config, keyPath, undefined, theme);\n            chart.addSeries(newSeries);\n        }\n        prevSeries = series;\n    }\n    // more existing series than new configs\n    for (; i < allSeries.length; i++) {\n        const series = allSeries[i];\n        if (series) {\n            chart.removeSeries(series);\n        }\n    }\n}\n\nfunction updateAxes(chart: Chart, configs: any[], keyPath: string, theme?: ChartTheme) {\n    const axes = chart.axes;\n    const axesToAdd: ChartAxis[] = [];\n    const axesToUpdate: ChartAxis[] = [];\n\n    for (const config of configs) {\n        const axisToUpdate = find(axes, axis => {\n            return axis.type === config.type && axis.position === config.position;\n        });\n        if (axisToUpdate) {\n            axesToUpdate.push(axisToUpdate);\n            update(axisToUpdate, config, keyPath, theme);\n        } else {\n            const axisToAdd = create(config, keyPath, undefined, theme);\n            if (axisToAdd) {\n                axesToAdd.push(axisToAdd);\n            }\n        }\n    }\n\n    chart.axes = axesToUpdate.concat(axesToAdd);\n}\n\nfunction provideDefaultChartType(options: any): any {\n    if (options.type) {\n        return options;\n    }\n    // If chart type is not specified, try to infer it from the type of first series.\n    const series = options.series && options.series[0];\n\n    if (series && series.type) {\n        outerLoop: for (const chartType in mappings) {\n            for (const seriesType in mappings[chartType].series) {\n                if (series.type === seriesType) {\n                    options = Object.create(options);\n                    options.type = chartType;\n                    break outerLoop;\n                }\n            }\n        }\n    }\n    if (!options.type) {\n        options = Object.create(options);\n        options.type = 'cartesian';\n    }\n\n    return options;\n}\n\nfunction provideDefaultType(options: any, path?: string): any {\n    if (!path) { // if `path` is undefined, `options` is a top-level (chart) config\n        path = '';\n        options = provideDefaultChartType(options);\n    }\n\n    if (!options.type) {\n        const seriesType = pathToSeriesTypeMap[path];\n        if (seriesType) {\n            options = Object.create(options);\n            options.type = seriesType;\n        }\n    }\n\n    return options;\n}\n\nfunction skipThemeKey(key: string): boolean {\n    return ['axes', 'series'].indexOf(key) >= 0;\n}\n\nconst enabledKey = 'enabled';\n\n/**\n * If certain options were not provided by the user, use the defaults from the theme and the mapping.\n * All three objects are provided for the current path in the config tree, not necessarily top-level.\n */\nfunction provideDefaultOptions(path: string, options: any, mapping: any, theme?: ChartTheme): any {\n    const isChartConfig = path.indexOf('.') < 0;\n    const themeDefaults = theme && theme.getConfig(path);\n    const defaults = mapping && mapping.meta && mapping.meta.defaults;\n    const isExplicitlyDisabled = options.enabled === false; // by the user\n\n    if (defaults || themeDefaults) {\n        options = Object.create(options);\n    }\n    // Fill in the gaps for properties not configured by the user using theme provided values.\n    for (const key in themeDefaults) {\n        // The default values for these special chart configs always come from the mappings, not theme.\n        if (isChartConfig && skipThemeKey(key)) {\n            continue;\n        }\n        if (!(key in options)) {\n            options[key] = themeDefaults[key];\n        }\n    }\n    // Fill in the gaps for properties not configured by the user, nor theme using chart mappings.\n    for (const key in defaults) {\n        if ((!themeDefaults || !(key in themeDefaults) || skipThemeKey(key)) && !(key in options)) {\n            options[key] = defaults[key];\n        }\n    }\n\n    // Special handling for the 'enabled' property. For example:\n    // title: { text: 'Quarterly Revenue' } // means title is enabled\n    // legend: {} // means legend is enabled\n    const hasEnabledKey =\n        (themeDefaults && enabledKey in themeDefaults) ||\n        (defaults && enabledKey in defaults);\n    if (hasEnabledKey && !isExplicitlyDisabled) {\n        options[enabledKey] = true;\n    }\n\n    return options;\n}\n","/Users/vitaliikravchenko/Sites/nova/client/src/charts/chart/legend.ts",[],"/Users/vitaliikravchenko/Sites/nova/client/src/charts/chart/chartMappings.ts",[],"/Users/vitaliikravchenko/Sites/nova/client/src/charts/chart/themes/pastelDark.ts",[],"/Users/vitaliikravchenko/Sites/nova/client/src/charts/chart/themes/materialDark.ts",[],"/Users/vitaliikravchenko/Sites/nova/client/src/charts/chart/series/series.ts",[],"/Users/vitaliikravchenko/Sites/nova/client/src/charts/chart/themes/solarLight.ts",[],"/Users/vitaliikravchenko/Sites/nova/client/src/charts/chart/themes/solarDark.ts",[],"/Users/vitaliikravchenko/Sites/nova/client/src/charts/chart/themes/vividLight.ts",[],"/Users/vitaliikravchenko/Sites/nova/client/src/charts/chart/themes/pastelLight.ts",[],"/Users/vitaliikravchenko/Sites/nova/client/src/charts/chart/themes/vividDark.ts",[],"/Users/vitaliikravchenko/Sites/nova/client/src/charts/chart/themes/materialLight.ts",[],"/Users/vitaliikravchenko/Sites/nova/client/src/charts/chart/themes/chartTheme.ts",[],"/Users/vitaliikravchenko/Sites/nova/client/src/charts/chart/themes/darkTheme.ts",["495"],"import { ChartTheme } from \"./chartTheme\";\nimport { ChartThemeOptions } from \"../chartOptions\";\n\nexport class DarkTheme extends ChartTheme {\n\n    getDefaults(): any {\n        const fontColor = 'rgb(200, 200, 200)';\n        const mutedFontColor = 'rgb(150, 150, 150)';\n\n        const axisDefaults = {\n            title: {\n                color: fontColor\n            },\n            label: {\n                color: fontColor\n            },\n            gridStyle: [{\n                stroke: 'rgb(88, 88, 88)',\n                lineDash: [4, 2]\n            }]\n        };\n\n        const seriesLabelDefaults = {\n            label: {\n                color: fontColor\n            }\n        };\n\n        const chartDefaults = {\n            background: {\n                fill: 'rgb(34, 38, 41)'\n            },\n            title: {\n                color: fontColor\n            },\n            subtitle: {\n                color: mutedFontColor\n            },\n            axes: {\n                number: {\n                    ...axisDefaults\n                },\n                category: {\n                    ...axisDefaults\n                },\n                time: {\n                    ...axisDefaults\n                }\n            },\n            legend: {\n                item: {\n                    label: {\n                        color: fontColor\n                    }\n                }\n            }\n        };\n\n        return this.mergeWithParentDefaults({\n            cartesian: {\n                ...chartDefaults,\n                series: {\n                    bar: {\n                        ...seriesLabelDefaults\n                    },\n                    column: {\n                        ...seriesLabelDefaults\n                    },\n                    histogram: {\n                        ...seriesLabelDefaults\n                    }\n                }\n            },\n            polar: {\n                ...chartDefaults,\n                series: {\n                    pie: {\n                        ...seriesLabelDefaults,\n                        title: {\n                            color: fontColor\n                        }\n                    }\n                }\n            }\n        });\n    }\n\n    constructor(options?: ChartThemeOptions) {\n        super(options);\n    }\n}","/Users/vitaliikravchenko/Sites/nova/client/src/charts/util/array.ts",["496","497"],"// Custom `Array.find` implementation for legacy browsers.\nexport function find<T>(arr: T[], predicate: (item: T, index: number, arr: T[]) => boolean): T | undefined {\n    for (let i = 0; i < arr.length; i++) {\n        const value = arr[i];\n        if (predicate(value, i, arr)) {\n            return value;\n        }\n    }\n}\n\nexport function findIndex<T>(arr: T[], predicate: (item: T, index: number, arr: T[]) => boolean): number {\n    for (let i = 0; i < arr.length; i++) {\n        if (predicate(arr[i], i, arr)) {\n            return i;\n        }\n    }\n    return -1;\n}\n\n/**\n * Returns the minimum and maximum value in the given iterable using natural order.\n * If the iterable contains no comparable values, returns `undefined`.\n * @param values\n */\nexport function extent<T>(values: T[]): [T, T] | undefined {\n    const n = values.length;\n    let i = -1;\n    let value;\n    let min;\n    let max;\n\n    while (++i < n) { // Find the first comparable finite value.\n        if ((value = values[i]) != null && value >= value) {\n            min = max = value;\n            while (++i < n) { // Compare the remaining values.\n                if ((value = values[i]) != null) {\n                    if (min > value) {\n                        min = value;\n                    }\n                    if (max < value) {\n                        max = value;\n                    }\n                }\n            }\n        }\n    }\n\n    return typeof min === 'undefined' || typeof max === 'undefined' ? undefined : [min, max];\n}\n\nexport function finiteExtent<T>(values: T[]): [T, T] | undefined {\n    const n = values.length;\n    let i = -1;\n    let value;\n    let min;\n    let max;\n\n    while (++i < n) { // Find the first comparable finite value.\n        if ((value = values[i]) != null && value >= value && isFinite(value as any)) {\n            min = max = value;\n            while (++i < n) { // Compare the remaining values.\n                if ((value = values[i]) != null && isFinite(value as any)) {\n                    if (min > value) {\n                        min = value;\n                    }\n                    if (max < value) {\n                        max = value;\n                    }\n                }\n            }\n        }\n    }\n\n    return min === undefined || max === undefined ? undefined : [min, max];\n}\n\n/**\n * This method will only return `undefined` if there's not a single valid finite number present\n * in the given array of values. Date values will be converted to timestamps.\n * @param values\n */\nexport function numericExtent<T>(values: T[]): [number, number] | undefined {\n    const calculatedExtent = finiteExtent(values);\n\n    if (typeof calculatedExtent === 'undefined') {\n        return;\n    }\n\n    const [a, b] = calculatedExtent;\n    const min = a instanceof Date ? a.getTime() : a;\n    const max = b instanceof Date ? b.getTime() : b;\n\n    if (typeof min === 'number' && isFinite(min) && typeof max === 'number' && isFinite(max)) {\n        return [min, max];\n    }\n}\n\n/**\n * finds the min and max using a process appropriate for stacked values. Ie,\n * summing up the positive and negative numbers, and returning the totals of each\n */\nexport function findMinMax(values: number[]): { min: number, max: number } {\n    let min = 0;\n    let max = 0;\n\n    for (const value of values) {\n        if (value < 0) {\n            min += value;\n        } else {\n            max += value;\n        }\n    }\n\n    return {min, max};\n}\n\nexport function copy(array: any[], start: number = 0, count: number = array.length): any[] {\n    const result = [];\n    let n = array.length;\n\n    if (n) {\n        for (let i = 0; i < count; i++) {\n            result.push(array[(start + i) % n]);\n        }\n    }\n\n    return result;\n}\n","/Users/vitaliikravchenko/Sites/nova/client/src/charts/util/object.ts",[],"/Users/vitaliikravchenko/Sites/nova/client/src/charts/util/id.ts",[],"/Users/vitaliikravchenko/Sites/nova/client/src/charts/chart/chart.ts",["498","499"],"import { Scene } from \"../scene/scene\";\nimport { Group } from \"../scene/group\";\nimport { Series, SeriesNodeDatum } from \"./series/series\";\nimport { Padding } from \"../util/padding\";\nimport { Shape } from \"../scene/shape/shape\";\nimport { Node } from \"../scene/node\";\nimport { Rect } from \"../scene/shape/rect\";\nimport { Legend, LegendClickEvent, LegendDatum } from \"./legend\";\nimport { BBox } from \"../scene/bbox\";\nimport { find } from \"../util/array\";\nimport { SizeMonitor } from \"../util/sizeMonitor\";\nimport { Caption } from \"../caption\";\nimport { Observable, reactive, PropertyChangeEvent, SourceEvent } from \"../util/observable\";\nimport { ChartAxis, ChartAxisDirection } from \"./chartAxis\";\nimport { CartesianSeries } from \"./series/cartesian/cartesianSeries\";\nimport { createId } from \"../util/id\";\n\nconst defaultTooltipCss = `\n.ag-chart-tooltip {\n    display: table;\n    position: absolute;\n    user-select: none;\n    pointer-events: none;\n    white-space: nowrap;\n    z-index: 99999;\n    font: 12px Verdana, sans-serif;\n    color: black;\n    background: rgb(244, 244, 244);\n    border-radius: 5px;\n    box-shadow: 0 0 1px rgba(3, 3, 3, 0.7), 0.5vh 0.5vh 1vh rgba(3, 3, 3, 0.25);\n}\n\n.ag-chart-tooltip-hidden {\n    top: -10000px !important;\n}\n\n.ag-chart-tooltip-title {\n    font-weight: bold;\n    padding: 7px;\n    border-top-left-radius: 5px;\n    border-top-right-radius: 5px;\n    color: white;\n    background-color: #888888;\n    border-top-left-radius: 5px;\n    border-top-right-radius: 5px;\n}\n\n.ag-chart-tooltip-content {\n    padding: 7px;\n    line-height: 1.7em;\n    border-bottom-left-radius: 5px;\n    border-bottom-right-radius: 5px;\n}\n\n.ag-chart-tooltip-arrow::before {\n    content: \"\";\n\n    position: absolute;\n    top: 100%;\n    left: 50%;\n    transform: translateX(-50%);\n\n    border: 6px solid #989898;\n\n    border-left-color: transparent;\n    border-right-color: transparent;\n    border-top-color: #989898;\n    border-bottom-color: transparent;\n\n    width: 0;\n    height: 0;\n\n    margin: 0 auto;\n}\n\n.ag-chart-tooltip-arrow::after {\n    content: \"\";\n\n    position: absolute;\n    top: 100%;\n    left: 50%;\n    transform: translateX(-50%);\n\n    border: 5px solid black;\n\n    border-left-color: transparent;\n    border-right-color: transparent;\n    border-top-color: rgb(244, 244, 244);\n    border-bottom-color: transparent;\n\n    width: 0;\n    height: 0;\n\n    margin: 0 auto;\n}\n\n.ag-chart-wrapper {\n    box-sizing: border-box;\n    overflow: hidden;\n}\n`;\n\nexport interface ChartClickEvent extends SourceEvent<Chart> {\n    event: MouseEvent;\n}\n\nexport interface TooltipMeta {\n    pageX: number;\n    pageY: number;\n}\n\nexport interface TooltipRendererResult {\n    content?: string;\n    title?: string;\n    color?: string;\n    backgroundColor?: string;\n}\n\nexport function toTooltipHtml(input: string | TooltipRendererResult, defaults?: TooltipRendererResult): string {\n    if (typeof input === 'string') {\n        return input;\n    }\n\n    defaults = defaults || {};\n\n    const {\n        content = defaults.content || '',\n        title = defaults.title || undefined,\n        color = defaults.color || 'white',\n        backgroundColor = defaults.backgroundColor || '#888'\n    } = input;\n\n    const titleHtml = title ? `<div class=\"${Chart.defaultTooltipClass}-title\"\n        style=\"color: ${color}; background-color: ${backgroundColor}\">${title}</div>` : '';\n\n    return `${titleHtml}<div class=\"${Chart.defaultTooltipClass}-content\">${content}</div>`;\n}\n\nexport class ChartTooltip extends Observable {\n    chart: Chart;\n\n    element = document.createElement('div');\n\n    private observer?: IntersectionObserver;\n\n    @reactive() enabled: boolean = true;\n\n    @reactive() class: string = Chart.defaultTooltipClass;\n\n    @reactive() delay: number = 0;\n\n    /**\n     * If `true`, the tooltip will be shown for the marker closest to the mouse cursor.\n     * Only has effect on series with markers.\n     */\n    @reactive() tracking: boolean = true;\n\n    isVisible(): boolean {\n        const { element } = this;\n        if (element.classList) { // if not IE11\n            return !element.classList.contains(Chart.defaultTooltipClass + '-hidden');\n        }\n\n        // IE11 part.\n        const classes = element.getAttribute('class');\n        if (classes) {\n            return classes.split(' ').indexOf(Chart.defaultTooltipClass + '-hidden') < 0;\n        }\n        return false;\n    }\n\n    updateClass(visible?: boolean, constrained?: boolean) {\n        const classList = [Chart.defaultTooltipClass, this.class];\n\n        if (visible !== true) {\n            classList.push(`${Chart.defaultTooltipClass}-hidden`);\n        }\n        if (constrained !== true) {\n            classList.push(`${Chart.defaultTooltipClass}-arrow`);\n        }\n\n        this.element.setAttribute('class', classList.join(' '));\n    }\n\n    private showTimeout: number = 0;\n    /**\n     * Shows tooltip at the given event's coordinates.\n     * If the `html` parameter is missing, moves the existing tooltip to the new position.\n     */\n    show(meta: TooltipMeta, html?: string, instantly = false) {\n        const el = this.element;\n\n        if (html !== undefined) {\n            el.innerHTML = html;\n        } else if (!el.innerHTML) {\n            return;\n        }\n\n        let left = meta.pageX - el.clientWidth / 2;\n        const top = meta.pageY - el.clientHeight - 8;\n\n        if (this.chart.container) {\n            const tooltipRect = el.getBoundingClientRect();\n            const minLeft = 0;\n            const maxLeft = window.innerWidth - tooltipRect.width;\n            if (left < minLeft) {\n                left = minLeft;\n                this.updateClass(true, true);\n            } else if (left > maxLeft) {\n                left = maxLeft;\n                this.updateClass(true, true);\n            }\n        }\n\n        el.style.left = `${left}px`;\n        el.style.top = `${top}px`;\n\n        if (this.delay > 0 && !instantly) {\n            this.toggle(false);\n            this.showTimeout = window.setTimeout(() => {\n                this.toggle(true);\n            }, this.delay);\n            return;\n        }\n\n        this.toggle(true);\n    }\n\n    toggle(visible?: boolean) {\n        if (!visible) {\n            window.clearTimeout(this.showTimeout);\n            if (this.chart.lastPick && !this.delay) {\n                this.chart.dehighlightDatum();\n                this.chart.lastPick = undefined;\n            }\n        }\n        this.updateClass(visible);\n    }\n\n    constructor(chart: Chart) {\n        super();\n\n        this.chart = chart;\n        this.class = '';\n\n        const tooltipRoot = document.body;\n        tooltipRoot.appendChild(this.element);\n\n        // Detect when the chart becomes invisible and hide the tooltip as well.\n        if (window.IntersectionObserver) {\n            const target = this.chart.scene.canvas.element;\n            const observer = new IntersectionObserver(entries => {\n                for (const entry of entries) {\n                    if (entry.target === target && entry.intersectionRatio === 0) {\n                        this.toggle(false);\n                    }\n                }\n            }, { root: tooltipRoot });\n            observer.observe(target);\n            this.observer = observer;\n        }\n    }\n\n    destroy() {\n        const { parentNode } = this.element;\n        if (parentNode) {\n            parentNode.removeChild(this.element);\n        }\n\n        if (this.observer) {\n            this.observer.unobserve(this.chart.scene.canvas.element);\n        }\n    }\n}\n\nexport abstract class Chart extends Observable {\n    readonly id = createId(this);\n\n    readonly scene: Scene;\n    readonly background: Rect = new Rect();\n    readonly legend = new Legend();\n\n    protected legendAutoPadding = new Padding();\n    protected captionAutoPadding = 0; // top padding only\n\n    static readonly defaultTooltipClass = 'ag-chart-tooltip';\n\n    private _container: HTMLElement | undefined | null = undefined;\n    set container(value: HTMLElement | undefined | null) {\n        if (this._container !== value) {\n            const { parentNode } = this.element;\n\n            if (parentNode != null) {\n                parentNode.removeChild(this.element);\n            }\n\n            if (value) {\n                value.appendChild(this.element);\n            }\n\n            this._container = value;\n        }\n    }\n    get container(): HTMLElement | undefined | null {\n        return this._container;\n    }\n\n    private _data: any[] = [];\n    set data(data: any[]) {\n        this._data = data;\n        this.series.forEach(series => series.data = data);\n    }\n    get data(): any[] {\n        return this._data;\n    }\n\n    set width(value: number) {\n        this.autoSize = false;\n        if (this.width !== value) {\n            this.scene.resize(value, this.height);\n            this.fireEvent({ type: 'layoutChange' });\n        }\n    }\n    get width(): number {\n        return this.scene.width;\n    }\n\n    set height(value: number) {\n        this.autoSize = false;\n        if (this.height !== value) {\n            this.scene.resize(this.width, value);\n            this.fireEvent({ type: 'layoutChange' });\n        }\n    }\n    get height(): number {\n        return this.scene.height;\n    }\n\n    protected _autoSize = false;\n    set autoSize(value: boolean) {\n        if (this._autoSize !== value) {\n            this._autoSize = value;\n            const { style } = this.element;\n            if (value) {\n                const chart = this; // capture `this` for IE11\n                SizeMonitor.observe(this.element, size => {\n                    if (size.width !== chart.width || size.height !== chart.height) {\n                        chart.scene.resize(size.width, size.height);\n                        chart.fireEvent({ type: 'layoutChange' });\n                    }\n                });\n                style.display = 'block';\n                style.width = '100%';\n                style.height = '100%';\n            } else {\n                SizeMonitor.unobserve(this.element);\n                style.display = 'inline-block';\n                style.width = 'auto';\n                style.height = 'auto';\n            }\n        }\n    }\n    get autoSize(): boolean {\n        return this._autoSize;\n    }\n\n    readonly tooltip: ChartTooltip;\n\n    download(fileName?: string) {\n        this.scene.download(fileName);\n    }\n\n    @reactive('layoutChange') padding = new Padding(20);\n    @reactive('layoutChange') title?: Caption;\n    @reactive('layoutChange') subtitle?: Caption;\n\n    private static tooltipDocuments: Document[] = [];\n\n    protected constructor(document = window.document) {\n        super();\n\n        const root = new Group();\n        const background = this.background;\n\n        background.fill = 'white';\n        root.appendChild(background);\n\n        const element = this._element = document.createElement('div');\n        element.setAttribute('class', 'ag-chart-wrapper');\n\n        const scene = new Scene(document);\n        this.scene = scene;\n        scene.root = root;\n        scene.container = element;\n        this.autoSize = true;\n\n        const { legend } = this;\n        legend.addEventListener('layoutChange', this.onLayoutChange, this);\n        legend.addPropertyListener('position', this.onLegendPositionChange, this);\n\n        this.tooltip = new ChartTooltip(this);\n        this.tooltip.addPropertyListener('class', () => this.tooltip.toggle());\n\n        if (Chart.tooltipDocuments.indexOf(document) < 0) {\n            const styleElement = document.createElement('style');\n            styleElement.innerHTML = defaultTooltipCss;\n            // Make sure the default tooltip style goes before other styles so it can be overridden.\n            document.head.insertBefore(styleElement, document.head.querySelector('style'));\n            Chart.tooltipDocuments.push(document);\n        }\n\n        this.setupDomListeners(scene.canvas.element);\n\n        this.addPropertyListener('title', this.onCaptionChange);\n        this.addPropertyListener('subtitle', this.onCaptionChange);\n        this.addEventListener('layoutChange', () => this.layoutPending = true);\n    }\n\n    destroy() {\n        this.tooltip.destroy();\n        SizeMonitor.unobserve(this.element);\n        this.container = undefined;\n\n        this.cleanupDomListeners(this.scene.canvas.element);\n        this.scene.container = undefined;\n    }\n\n    private onLayoutChange() {\n        this.layoutPending = true;\n    }\n\n    private onLegendPositionChange() {\n        this.legendAutoPadding.clear();\n        this.layoutPending = true;\n    }\n\n    private onCaptionChange(event: PropertyChangeEvent<this, Caption | undefined>) {\n        const { value, oldValue } = event;\n\n        if (oldValue) {\n            oldValue.removeEventListener('change', this.onLayoutChange, this);\n            this.scene.root!.removeChild(oldValue.node);\n        }\n        if (value) {\n            value.addEventListener('change', this.onLayoutChange, this);\n            this.scene.root!.appendChild(value.node);\n        }\n    }\n\n    protected _element: HTMLElement;\n    get element(): HTMLElement {\n        return this._element;\n    }\n\n    abstract get seriesRoot(): Node;\n\n    protected _axes: ChartAxis[] = [];\n    set axes(values: ChartAxis[]) {\n        this._axes.forEach(axis => this.detachAxis(axis));\n        // make linked axes go after the regular ones (simulates stable sort by `linkedTo` property)\n        this._axes = values.filter(a => !a.linkedTo).concat(values.filter(a => a.linkedTo));\n        this._axes.forEach(axis => this.attachAxis(axis));\n        this.axesChanged = true;\n    }\n    get axes(): ChartAxis[] {\n        return this._axes;\n    }\n\n    protected attachAxis(axis: ChartAxis) {\n        this.scene.root!.insertBefore(axis.group, this.seriesRoot);\n    }\n\n    protected detachAxis(axis: ChartAxis) {\n        this.scene.root!.removeChild(axis.group);\n    }\n\n    protected _series: Series[] = [];\n    set series(values: Series[]) {\n        this.removeAllSeries();\n        values.forEach(series => this.addSeries(series));\n    }\n    get series(): Series[] {\n        return this._series;\n    }\n\n    private scheduleLayout() {\n        this.layoutPending = true;\n    }\n\n    private scheduleData() {\n        // To prevent the chart from thinking the cursor is over the same node\n        // after a change to data (the nodes are reused on data changes).\n        this.dehighlightDatum();\n        this.dataPending = true;\n    }\n\n    addSeries(series: Series, before?: Series): boolean {\n        const { series: allSeries, seriesRoot } = this;\n        const canAdd = allSeries.indexOf(series) < 0;\n\n        if (canAdd) {\n            const beforeIndex = before ? allSeries.indexOf(before) : -1;\n\n            if (beforeIndex >= 0) {\n                allSeries.splice(beforeIndex, 0, series);\n                seriesRoot.insertBefore(series.group, before!.group);\n            } else {\n                allSeries.push(series);\n                seriesRoot.append(series.group);\n            }\n            this.initSeries(series);\n            this.seriesChanged = true;\n            this.axesChanged = true;\n\n            return true;\n        }\n\n        return false;\n    }\n\n    protected initSeries(series: Series) {\n        series.chart = this;\n        if (!series.data) {\n            series.data = this.data;\n        }\n        series.addEventListener('layoutChange', this.scheduleLayout, this);\n        series.addEventListener('dataChange', this.scheduleData, this);\n        series.addEventListener('legendChange', this.updateLegend, this);\n        series.addEventListener('nodeClick', this.onSeriesNodeClick, this);\n    }\n\n    protected freeSeries(series: Series) {\n        series.chart = undefined;\n        series.removeEventListener('layoutChange', this.scheduleLayout, this);\n        series.removeEventListener('dataChange', this.scheduleData, this);\n        series.removeEventListener('legendChange', this.updateLegend, this);\n        series.removeEventListener('nodeClick', this.onSeriesNodeClick, this);\n    }\n\n    addSeriesAfter(series: Series, after?: Series): boolean {\n        const { series: allSeries, seriesRoot } = this;\n        const canAdd = allSeries.indexOf(series) < 0;\n\n        if (canAdd) {\n            const afterIndex = after ? this.series.indexOf(after) : -1;\n\n            if (afterIndex >= 0) {\n                if (afterIndex + 1 < allSeries.length) {\n                    seriesRoot.insertBefore(series.group, allSeries[afterIndex + 1].group);\n                } else {\n                    seriesRoot.append(series.group);\n                }\n                this.initSeries(series);\n\n                allSeries.splice(afterIndex + 1, 0, series);\n            } else {\n                if (allSeries.length > 0) {\n                    seriesRoot.insertBefore(series.group, allSeries[0].group);\n                } else {\n                    seriesRoot.append(series.group);\n                }\n                this.initSeries(series);\n\n                allSeries.unshift(series);\n            }\n\n            this.seriesChanged = true;\n            this.axesChanged = true;\n        }\n\n        return false;\n    }\n\n    removeSeries(series: Series): boolean {\n        const index = this.series.indexOf(series);\n\n        if (index >= 0) {\n            this.series.splice(index, 1);\n            this.freeSeries(series);\n            this.seriesRoot.removeChild(series.group);\n            this.seriesChanged = true;\n            return true;\n        }\n\n        return false;\n    }\n\n    removeAllSeries(): void {\n        this.series.forEach(series => {\n            this.freeSeries(series);\n            this.seriesRoot.removeChild(series.group);\n        });\n        this._series = []; // using `_series` instead of `series` to prevent infinite recursion\n        this.seriesChanged = true;\n    }\n\n    protected assignSeriesToAxes() {\n        this.axes.forEach(axis => {\n            const axisName = axis.direction + 'Axis';\n            const boundSeries: Series[] = [];\n\n            this.series.forEach(series => {\n                if ((series as any)[axisName] === axis) {\n                    boundSeries.push(series);\n                }\n            });\n\n            axis.boundSeries = boundSeries;\n        });\n\n        this.seriesChanged = false;\n    }\n\n    protected assignAxesToSeries(force: boolean = false) {\n        // This method has to run before `assignSeriesToAxes`.\n        const directionToAxesMap: { [key in ChartAxisDirection]?: ChartAxis[] } = {};\n\n        this.axes.forEach(axis => {\n            const direction = axis.direction;\n            const directionAxes = directionToAxesMap[direction] || (directionToAxesMap[direction] = []);\n            directionAxes.push(axis);\n        });\n\n        this.series.forEach(series => {\n            series.directions.forEach(direction => {\n                const axisName = direction + 'Axis';\n                if (!(series as any)[axisName] || force) {\n                    const directionAxes = directionToAxesMap[direction];\n                    if (directionAxes) {\n                        const axis = this.findMatchingAxis(directionAxes, series.getKeys(direction));\n                        if (axis) {\n                            (series as any)[axisName] = axis;\n                        }\n                    }\n                }\n            });\n\n            if (series instanceof CartesianSeries) {\n                if (!series.xAxis) {\n                    console.warn(`Could not find a matching xAxis for the ${series.id} series.`);\n                    return;\n                }\n                if (!series.yAxis) {\n                    console.warn(`Could not find a matching yAxis for the ${series.id} series.`);\n                    return;\n                }\n            }\n        });\n\n        this.axesChanged = false;\n    }\n\n    private findMatchingAxis(directionAxes: ChartAxis[], directionKeys?: string[]): ChartAxis | undefined {\n        for (let i = 0; i < directionAxes.length; i++) {\n            const axis = directionAxes[i];\n            const axisKeys = axis.keys;\n\n            if (!axisKeys.length) {\n                return axis;\n            } else if (directionKeys) {\n                for (let j = 0; j < directionKeys.length; j++) {\n                    if (axisKeys.indexOf(directionKeys[j]) >= 0 ) {\n                        return axis;\n                    }\n                }\n            }\n        }\n    }\n\n    protected _axesChanged = false;\n    protected set axesChanged(value: boolean) {\n        this._axesChanged = value;\n    }\n    protected get axesChanged(): boolean {\n        return this._axesChanged;\n    }\n\n    protected _seriesChanged = false;\n    protected set seriesChanged(value: boolean) {\n        this._seriesChanged = value;\n        if (value) {\n            this.dataPending = true;\n        }\n    }\n    protected get seriesChanged(): boolean {\n        return this._seriesChanged;\n    }\n\n    protected layoutCallbackId: number = 0;\n    set layoutPending(value: boolean) {\n        if (value) {\n            if (!(this.layoutCallbackId || this.dataPending)) {\n                this.layoutCallbackId = requestAnimationFrame(this._performLayout);\n            }\n        } else if (this.layoutCallbackId) {\n            cancelAnimationFrame(this.layoutCallbackId);\n            this.layoutCallbackId = 0;\n        }\n    }\n    /**\n     * Only `true` while we are waiting for the layout to start.\n     * This will be `false` if the layout has already started and is ongoing.\n     */\n    get layoutPending(): boolean {\n        return !!this.layoutCallbackId;\n    }\n\n    private readonly _performLayout = () => {\n        this.layoutCallbackId = 0;\n\n        this.background.width = this.width;\n        this.background.height = this.height;\n\n        this.performLayout();\n\n        if (!this.layoutPending) {\n            this.fireEvent({ type: 'layoutDone' });\n        }\n    }\n\n    private dataCallbackId: number = 0;\n    set dataPending(value: boolean) {\n        if (this.dataCallbackId) {\n            clearTimeout(this.dataCallbackId);\n            this.dataCallbackId = 0;\n        }\n        if (value) {\n            this.dataCallbackId = window.setTimeout(() => {\n                this.dataPending = false;\n                this.processData();\n            }, 0);\n        }\n    }\n    get dataPending(): boolean {\n        return !!this.dataCallbackId;\n    }\n\n    processData(): void {\n        this.layoutPending = false;\n\n        if (this.axesChanged) {\n            this.assignAxesToSeries(true);\n            this.assignSeriesToAxes();\n        }\n\n        if (this.seriesChanged) {\n            this.assignSeriesToAxes();\n        }\n\n        this.series.filter(s => s.visible).forEach(series => series.processData());\n        this.updateLegend();\n\n        this.layoutPending = true;\n    }\n\n    private updateLegend() {\n        const legendData: LegendDatum[] = [];\n\n        this.series.filter(s => s.showInLegend).forEach(series => series.listSeriesItems(legendData));\n\n        this.legend.data = legendData;\n    }\n\n    abstract performLayout(): void;\n\n    protected positionCaptions() {\n        const { title, subtitle } = this;\n\n        let titleVisible = false;\n        let subtitleVisible = false;\n\n        const spacing = 10;\n        let paddingTop = spacing;\n\n        if (title && title.enabled) {\n            title.node.x = this.width / 2;\n            title.node.y = paddingTop;\n            titleVisible = true;\n            const titleBBox = title.node.computeBBox(); // make sure to set node's x/y, then computeBBox\n            if (titleBBox) {\n                paddingTop = titleBBox.y + titleBBox.height;\n            }\n\n            if (subtitle && subtitle.enabled) {\n                subtitle.node.x = this.width / 2;\n                subtitle.node.y = paddingTop + spacing;\n                subtitleVisible = true;\n                const subtitleBBox = subtitle.node.computeBBox();\n                if (subtitleBBox) {\n                    paddingTop = subtitleBBox.y + subtitleBBox.height;\n                }\n            }\n        }\n\n        if (title) {\n            title.node.visible = titleVisible;\n        }\n        if (subtitle) {\n            subtitle.node.visible = subtitleVisible;\n        }\n\n        this.captionAutoPadding = Math.floor(paddingTop);\n    }\n\n    protected positionLegend() {\n        if (!this.legend.enabled || !this.legend.data.length) {\n            return;\n        }\n\n        const { legend, captionAutoPadding, legendAutoPadding } = this;\n        const width = this.width;\n        const height = this.height - captionAutoPadding;\n        const legendGroup = legend.group;\n        const legendSpacing = legend.spacing;\n\n        let translationX = 0;\n        let translationY = 0;\n\n        let legendBBox: BBox;\n        switch (legend.position) {\n            case 'bottom':\n                legend.performLayout(width - legendSpacing * 2, 0);\n                legendBBox = legendGroup.computeBBox();\n\n                translationX = (width - legendBBox.width) / 2 - legendBBox.x;\n                translationY = captionAutoPadding + height - legendBBox.height - legendBBox.y - legendSpacing;\n\n                legendAutoPadding.bottom = legendBBox.height;\n                break;\n\n            case 'top':\n                legend.performLayout(width - legendSpacing * 2, 0);\n                legendBBox = legendGroup.computeBBox();\n\n                translationX = (width - legendBBox.width) / 2 - legendBBox.x;\n                translationY = captionAutoPadding + legendSpacing - legendBBox.y;\n\n                legendAutoPadding.top = legendBBox.height;\n                break;\n\n            case 'left':\n                legend.performLayout(0, height - legendSpacing * 2);\n                legendBBox = legendGroup.computeBBox();\n\n                translationX = legendSpacing - legendBBox.x;\n                translationY = captionAutoPadding + (height - legendBBox.height) / 2 - legendBBox.y;\n\n                legendAutoPadding.left = legendBBox.width;\n                break;\n\n            default: // case 'right':\n                legend.performLayout(0, height - legendSpacing * 2);\n                legendBBox = legendGroup.computeBBox();\n\n                translationX = width - legendBBox.width - legendBBox.x - legendSpacing;\n                translationY = captionAutoPadding + (height - legendBBox.height) / 2 - legendBBox.y;\n\n                legendAutoPadding.right = legendBBox.width;\n                break;\n        }\n\n        // Round off for pixel grid alignment to work properly.\n        legendGroup.translationX = Math.floor(translationX + legendGroup.translationX);\n        legendGroup.translationY = Math.floor(translationY + legendGroup.translationY);\n    }\n\n    protected setupDomListeners(chartElement: HTMLCanvasElement) {\n        chartElement.addEventListener('mousedown', this._onMouseDown);\n        chartElement.addEventListener('mousemove', this._onMouseMove);\n        chartElement.addEventListener('mouseup', this._onMouseUp);\n        chartElement.addEventListener('mouseout', this._onMouseOut);\n        chartElement.addEventListener('click', this._onClick);\n    }\n\n    protected cleanupDomListeners(chartElement: HTMLCanvasElement) {\n        chartElement.removeEventListener('mousedown', this._onMouseDown);\n        chartElement.removeEventListener('mousemove', this._onMouseMove);\n        chartElement.removeEventListener('mouseup', this._onMouseUp);\n        chartElement.removeEventListener('mouseout', this._onMouseOut);\n        chartElement.removeEventListener('click', this._onClick);\n    }\n\n    // Should be available after first layout.\n    protected seriesRect?: BBox;\n\n    // x/y are local canvas coordinates in CSS pixels, not actual pixels\n    private pickSeriesNode(x: number, y: number): {\n        series: Series,\n        node: Node\n    } | undefined {\n        if (!this.seriesRect || !this.seriesRect.containsPoint(x, y)) {\n            return undefined;\n        }\n\n        const allSeries = this.series;\n        let node: Node | undefined = undefined;\n        for (let i = allSeries.length - 1; i >= 0; i--) {\n            const series = allSeries[i];\n            node = series.group.pickNode(x, y);\n            if (node) {\n                return {\n                    series,\n                    node\n                };\n            }\n        }\n    }\n\n    lastPick?: {\n        datum: SeriesNodeDatum;\n        node?: Shape; // We may not always have an associated node, for example\n                      // when line series are rendered without markers.\n        event?: MouseEvent;\n    };\n\n    // Provided x/y are in canvas coordinates.\n    private pickClosestSeriesNodeDatum(x: number, y: number): SeriesNodeDatum | undefined {\n        if (!this.seriesRect || !this.seriesRect.containsPoint(x, y)) {\n            return undefined;\n        }\n\n        const allSeries = this.series;\n\n        type Point = { x: number, y: number};\n\n        function getDistance(p1: Point, p2: Point): number {\n            return Math.sqrt((p1.x - p2.x)**2 + (p1.y - p2.y)**2);\n        }\n\n        let minDistance = Infinity;\n        let closestDatum: SeriesNodeDatum | undefined;\n\n        for (let i = allSeries.length - 1; i >= 0; i--) {\n            const series = allSeries[i];\n            if (!series.visible) {\n                continue;\n            }\n            const hitPoint = series.group.transformPoint(x, y);\n            series.getNodeData().forEach(datum => {\n                if (!datum.point) {\n                    return;\n                }\n                const distance = getDistance(hitPoint, datum.point);\n                if (distance < minDistance) {\n                    minDistance = distance;\n                    closestDatum = datum;\n                }\n            });\n        }\n\n        if (closestDatum) {\n            return closestDatum;\n        }\n    }\n\n    private _onMouseDown = this.onMouseDown.bind(this);\n    private _onMouseUp = this.onMouseUp.bind(this);\n    private _onMouseMove = this.onMouseMove.bind(this);\n    private _onMouseOut = this.onMouseOut.bind(this);\n    private _onClick = this.onClick.bind(this);\n\n    protected onMouseMove(event: MouseEvent) {\n        if (this.tooltip.enabled) {\n            if (this.tooltip.delay > 0) {\n                this.tooltip.toggle(false);\n            }\n            this.handleTooltip(event);\n        }\n    }\n\n    protected handleTooltip(event: MouseEvent) {\n        const { lastPick, tooltip: { tracking: tooltipTracking } } = this;\n        const { offsetX, offsetY } = event;\n        const pick = this.pickSeriesNode(offsetX, offsetY);\n        let nodeDatum: SeriesNodeDatum | undefined;\n\n        if (pick && pick.node instanceof Shape) {\n            const { node } = pick;\n            nodeDatum = node.datum as SeriesNodeDatum;\n            if (lastPick && lastPick.datum === nodeDatum) {\n                lastPick.node = node;\n                lastPick.event = event;\n            }\n            // Marker nodes will have the `point` info in their datums.\n            // Highlight if not a marker node or, if not in the tracking mode, highlight markers too.\n            if ((!node.datum.point || !tooltipTracking)) {\n                if (!lastPick // cursor moved from empty space to a node\n                    || lastPick.node !== node) { // cursor moved from one node to another\n                    this.onSeriesDatumPick(event, node.datum, node, event);\n                } else if (pick.series.tooltip.enabled) { // cursor moved within the same node\n                    this.tooltip.show(event);\n                }\n                // A non-marker node (takes precedence over marker nodes) was highlighted.\n                // Or we are not in the tracking mode.\n                // Either way, we are done at this point.\n                return;\n            }\n        }\n\n        let hideTooltip = false;\n        // In tracking mode a tooltip is shown for the closest rendered datum.\n        // This makes it easier to show tooltips when markers are small and/or plentiful\n        // and also gives the ability to show tooltips even when the series were configured\n        // to not render markers.\n        if (tooltipTracking) {\n            const closestDatum = this.pickClosestSeriesNodeDatum(offsetX, offsetY);\n            if (closestDatum && closestDatum.point) {\n                const { x, y } = closestDatum.point;\n                const { canvas } = this.scene;\n                const point = closestDatum.series.group.inverseTransformPoint(x, y);\n                const canvasRect = canvas.element.getBoundingClientRect();\n                this.onSeriesDatumPick({\n                    pageX: Math.round(canvasRect.left + window.pageXOffset + point.x),\n                    pageY: Math.round(canvasRect.top + window.pageYOffset + point.y)\n                }, closestDatum, nodeDatum === closestDatum && pick ? pick.node as Shape : undefined, event);\n            } else {\n                hideTooltip = true;\n            }\n        }\n\n        if (lastPick && (hideTooltip || !tooltipTracking)) {\n            // Cursor moved from a non-marker node to empty space.\n            this.dehighlightDatum();\n            this.tooltip.toggle(false);\n            this.lastPick = undefined;\n        }\n    }\n\n    protected onMouseDown(event: MouseEvent) {}\n    protected onMouseUp(event: MouseEvent) {}\n\n    protected onMouseOut(event: MouseEvent) {\n        this.tooltip.toggle(false);\n    }\n\n    protected onClick(event: MouseEvent) {\n        if (this.checkSeriesNodeClick()) {\n            return;\n        }\n        if (this.checkLegendClick(event)) {\n            return;\n        }\n        this.fireEvent<ChartClickEvent>({\n            type: 'click',\n            event\n        });\n    }\n\n    private checkSeriesNodeClick(): boolean {\n        const { lastPick } = this;\n\n        if (lastPick && lastPick.event && lastPick.node) {\n            const { event, datum } = lastPick;\n            datum.series.fireNodeClickEvent(event, datum);\n            return true;\n        }\n\n        return false;\n    }\n\n    private onSeriesNodeClick(event: SourceEvent<Series>) {\n        this.fireEvent({ ...event, type: 'seriesNodeClick' });\n    }\n\n    private checkLegendClick(event: MouseEvent): boolean {\n        const datum = this.legend.getDatumForPoint(event.offsetX, event.offsetY);\n\n        if (datum) {\n            const { id, itemId, enabled } = datum;\n            const series = find(this.series, series => series.id === id);\n\n            if (series) {\n                series.toggleSeriesItem(itemId, !enabled);\n                if (enabled) {\n                    this.tooltip.toggle(false);\n                }\n                this.legend.fireEvent<LegendClickEvent>({\n                    type: 'click',\n                    event,\n                    itemId,\n                    enabled: !enabled\n                });\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    private onSeriesDatumPick(meta: TooltipMeta, datum: SeriesNodeDatum, node?: Shape, event?: MouseEvent) {\n        if (this.lastPick) {\n            this.dehighlightDatum();\n        }\n\n        this.lastPick = {\n            datum,\n            node,\n            event\n        };\n\n        this.highlightDatum(datum);\n\n        const html = datum.series.tooltip.enabled && datum.series.getTooltipHtml(datum);\n\n        if (html) {\n            this.tooltip.show(meta, html);\n        }\n    }\n\n    highlightedDatum?: SeriesNodeDatum;\n\n    highlightDatum(datum: SeriesNodeDatum): void {\n        this.highlightedDatum = datum;\n        this.series.forEach(s => s.onHighlightChange());\n    }\n\n    dehighlightDatum(): void {\n        if (this.highlightedDatum) {\n            this.highlightedDatum = undefined;\n            this.series.forEach(s => s.onHighlightChange());\n        }\n    }\n}\n","/Users/vitaliikravchenko/Sites/nova/client/src/charts/chart/series/cartesian/cartesianSeries.ts",[],"/Users/vitaliikravchenko/Sites/nova/client/src/charts/util/padding.ts",[],"/Users/vitaliikravchenko/Sites/nova/client/src/charts/util/observable.ts",[],"/Users/vitaliikravchenko/Sites/nova/client/src/charts/chart/chartAxis.ts",[],"/Users/vitaliikravchenko/Sites/nova/client/src/charts/scene/dropShadow.ts",[],"/Users/vitaliikravchenko/Sites/nova/client/src/charts/scene/group.ts",[],"/Users/vitaliikravchenko/Sites/nova/client/src/charts/caption.ts",[],"/Users/vitaliikravchenko/Sites/nova/client/src/charts/chart/navigator/navigatorMask.ts",[],"/Users/vitaliikravchenko/Sites/nova/client/src/charts/chart/navigator/navigator.ts",[],"/Users/vitaliikravchenko/Sites/nova/client/src/charts/chart/navigator/navigatorHandle.ts",[],"/Users/vitaliikravchenko/Sites/nova/client/src/charts/chart/axis/timeAxis.ts",[],"/Users/vitaliikravchenko/Sites/nova/client/src/charts/axis.ts",["500","501","502","503"],"import Scale from \"./scale/scale\";\nimport { Group } from \"./scene/group\";\nimport { Selection } from \"./scene/selection\";\nimport { Line } from \"./scene/shape/line\";\nimport { normalizeAngle360, normalizeAngle360Inclusive, toRadians } from \"./util/angle\";\nimport { Text, FontStyle, FontWeight } from \"./scene/shape/text\";\nimport { Arc } from \"./scene/shape/arc\";\nimport { Shape } from \"./scene/shape/shape\";\nimport { BBox } from \"./scene/bbox\";\nimport { Matrix } from \"./scene/matrix\";\nimport { Caption } from \"./caption\";\nimport { createId } from \"./util/id\";\n// import { Rect } from \"./scene/shape/rect\"; // debug (bbox)\n\nenum Tags {\n    Tick,\n    GridLine\n}\n\nexport interface GridStyle {\n    stroke?: string;\n    lineDash?: number[];\n}\n\nexport class AxisTick {\n    /**\n     * The line width to be used by axis ticks.\n     */\n    width: number = 1;\n\n    /**\n     * The line length to be used by axis ticks.\n     */\n    size: number = 6;\n\n    /**\n     * The color of the axis ticks.\n     * Use `undefined` rather than `rgba(0, 0, 0, 0)` to make the ticks invisible.\n     */\n    color?: string = 'rgba(195, 195, 195, 1)';\n\n    /**\n     * A hint of how many ticks to use (the exact number of ticks might differ),\n     * a `TimeInterval` or a `CountableTimeInterval`.\n     * For example:\n     *\n     *     axis.tick.count = 5;\n     *     axis.tick.count = year;\n     *     axis.tick.count = month.every(6);\n     */\n    count: any = 10;\n}\n\nexport interface AxisLabelFormatterParams {\n    value: any;\n    index: number;\n    fractionDigits?: number;\n    formatter?: (x: any) => string;\n    axis?: any;\n}\n\nexport class AxisLabel {\n\n    fontStyle?: FontStyle;\n\n    fontWeight?: FontWeight;\n\n    fontSize: number = 12;\n\n    fontFamily: string = 'Verdana, sans-serif';\n\n    /**\n     * The padding between the labels and the ticks.\n     */\n    padding: number = 5;\n\n    /**\n     * The color of the labels.\n     * Use `undefined` rather than `rgba(0, 0, 0, 0)` to make labels invisible.\n     */\n    color?: string = 'rgba(87, 87, 87, 1)';\n\n    /**\n     * Custom label rotation in degrees.\n     * Labels are rendered perpendicular to the axis line by default.\n     * Or parallel to the axis line, if the {@link parallel} is set to `true`.\n     * The value of this config is used as the angular offset/deflection\n     * from the default rotation.\n     */\n    rotation: number = 0;\n\n    /**\n     * By default labels and ticks are positioned to the left of the axis line.\n     * `true` positions the labels to the right of the axis line.\n     * However, if the axis is rotated, its easier to think in terms\n     * of this side or the opposite side, rather than left and right.\n     * We use the term `mirror` for conciseness, although it's not\n     * true mirroring - for example, when a label is rotated, so that\n     * it is inclined at the 45 degree angle, text flowing from north-west\n     * to south-east, ending at the tick to the left of the axis line,\n     * and then we set this config to `true`, the text will still be flowing\n     * from north-west to south-east, _starting_ at the tick to the right\n     * of the axis line.\n     */\n    mirrored: boolean = false;\n\n    /**\n     * Labels are rendered perpendicular to the axis line by default.\n     * Setting this config to `true` makes labels render parallel to the axis line\n     * and center aligns labels' text at the ticks.\n     */\n    parallel: boolean = false;\n\n    /**\n     * In case {@param value} is a number, the {@param fractionDigits} parameter will\n     * be provided as well. The `fractionDigits` corresponds to the number of fraction\n     * digits used by the tick step. For example, if the tick step is `0.0005`,\n     * the `fractionDigits` is 4.\n     */\n    formatter?: (params: AxisLabelFormatterParams) => string;\n\n    onFormatChange?: (format?: string) => void;\n\n    private _format?: string;\n    set format(value: string | undefined) {\n        // See `TimeLocaleObject` docs for the list of supported format directives.\n        if (this._format !== value) {\n            this._format = value;\n            if (this.onFormatChange) {\n                this.onFormatChange(value);\n            }\n        }\n    }\n    get format(): string | undefined {\n        return this._format;\n    }\n}\n\n/**\n * A general purpose linear axis with no notion of orientation.\n * The axis is always rendered vertically, with horizontal labels positioned to the left\n * of the axis line by default. The axis can be {@link rotation | rotated} by an arbitrary angle,\n * so that it can be used as a top, right, bottom, left, radial or any other kind\n * of linear axis.\n * The generic `D` parameter is the type of the domain of the axis' scale.\n * The output range of the axis' scale is always numeric (screen coordinates).\n */\nexport class Axis<S extends Scale<D, number>, D = any> {\n\n    // debug (bbox)\n    // private bboxRect = (() => {\n    //     const rect = new Rect();\n    //     rect.fill = undefined;\n    //     rect.stroke = 'red';\n    //     rect.strokeWidth = 1;\n    //     rect.strokeOpacity = 0.2;\n    //     return rect;\n    // })();\n\n    readonly id = createId(this);\n\n    private groupSelection: Selection<Group, Group, D, D>;\n    private lineNode = new Line();\n\n    readonly group = new Group();\n\n    readonly line: {\n        /**\n         * The line width to be used by the axis line.\n         */\n        width: number,\n        /**\n         * The color of the axis line.\n         * Use `undefined` rather than `rgba(0, 0, 0, 0)` to make the axis line invisible.\n         */\n        color?: string\n    } = {\n            width: 1,\n            color: 'rgba(195, 195, 195, 1)'\n        };\n\n    readonly tick = new AxisTick();\n    readonly label = new AxisLabel();\n\n    readonly translation = { x: 0, y: 0 };\n    rotation: number = 0; // axis rotation angle in degrees\n\n    getMeta(): any {}\n\n    constructor(public readonly scale: S) {\n        this.scale = scale;\n        this.requestedRange = scale.range.slice();\n        this.groupSelection = Selection.select(this.group).selectAll<Group>();\n        this.label.onFormatChange = this.onTickFormatChange.bind(this);\n        this.group.append(this.lineNode);\n        this.onTickFormatChange();\n        // this.group.append(this.bboxRect); // debug (bbox)\n    }\n\n    protected updateRange() {\n        const { requestedRange: rr, visibleRange: vr, scale } = this;\n        const span = (rr[1] - rr[0]) / (vr[1] - vr[0]);\n        const shift = span * vr[0];\n        const start = rr[0] - shift;\n\n        scale.range = [start, start + span];\n    }\n\n    /**\n     * Checks if a point or an object is in range.\n     * @param x A point (or object's starting point).\n     * @param width Object's width.\n     * @param tolerance Expands the range on both ends by this amount.\n     */\n    inRange(x: number, width = 0, tolerance = 0): boolean {\n        return this.inRangeEx(x, width, tolerance) === 0;\n    }\n\n    inRangeEx(x: number, width = 0, tolerance = 0): -1 | 0 | 1 {\n        const { range } = this;\n        if ((x + width) < (range[0] - tolerance)) {\n            return -1; // left or range\n        }\n        if (x > (range[1] + tolerance)) {\n            return 1; // right of range\n        }\n        return 0; // in range\n    }\n\n    protected requestedRange: number[];\n    set range(value: number[]) {\n        this.requestedRange = value.slice();\n        this.updateRange();\n    }\n    get range(): number[] {\n        return this.requestedRange.slice();\n    }\n\n    protected _visibleRange: number[] = [0, 1];\n    set visibleRange(value: number[]) {\n        if (value && value.length === 2) {\n            let [min, max] = value;\n            min = Math.max(0, min);\n            max = Math.min(1, max);\n            min = Math.min(min, max);\n            max = Math.max(min, max);\n            this._visibleRange = [min, max];\n            this.updateRange();\n        }\n    }\n    get visibleRange(): number[] {\n        return this._visibleRange.slice();\n    }\n\n    set domain(value: D[]) {\n        this.scale.domain = value.slice();\n    }\n    get domain(): D[] {\n        return this.scale.domain.slice();\n    }\n\n    private tickFormatter?: (datum: any) => string;\n    private onTickFormatChange(format?: string) {\n        if (format) {\n            if (this.scale.tickFormat) {\n                this.tickFormatter = this.scale.tickFormat(10, format);\n            }\n        } else {\n            if (this.scale.tickFormat) {\n                this.tickFormatter = this.scale.tickFormat(10, undefined);\n            } else {\n                this.tickFormatter = undefined;\n            }\n        }\n    }\n\n    protected _title: Caption | undefined = undefined;\n    set title(value: Caption | undefined) {\n        const oldTitle = this._title;\n        if (oldTitle !== value) {\n            if (oldTitle) {\n                this.group.removeChild(oldTitle.node);\n            }\n\n            if (value) {\n                value.node.rotation = -Math.PI / 2;\n                this.group.appendChild(value.node);\n            }\n\n            this._title = value;\n        }\n    }\n    get title(): Caption | undefined {\n        return this._title;\n    }\n\n    /**\n     * The length of the grid. The grid is only visible in case of a non-zero value.\n     * In case {@link radialGrid} is `true`, the value is interpreted as an angle\n     * (in degrees).\n     */\n    protected _gridLength: number = 0;\n    set gridLength(value: number) {\n        // Was visible and now invisible, or was invisible and now visible.\n        if (this._gridLength && !value || !this._gridLength && value) {\n            this.groupSelection = this.groupSelection.remove().setData([]);\n        }\n\n        this._gridLength = value;\n    }\n    get gridLength(): number {\n        return this._gridLength;\n    }\n\n    /**\n     * The array of styles to cycle through when rendering grid lines.\n     * For example, use two {@link GridStyle} objects for alternating styles.\n     * Contains only one {@link GridStyle} object by default, meaning all grid lines\n     * have the same style.\n     */\n    gridStyle: GridStyle[] = [{\n        stroke: 'rgba(219, 219, 219, 1)',\n        lineDash: [4, 2]\n    }];\n\n    /**\n     * `false` - render grid as lines of {@link gridLength} that extend the ticks\n     *           on the opposite side of the axis\n     * `true` - render grid as concentric circles that go through the ticks\n     */\n    private _radialGrid: boolean = false;\n    set radialGrid(value: boolean) {\n        if (this._radialGrid !== value) {\n            this._radialGrid = value;\n            this.groupSelection = this.groupSelection.remove().setData([]);\n        }\n    }\n    get radialGrid(): boolean {\n        return this._radialGrid;\n    }\n\n    /**\n     * Creates/removes/updates the scene graph nodes that constitute the axis.\n     * Supposed to be called _manually_ after changing _any_ of the axis properties.\n     * This allows to bulk set axis properties before updating the nodes.\n     * The node changes made by this method are rendered on the next animation frame.\n     * We could schedule this method call automatically on the next animation frame\n     * when any of the axis properties change (the way we do when properties of scene graph's\n     * nodes change), but this will mean that we first wait for the next animation\n     * frame to make changes to the nodes of the axis, then wait for another animation\n     * frame to render those changes. It's nice to have everything update automatically,\n     * but this extra level of async indirection will not just introduce an unwanted delay,\n     * it will also make it harder to reason about the program.\n     */\n    update() {\n        const { group, scale, tick, label, gridStyle, requestedRange } = this;\n        const requestedRangeMin = Math.min(requestedRange[0], requestedRange[1]);\n        const requestedRangeMax = Math.max(requestedRange[0], requestedRange[1]);\n        const rotation = toRadians(this.rotation);\n        const parallelLabels = label.parallel;\n        const labelRotation = normalizeAngle360(toRadians(label.rotation));\n\n        group.translationX = this.translation.x;\n        group.translationY = this.translation.y;\n        group.rotation = rotation;\n\n        const halfBandwidth = (scale.bandwidth || 0) / 2;\n\n        // The side of the axis line to position the labels on.\n        // -1 = left (default)\n        //  1 = right\n        const sideFlag = label.mirrored ? 1 : -1;\n        // When labels are parallel to the axis line, the `parallelFlipFlag` is used to\n        // flip the labels to avoid upside-down text, when the axis is rotated\n        // such that it is in the right hemisphere, i.e. the angle of rotation\n        // is in the [0, ] interval.\n        // The rotation angle is normalized, so that we have an easier time checking\n        // if it's in the said interval. Since the axis is always rendered vertically\n        // and then rotated, zero rotation means 12 (not 3) o-clock.\n        // -1 = flip\n        //  1 = don't flip (default)\n        const parallelFlipRotation = normalizeAngle360(rotation);\n        const parallelFlipFlag = !labelRotation && parallelFlipRotation >= 0 && parallelFlipRotation <= Math.PI ? -1 : 1;\n\n        const regularFlipRotation = normalizeAngle360(rotation - Math.PI / 2);\n        // Flip if the axis rotation angle is in the top hemisphere.\n        const regularFlipFlag = !labelRotation && regularFlipRotation >= 0 && regularFlipRotation <= Math.PI ? -1 : 1;\n\n        const alignFlag = labelRotation >= 0 && labelRotation <= Math.PI ? -1 : 1;\n\n        const ticks = scale.ticks!(this.tick.count);\n        const update = this.groupSelection.setData(ticks);\n        update.exit.remove();\n\n        const enter = update.enter.append(Group);\n        // Line auto-snaps to pixel grid if vertical or horizontal.\n        enter.append(Line).each(node => node.tag = Tags.Tick);\n\n        if (this.gridLength) {\n            if (this.radialGrid) {\n                enter.append(Arc).each(node => node.tag = Tags.GridLine);\n            } else {\n                enter.append(Line).each(node => node.tag = Tags.GridLine);\n            }\n        }\n        enter.append(Text);\n\n        const groupSelection = update.merge(enter);\n\n        groupSelection\n            .attrFn('translationY', function (_, datum) {\n                return Math.round(scale.convert(datum) + halfBandwidth);\n            })\n            .attrFn('visible', function (node) {\n                return node.translationY >= requestedRangeMin && node.translationY <= requestedRangeMax;\n            });\n\n        groupSelection.selectByTag<Line>(Tags.Tick)\n            .each(line => {\n                line.strokeWidth = tick.width;\n                line.stroke = tick.color;\n            })\n            .attr('x1', sideFlag * tick.size)\n            .attr('x2', 0)\n            .attr('y1', 0)\n            .attr('y2', 0);\n\n        if (this.gridLength && gridStyle.length) {\n            const styleCount = gridStyle.length;\n            let gridLines: Selection<Shape, Group, D, D>;\n\n            if (this.radialGrid) {\n                const angularGridLength = normalizeAngle360Inclusive(toRadians(this.gridLength));\n\n                gridLines = groupSelection.selectByTag<Arc>(Tags.GridLine)\n                    .each((arc, datum) => {\n                        const radius = Math.round(scale.convert(datum) + halfBandwidth);\n\n                        arc.centerX = 0;\n                        arc.centerY = scale.range[0] - radius;\n                        arc.endAngle = angularGridLength;\n                        arc.radiusX = radius;\n                        arc.radiusY = radius;\n                    });\n            } else {\n                gridLines = groupSelection.selectByTag<Line>(Tags.GridLine)\n                    .each(line => {\n                        line.x1 = 0;\n                        line.x2 = -sideFlag * this.gridLength;\n                        line.y1 = 0;\n                        line.y2 = 0;\n                        line.visible = Math.abs(line.parent!.translationY - scale.range[0]) > 1;\n                    });\n            }\n\n            gridLines.each((gridLine, _, index) => {\n                const style = gridStyle[index % styleCount];\n\n                gridLine.stroke = style.stroke;\n                gridLine.strokeWidth = tick.width;\n                gridLine.lineDash = style.lineDash;\n                gridLine.fill = undefined;\n            });\n        }\n\n        const { tickFormatter } = this;\n        const meta = this.getMeta();\n        // `ticks instanceof NumericTicks` doesn't work here, so we feature detect.\n        const fractionDigits = (ticks as any).fractionDigits >= 0 ? (ticks as any).fractionDigits : 0;\n\n        const labelSelection = groupSelection.selectByClass(Text)\n            .each((node, datum, index) => {\n                node.fontStyle = label.fontStyle;\n                node.fontWeight = label.fontWeight;\n                node.fontSize = label.fontSize;\n                node.fontFamily = label.fontFamily;\n                node.fill = label.color;\n                node.textBaseline = parallelLabels && !labelRotation\n                    ? (sideFlag * parallelFlipFlag === -1 ? 'hanging' : 'bottom')\n                    : 'middle';\n                node.text = label.formatter\n                    ? label.formatter({\n                        value: fractionDigits >= 0 ? datum : String(datum),\n                        index,\n                        fractionDigits,\n                        formatter: tickFormatter,\n                        axis: meta\n                    })\n                    : fractionDigits\n                        // the `datum` is a floating point number\n                        ? (datum as any as number).toFixed(fractionDigits)\n                        // the `datum` is an integer, a string or an object\n                        : tickFormatter\n                            ? tickFormatter(datum)\n                            : String(datum);\n                node.textAlign = parallelLabels\n                    ? labelRotation ? (sideFlag * alignFlag === -1 ? 'end' : 'start') : 'center'\n                    : sideFlag * regularFlipFlag === -1 ? 'end' : 'start';\n            });\n\n        const labelX = sideFlag * (tick.size + label.padding);\n        const autoRotation = parallelLabels\n            ? parallelFlipFlag * Math.PI / 2\n            : (regularFlipFlag === -1 ? Math.PI : 0);\n\n        labelSelection.each(label => {\n            label.x = labelX;\n            label.rotationCenterX = labelX;\n            label.rotation = autoRotation + labelRotation;\n        });\n\n        this.groupSelection = groupSelection;\n\n        // Render axis line.\n        const lineNode = this.lineNode;\n        lineNode.x1 = 0;\n        lineNode.x2 = 0;\n        lineNode.y1 = requestedRange[0];\n        lineNode.y2 = requestedRange[1];\n        lineNode.strokeWidth = this.line.width;\n        lineNode.stroke = this.line.color;\n        lineNode.visible = ticks.length > 0;\n\n        const title = this.title;\n\n        let titleVisible = false;\n        if (title && title.enabled) {\n            titleVisible = true;\n            const padding = title.padding.bottom;\n            const titleNode = title.node;\n            const bbox = this.computeBBox({ excludeTitle: true });\n            const titleRotationFlag = sideFlag === -1 && parallelFlipRotation > Math.PI && parallelFlipRotation < Math.PI * 2 ? -1 : 1;\n\n            titleNode.rotation = titleRotationFlag * sideFlag * Math.PI / 2;\n            titleNode.x = titleRotationFlag * sideFlag * (lineNode.y1 + lineNode.y2) / 2;\n            titleNode.x = titleRotationFlag * sideFlag * (requestedRange[0] + requestedRange[1]) / 2;\n\n            if (sideFlag === -1) {\n                titleNode.y = titleRotationFlag * (-padding - bbox.width + Math.max(bbox.x + bbox.width, 0));\n            } else {\n                titleNode.y = -padding - bbox.width - Math.min(bbox.x, 0);\n            }\n            // title.text = `Axis Title: ${sideFlag} ${toDegrees(parallelFlipRotation).toFixed(0)} ${titleRotationFlag}`;\n            titleNode.textBaseline = titleRotationFlag === 1 ? 'bottom' : 'top';\n        }\n        if (title) {\n            title.node.visible = titleVisible;\n        }\n\n        // debug (bbox)\n        // const bbox = this.computeBBox();\n        // const bboxRect = this.bboxRect;\n        // bboxRect.x = bbox.x;\n        // bboxRect.y = bbox.y;\n        // bboxRect.width = bbox.width;\n        // bboxRect.height = bbox.height;\n    }\n\n    computeBBox(options?: { excludeTitle: boolean }): BBox {\n        const { title, lineNode } = this;\n        const labels = this.groupSelection.selectByClass(Text);\n\n        let left = Infinity;\n        let right = -Infinity;\n        let top = Infinity;\n        let bottom = -Infinity;\n\n        labels.each(label => {\n            // The label itself is rotated, but not translated, the group that\n            // contains it is. So to capture the group transform in the label bbox\n            // calculation we combine the transform matrices of the label and the group.\n            // Depending on the timing of the `axis.computeBBox()` method call, we may\n            // not have the group's and the label's transform matrices updated yet (because\n            // the transform matrix is not recalculated whenever a node's transform attributes\n            // change, instead it's marked for recalculation on the next frame by setting\n            // the node's `dirtyTransform` flag to `true`), so we force them to update\n            // right here by calling `computeTransformMatrix`.\n            label.computeTransformMatrix();\n            const matrix = Matrix.flyweight(label.matrix);\n            const group = label.parent!;\n            group.computeTransformMatrix();\n            matrix.preMultiplySelf(group.matrix);\n            const labelBBox = label.computeBBox();\n\n            if (labelBBox) {\n                const bbox = matrix.transformBBox(labelBBox);\n\n                left = Math.min(left, bbox.x);\n                right = Math.max(right, bbox.x + bbox.width);\n                top = Math.min(top, bbox.y);\n                bottom = Math.max(bottom, bbox.y + bbox.height);\n            }\n        });\n\n        if (title && title.enabled && (!options || !options.excludeTitle)) {\n            const label = title.node;\n            label.computeTransformMatrix();\n            const matrix = Matrix.flyweight(label.matrix);\n            const labelBBox = label.computeBBox();\n\n            if (labelBBox) {\n                const bbox = matrix.transformBBox(labelBBox);\n\n                left = Math.min(left, bbox.x);\n                right = Math.max(right, bbox.x + bbox.width);\n                top = Math.min(top, bbox.y);\n                bottom = Math.max(bottom, bbox.y + bbox.height);\n            }\n        }\n\n        left = Math.min(left, 0);\n        right = Math.max(right, 0);\n        top = Math.min(top, lineNode.y1, lineNode.y2);\n        bottom = Math.max(bottom, lineNode.y1, lineNode.y2);\n\n        return new BBox(\n            left,\n            top,\n            right - left,\n            bottom - top\n        );\n    }\n}\n","/Users/vitaliikravchenko/Sites/nova/client/src/charts/util/sizeMonitor.ts",[],"/Users/vitaliikravchenko/Sites/nova/client/src/charts/scene/shape/rect.ts",[],"/Users/vitaliikravchenko/Sites/nova/client/src/charts/chart/series/seriesMarker.ts",[],"/Users/vitaliikravchenko/Sites/nova/client/src/charts/scene/shape/shape.ts",["504"],"import { Node } from \"../node\";\nimport { chainObjects } from \"../../util/object\";\nimport { DropShadow } from \"../dropShadow\";\n\nexport type ShapeLineCap = undefined | 'round' | 'square';  // null is for 'butt'\nexport type ShapeLineJoin = undefined | 'round' | 'bevel';  // null is for 'miter'\n\nexport abstract class Shape extends Node {\n    /**\n     * Creates a light-weight instance of the given shape (that serves as a template).\n     * The created instance only stores the properites set on the instance itself\n     * and the rest of the properties come via the prototype chain from the template.\n     * This can greatly reduce memory usage in cases where one has many simular shapes,\n     * for example, circles of different size, position and color. The exact memory usage\n     * reduction will depend on the size of the template and the number of own properties\n     * set on its lightweight instances, but will typically be around an order of magnitude\n     * or more.\n     *\n     * Note: template shapes are not supposed to be part of the scene graph (they should not\n     * have a parent).\n     *\n     * @param template\n     */\n    static createInstance<T extends Shape>(template: T): T {\n        const shape = Object.create(template);\n        shape._setParent(undefined);\n        shape.id = template.id + '-Instance-' + String(++template.lastInstanceId);\n        return shape;\n    }\n\n    private lastInstanceId = 0;\n\n    /**\n     * Defaults for style properties. Note that properties that affect the position\n     * and shape of the node are not considered style properties, for example:\n     * `x`, `y`, `width`, `height`, `radius`, `rotation`, etc.\n     * Can be used to reset to the original styling after some custom styling\n     * has been applied (using the `restoreOwnStyles` and `restoreAllStyles` methods).\n     * These static defaults are meant to be inherited by subclasses.\n     */\n    protected static defaultStyles = chainObjects({}, {\n        fill: 'black',\n        stroke: undefined,\n        strokeWidth: 0,\n        lineDash: undefined,\n        lineDashOffset: 0,\n        lineCap: undefined as ShapeLineCap,\n        lineJoin: undefined as ShapeLineJoin,\n        opacity: 1,\n        fillShadow: undefined,\n        strokeShadow: undefined\n    });\n\n    /**\n     * Restores the default styles introduced by this subclass.\n     */\n    protected restoreOwnStyles() {\n        const styles = (this.constructor as any).defaultStyles;\n        const keys = Object.getOwnPropertyNames(styles);\n\n        // getOwnPropertyNames is about 2.5 times faster than\n        // for..in with the hasOwnProperty check and in this\n        // case, where most properties are inherited, can be\n        // more then an order of magnitude faster.\n        for (let i = 0, n = keys.length; i < n; i++) {\n            const key = keys[i];\n            (this as any)[key] = styles[key];\n        }\n    }\n\n    protected restoreAllStyles() {\n        const styles = (this.constructor as any).defaultStyles;\n\n        for (const property in styles) {\n            (this as any)[property] = styles[property];\n        }\n    }\n\n    /**\n     * Restores the base class default styles that have been overridden by this subclass.\n     */\n    protected restoreOverriddenStyles() {\n        const styles = (this.constructor as any).defaultStyles;\n        const protoStyles = Object.getPrototypeOf(styles);\n\n        for (const property in styles) {\n            if (styles.hasOwnProperty(property) && protoStyles.hasOwnProperty(property)) {\n                (this as any)[property] = styles[property];\n            }\n        }\n    }\n\n    protected _fillOpacity: number = 1;\n    set fillOpacity(value: number) {\n        if (this._fillOpacity !== value) {\n            this._fillOpacity = value;\n            this.dirty = true;\n        }\n    }\n    get fillOpacity(): number {\n        return this._fillOpacity;\n    }\n\n    protected _strokeOpacity: number = 1;\n    set strokeOpacity(value: number) {\n        if (this._strokeOpacity !== value) {\n            this._strokeOpacity = value;\n            this.dirty = true;\n        }\n    }\n    get strokeOpacity(): number {\n        return this._strokeOpacity;\n    }\n\n    protected _fill: string | undefined = Shape.defaultStyles.fill;\n    set fill(value: string | undefined) {\n        if (this._fill !== value) {\n            this._fill = value;\n            this.dirty = true;\n        }\n    }\n    get fill(): string | undefined {\n        return this._fill;\n    }\n\n    /**\n     * Note that `strokeStyle = null` means invisible stroke,\n     * while `lineWidth = 0` means no stroke, and sometimes this can mean different things.\n     * For example, a rect shape with an invisible stroke may not align to the pixel grid\n     * properly because the stroke affects the rules of alignment, and arc shapes forming\n     * a pie chart will have a gap between them if they have an invisible stroke, whereas\n     * there would be not gap if there was no stroke at all.\n     * The preferred way of making the stroke invisible is setting the `lineWidth` to zero,\n     * unless specific looks that is achieved by having an invisible stroke is desired.\n     */\n    protected _stroke: string | undefined = Shape.defaultStyles.stroke;\n    set stroke(value: string | undefined) {\n        if (this._stroke !== value) {\n            this._stroke = value;\n            this.dirty = true;\n        }\n    }\n    get stroke(): string | undefined {\n        return this._stroke;\n    }\n\n    protected _strokeWidth: number = Shape.defaultStyles.strokeWidth;\n    set strokeWidth(value: number) {\n        if (this._strokeWidth !== value) {\n            this._strokeWidth = value;\n            this.dirty = true;\n        }\n    }\n    get strokeWidth(): number {\n        return this._strokeWidth;\n    }\n\n    // An offset value to align to the pixel grid.\n    get alignment(): number {\n        return Math.floor(this.strokeWidth) % 2 / 2;\n    }\n    // Returns the aligned `start` or `length` value.\n    // For example: `start` could be `y` and `length` could be `height` of a rectangle.\n    align(alignment: number, start: number, length?: number) {\n        if (length != undefined) {\n            return Math.floor(length) + Math.floor(start % 1 + length % 1);\n        }\n        return Math.floor(start) + alignment;\n    }\n\n    protected _lineDash: number[] | undefined = Shape.defaultStyles.lineDash;\n    set lineDash(value: number[] | undefined) {\n        const oldValue = this._lineDash;\n\n        if (oldValue !== value) {\n            if (oldValue && value && oldValue.length === value.length) {\n                let identical = true;\n                const n = value.length;\n                for (let i = 0; i < n; i++) {\n                    if (oldValue[i] !== value[i]) {\n                        identical = false;\n                        break;\n                    }\n                }\n                if (identical) {\n                    return;\n                }\n            }\n            this._lineDash = value;\n            this.dirty = true;\n        }\n    }\n    get lineDash(): number[] | undefined {\n        return this._lineDash;\n    }\n\n    protected _lineDashOffset: number = Shape.defaultStyles.lineDashOffset;\n    set lineDashOffset(value: number) {\n        if (this._lineDashOffset !== value) {\n            this._lineDashOffset = value;\n            this.dirty = true;\n        }\n    }\n    get lineDashOffset(): number {\n        return this._lineDashOffset;\n    }\n\n    protected _lineCap: ShapeLineCap = Shape.defaultStyles.lineCap;\n    set lineCap(value: ShapeLineCap) {\n        if (this._lineCap !== value) {\n            this._lineCap = value;\n            this.dirty = true;\n        }\n    }\n    get lineCap(): ShapeLineCap {\n        return this._lineCap;\n    }\n\n    protected _lineJoin: ShapeLineJoin = Shape.defaultStyles.lineJoin;\n    set lineJoin(value: ShapeLineJoin) {\n        if (this._lineJoin !== value) {\n            this._lineJoin = value;\n            this.dirty = true;\n        }\n    }\n    get lineJoin(): ShapeLineJoin {\n        return this._lineJoin;\n    }\n\n    protected _opacity: number = Shape.defaultStyles.opacity;\n    set opacity(value: number) {\n        value = Math.min(1, Math.max(0, value));\n        if (this._opacity !== value) {\n            this._opacity = value;\n            this.dirty = true;\n        }\n    }\n    get opacity(): number {\n        return this._opacity;\n    }\n\n    private readonly onShadowChange = () => {\n        this.dirty = true;\n    }\n\n    protected _fillShadow: DropShadow | undefined = Shape.defaultStyles.fillShadow;\n    set fillShadow(value: DropShadow | undefined) {\n        const oldValue = this._fillShadow;\n        if (oldValue !== value) {\n            if (oldValue) {\n                oldValue.removeEventListener('change', this.onShadowChange);\n            }\n            if (value) {\n                value.addEventListener('change', this.onShadowChange);\n            }\n            this._fillShadow = value;\n            this.dirty = true;\n        }\n    }\n    get fillShadow(): DropShadow | undefined {\n        return this._fillShadow;\n    }\n\n    protected _strokeShadow: DropShadow | undefined = Shape.defaultStyles.strokeShadow;\n    set strokeShadow(value: DropShadow | undefined) {\n        const oldValue = this._strokeShadow;\n        if (oldValue !== value) {\n            if (oldValue) {\n                oldValue.removeEventListener('change', this.onShadowChange);\n            }\n            if (value) {\n                value.addEventListener('change', this.onShadowChange);\n            }\n            this._strokeShadow = value;\n            this.dirty = true;\n        }\n    }\n    get strokeShadow(): DropShadow | undefined {\n        return this._strokeShadow;\n    }\n\n    protected fillStroke(ctx: CanvasRenderingContext2D) {\n        if (!this.scene) {\n            return;\n        }\n\n        const pixelRatio = this.scene.canvas.pixelRatio || 1;\n\n        if (this.fill) {\n            ctx.fillStyle = this.fill;\n            ctx.globalAlpha = this.opacity * this.fillOpacity;\n\n            // The canvas context scaling (depends on the device's pixel ratio)\n            // has no effect on shadows, so we have to account for the pixel ratio\n            // manually here.\n            const fillShadow = this.fillShadow;\n            if (fillShadow && fillShadow.enabled) {\n                ctx.shadowColor = fillShadow.color;\n                ctx.shadowOffsetX = fillShadow.xOffset * pixelRatio;\n                ctx.shadowOffsetY = fillShadow.yOffset * pixelRatio;\n                ctx.shadowBlur = fillShadow.blur * pixelRatio;\n            }\n            ctx.fill();\n        }\n\n        ctx.shadowColor = 'rgba(0, 0, 0, 0)';\n\n        if (this.stroke && this.strokeWidth) {\n            ctx.strokeStyle = this.stroke;\n            ctx.globalAlpha = this.opacity * this.strokeOpacity;\n\n            ctx.lineWidth = this.strokeWidth;\n            if (this.lineDash) {\n                ctx.setLineDash(this.lineDash);\n            }\n            if (this.lineDashOffset) {\n                ctx.lineDashOffset = this.lineDashOffset;\n            }\n            if (this.lineCap) {\n                ctx.lineCap = this.lineCap;\n            }\n            if (this.lineJoin) {\n                ctx.lineJoin = this.lineJoin;\n            }\n\n            const strokeShadow = this.strokeShadow;\n            if (strokeShadow && strokeShadow.enabled) {\n                ctx.shadowColor = strokeShadow.color;\n                ctx.shadowOffsetX = strokeShadow.xOffset * pixelRatio;\n                ctx.shadowOffsetY = strokeShadow.yOffset * pixelRatio;\n                ctx.shadowBlur = strokeShadow.blur * pixelRatio;\n            }\n            ctx.stroke();\n        }\n    }\n\n    containsPoint(x: number, y: number): boolean {\n        return this.isPointInPath(x, y);\n    }\n\n    abstract isPointInPath(x: number, y: number): boolean;\n    abstract isPointInStroke(x: number, y: number): boolean;\n}\n","/Users/vitaliikravchenko/Sites/nova/client/src/charts/scene/node.ts",["505"],"import { Scene } from \"./scene\";\nimport { Matrix } from \"./matrix\";\nimport { BBox } from \"./bbox\";\nimport { createId } from \"../util/id\";\n\nexport enum PointerEvents {\n    All,\n    None\n}\n\n/**\n * Abstract scene graph node.\n * Each node can have zero or one parent and belong to zero or one scene.\n */\nexport abstract class Node { // Don't confuse with `window.Node`.\n\n    /**\n     * Unique node ID in the form `ClassName-NaturalNumber`.\n     */\n    readonly id = createId(this);\n\n    /**\n     * Some arbitrary data bound to the node.\n     */\n    datum: any;\n\n    /**\n     * Some number to identify this node, typically within a `Group` node.\n     * Usually this will be some enum value used as a selector.\n     */\n    tag: number = NaN;\n\n    /**\n     * This is meaningfully faster than `instanceof` and should be the preferred way\n     * of checking inside loops.\n     * @param node\n     */\n    static isNode(node: any): node is Node {\n        return node ? (node as Node).matrix !== undefined : false;\n    }\n\n    /**\n     * To simplify the type system (especially in Selections) we don't have the `Parent` node\n     * (one that has children). Instead, we mimic HTML DOM, where any node can have children.\n     * But we still need to distinguish regular leaf nodes from container leafs somehow.\n     */\n    protected isContainerNode: boolean = false;\n\n    // Note: _setScene and _setParent methods are not meant for end users,\n    // but they are not quite private either, rather, they have package level visibility.\n\n    protected _scene?: Scene;\n    _setScene(value?: Scene) {\n        this._scene = value;\n\n        const children = this.children;\n        const n = children.length;\n\n        for (let i = 0; i < n; i++) {\n            children[i]._setScene(value);\n        }\n    }\n    get scene(): Scene | undefined {\n        return this._scene;\n    }\n\n    private _parent?: Node;\n    _setParent(value?: Node) {\n        this._parent = value;\n    }\n    get parent(): Node | undefined {\n        return this._parent;\n    }\n\n    private _children: Node[] = [];\n    get children(): ReadonlyArray<Node> {\n        return this._children;\n    }\n\n    private static MAX_SAFE_INTEGER = Math.pow(2, 53) - 1; // Number.MAX_SAFE_INTEGER\n\n    countChildren(depth = Node.MAX_SAFE_INTEGER): number {\n        if (depth <= 0) {\n            return 0;\n        }\n\n        const children = this.children;\n        const n = children.length;\n        let size = n;\n\n        for (let i = 0; i < n; i++) {\n            size += children[i].countChildren(depth - 1);\n        }\n\n        return size;\n    }\n\n    // Used to check for duplicate nodes.\n    private childSet: { [id: string]: boolean } = {}; // new Set<Node>()\n\n    /**\n     * Appends one or more new node instances to this parent.\n     * If one needs to:\n     * - move a child to the end of the list of children\n     * - move a child from one parent to another (including parents in other scenes)\n     * one should use the {@link insertBefore} method instead.\n     * @param nodes A node or nodes to append.\n     */\n    append(nodes: Node[] | Node) {\n        // Passing a single parameter to an open-ended version of `append`\n        // would be 30-35% slower than this.\n        if (Node.isNode(nodes)) {\n            nodes = [nodes];\n        }\n        // The function takes an array rather than having open-ended\n        // arguments like `...nodes: Node[]` because the latter is\n        // transpiled to a function where the `arguments` object\n        // is copied to a temporary array inside a loop.\n        // So an array is created either way. And if we already have\n        // an array of nodes we want to add, we have to use the prohibitively\n        // expensive spread operator to pass it to the function,\n        // and, on top of that, the copy of the `arguments` is still made.\n        const n = nodes.length;\n\n        for (let i = 0; i < n; i++) {\n            const node = nodes[i];\n\n            if (node.parent) {\n                throw new Error(`${node} already belongs to another parent: ${node.parent}.`);\n            }\n            if (node.scene) {\n                throw new Error(`${node} already belongs a scene: ${node.scene}.`);\n            }\n            if (this.childSet[node.id]) {\n                // Cast to `any` to avoid `Property 'name' does not exist on type 'Function'`.\n                throw new Error(`Duplicate ${(node.constructor as any).name} node: ${node}`);\n            }\n\n            this._children.push(node);\n            this.childSet[node.id] = true;\n\n            node._setParent(this);\n            node._setScene(this.scene);\n        }\n\n        this.dirty = true;\n    }\n\n    appendChild<T extends Node>(node: T): T {\n        if (node.parent) {\n            throw new Error(`${node} already belongs to another parent: ${node.parent}.`);\n        }\n        if (node.scene) {\n            throw new Error(`${node} already belongs a scene: ${node.scene}.`);\n        }\n        if (this.childSet[node.id]) {\n            // Cast to `any` to avoid `Property 'name' does not exist on type 'Function'`.\n            throw new Error(`Duplicate ${(node.constructor as any).name} node: ${node}`);\n        }\n\n        this._children.push(node);\n        this.childSet[node.id] = true;\n\n        node._setParent(this);\n        node._setScene(this.scene);\n\n        this.dirty = true;\n\n        return node;\n    }\n\n    removeChild<T extends Node>(node: T): T {\n        if (node.parent === this) {\n            const i = this.children.indexOf(node);\n\n            if (i >= 0) {\n                this._children.splice(i, 1);\n                delete this.childSet[node.id];\n                node._setParent();\n                node._setScene();\n                this.dirty = true;\n\n                return node;\n            }\n        }\n        throw new Error(`The node to be removed is not a child of this node.`);\n    }\n\n    /**\n     * Inserts the node `node` before the existing child node `nextNode`.\n     * If `nextNode` is null, insert `node` at the end of the list of children.\n     * If the `node` belongs to another parent, it is first removed.\n     * Returns the `node`.\n     * @param node\n     * @param nextNode\n     */\n    insertBefore<T extends Node>(node: T, nextNode?: Node | null): T {\n        const parent = node.parent;\n\n        if (node.parent) {\n            node.parent.removeChild(node);\n        }\n\n        if (nextNode && nextNode.parent === this) {\n            const i = this.children.indexOf(nextNode);\n\n            if (i >= 0) {\n                this._children.splice(i, 0, node);\n                this.childSet[node.id] = true;\n                node._setParent(this);\n                node._setScene(this.scene);\n            } else {\n                throw new Error(`${nextNode} has ${parent} as the parent, `\n                    + `but is not in its list of children.`);\n            }\n\n            this.dirty = true;\n        } else {\n            this.append(node);\n        }\n\n        return node;\n    }\n\n    get nextSibling(): Node | undefined {\n        const { parent } = this;\n\n        if (parent) {\n            const { children } = parent;\n            const index = children.indexOf(this);\n\n            if (index >= 0 && index <= children.length - 1) {\n                return children[index + 1];\n            }\n        }\n    }\n\n    // These matrices may need to have package level visibility\n    // for performance optimization purposes.\n    matrix = new Matrix();\n    protected inverseMatrix = new Matrix();\n\n    transformPoint(x: number, y: number) {\n        const matrix = Matrix.flyweight(this.matrix);\n\n        let parent = this.parent;\n        while (parent) {\n            matrix.preMultiplySelf(parent.matrix);\n            parent = parent.parent;\n        }\n\n        return matrix.invertSelf().transformPoint(x, y);\n    }\n\n    inverseTransformPoint(x: number, y: number) {\n        const matrix = Matrix.flyweight(this.matrix);\n\n        let parent = this.parent;\n        while (parent) {\n            matrix.preMultiplySelf(parent.matrix);\n            parent = parent.parent;\n        }\n\n        return matrix.transformPoint(x, y);\n    }\n\n    private _dirtyTransform = false;\n    set dirtyTransform(value: boolean) {\n        this._dirtyTransform = value;\n        if (value) {\n            this.dirty = true;\n        }\n    }\n    get dirtyTransform(): boolean {\n        return this._dirtyTransform;\n    }\n\n    private _scalingX: number = 1;\n    set scalingX(value: number) {\n        if (this._scalingX !== value) {\n            this._scalingX = value;\n            this.dirtyTransform = true;\n        }\n    }\n    get scalingX(): number {\n        return this._scalingX;\n    }\n\n    private _scalingY: number = 1;\n    set scalingY(value: number) {\n        if (this._scalingY !== value) {\n            this._scalingY = value;\n            this.dirtyTransform = true;\n        }\n    }\n    get scalingY(): number {\n        return this._scalingY;\n    }\n\n    /**\n     * The center of scaling.\n     * The default value of `null` means the scaling center will be\n     * determined automatically, as the center of the bounding box\n     * of a node.\n     */\n    private _scalingCenterX: number | null = null;\n    set scalingCenterX(value: number | null) {\n        if (this._scalingCenterX !== value) {\n            this._scalingCenterX = value;\n            this.dirtyTransform = true;\n        }\n    }\n    get scalingCenterX(): number | null {\n        return this._scalingCenterX;\n    }\n\n    private _scalingCenterY: number | null = null;\n    set scalingCenterY(value: number | null) {\n        if (this._scalingCenterY !== value) {\n            this._scalingCenterY = value;\n            this.dirtyTransform = true;\n        }\n    }\n    get scalingCenterY(): number | null {\n        return this._scalingCenterY;\n    }\n\n    private _rotationCenterX: number | null = null;\n    set rotationCenterX(value: number | null) {\n        if (this._rotationCenterX !== value) {\n            this._rotationCenterX = value;\n            this.dirtyTransform = true;\n        }\n    }\n    get rotationCenterX(): number | null {\n        return this._rotationCenterX;\n    }\n\n    private _rotationCenterY: number | null = null;\n    set rotationCenterY(value: number | null) {\n        if (this._rotationCenterY !== value) {\n            this._rotationCenterY = value;\n            this.dirtyTransform = true;\n        }\n    }\n    get rotationCenterY(): number | null {\n        return this._rotationCenterY;\n    }\n\n    /**\n     * Rotation angle in radians.\n     * The value is set as is. No normalization to the [-180, 180) or [0, 360)\n     * interval is performed.\n     */\n    private _rotation: number = 0;\n    set rotation(value: number) {\n        if (this._rotation !== value) {\n            this._rotation = value;\n            this.dirtyTransform = true;\n        }\n    }\n    get rotation(): number {\n        return this._rotation;\n    }\n\n    /**\n     * For performance reasons the rotation angle's internal representation\n     * is in radians. Therefore, don't expect to get the same number you set.\n     * Even with integer angles about a quarter of them from 0 to 359 cannot\n     * be converted to radians and back without precision loss.\n     * For example:\n     *\n     *     node.rotationDeg = 11;\n     *     console.log(node.rotationDeg); // 10.999999999999998\n     *\n     * @param value Rotation angle in degrees.\n     */\n    set rotationDeg(value: number) {\n        this.rotation = value / 180 * Math.PI;\n    }\n    get rotationDeg(): number {\n        return this.rotation / Math.PI * 180;\n    }\n\n    private _translationX: number = 0;\n    set translationX(value: number) {\n        if (this._translationX !== value) {\n            this._translationX = value;\n            this.dirtyTransform = true;\n        }\n    }\n    get translationX(): number {\n        return this._translationX;\n    }\n\n    private _translationY: number = 0;\n    set translationY(value: number) {\n        if (this._translationY !== value) {\n            this._translationY = value;\n            this.dirtyTransform = true;\n        }\n    }\n    get translationY(): number {\n        return this._translationY;\n    }\n\n    containsPoint(x: number, y: number): boolean {\n        return false;\n    }\n\n    /**\n     * Hit testing method.\n     * Recursively checks if the given point is inside this node or any of its children.\n     * Returns the first matching node or `undefined`.\n     * Nodes that render later (show on top) are hit tested first.\n     * @param x\n     * @param y\n     */\n    pickNode(x: number, y: number): Node | undefined {\n        if (!this.visible || this.pointerEvents === PointerEvents.None || !this.containsPoint(x, y)) {\n            return;\n        }\n\n        const children = this.children;\n\n        if (children.length) {\n            // Nodes added later should be hit-tested first,\n            // as they are rendered on top of the previously added nodes.\n            for (let i = children.length - 1; i >= 0; i--) {\n                const hit = children[i].pickNode(x, y);\n                if (hit) {\n                    return hit;\n                }\n            }\n        } else if (!this.isContainerNode) { // a leaf node, but not a container leaf\n            return this;\n        }\n    }\n\n    computeBBox(): BBox | undefined { return; }\n\n    computeBBoxCenter(): [number, number] {\n        const bbox = this.computeBBox && this.computeBBox();\n        if (bbox) {\n            return [\n                bbox.x + bbox.width * 0.5,\n                bbox.y + bbox.height * 0.5\n            ];\n        }\n        return [0, 0];\n    }\n\n    computeTransformMatrix() {\n        // TODO: transforms without center of scaling and rotation correspond directly\n        //       to `setAttribute('transform', 'translate(tx, ty) rotate(rDeg) scale(sx, sy)')`\n        //       in SVG. Our use cases will mostly require positioning elements (rects, circles)\n        //       within a group, rotating groups at right angles (e.g. for axis) and translating\n        //       groups. We shouldn't even need `scale(1, -1)` (invert vertically), since this\n        //       can be done using D3-like scales already by inverting the output range.\n        //       So for now, just assume that centers of scaling and rotation are at the origin.\n        // const [bbcx, bbcy] = this.computeBBoxCenter();\n        const [bbcx, bbcy] = [0, 0];\n\n        const sx = this.scalingX;\n        const sy = this.scalingY;\n        let scx: number;\n        let scy: number;\n\n        if (sx === 1 && sy === 1) {\n            scx = 0;\n            scy = 0;\n        } else {\n            scx = this.scalingCenterX === null ? bbcx : this.scalingCenterX;\n            scy = this.scalingCenterY === null ? bbcy : this.scalingCenterY;\n        }\n\n        const r = this.rotation;\n        const cos = Math.cos(r);\n        const sin = Math.sin(r);\n        let rcx: number;\n        let rcy: number;\n\n        if (r === 0) {\n            rcx = 0;\n            rcy = 0;\n        } else {\n            rcx = this.rotationCenterX === null ? bbcx : this.rotationCenterX;\n            rcy = this.rotationCenterY === null ? bbcy : this.rotationCenterY;\n        }\n\n        const tx = this.translationX;\n        const ty = this.translationY;\n\n        // The transform matrix `M` is a result of the following transformations:\n        // 1) translate the center of scaling to the origin\n        // 2) scale\n        // 3) translate back\n        // 4) translate the center of rotation to the origin\n        // 5) rotate\n        // 6) translate back\n        // 7) translate\n        //         (7)          (6)             (5)             (4)           (3)           (2)           (1)\n        //     | 1 0 tx |   | 1 0 rcx |   | cos -sin 0 |   | 1 0 -rcx |   | 1 0 scx |   | sx 0 0 |   | 1 0 -scx |\n        // M = | 0 1 ty | * | 0 1 rcy | * | sin  cos 0 | * | 0 1 -rcy | * | 0 1 scy | * | 0 sy 0 | * | 0 1 -scy |\n        //     | 0 0  1 |   | 0 0  1  |   |  0    0  1 |   | 0 0  1   |   | 0 0  1  |   | 0  0 0 |   | 0 0  1   |\n\n        // Translation after steps 1-4 above:\n        const tx4 = scx * (1 - sx) - rcx;\n        const ty4 = scy * (1 - sy) - rcy;\n\n        this.dirtyTransform = false;\n\n        this.matrix.setElements([\n            cos * sx, sin * sx,\n            -sin * sy, cos * sy,\n            cos * tx4 - sin * ty4 + rcx + tx,\n            sin * tx4 + cos * ty4 + rcy + ty\n        ]).inverseTo(this.inverseMatrix);\n    }\n\n    /**\n     * Scene nodes start rendering with the {@link Scene.root | root},\n     * where the `render` call propagates from parent nodes to their children.\n     * The root rendering is initiated by the {@link Scene.render} method,\n     * so if the `render` method of a node is called, that node belongs to a scene,\n     * and there is no need to check if node's {@link Node._scene} property\n     * is defined inside node's `render` method. For example, instead of doing this:\n     *\n     *     this.scene.appendPath(this.path);\n     *\n     * it's safe to do this:\n     *\n     *     this.scene!.appendPath(this.path);\n     *\n     * @param ctx The 2D canvas rendering context.\n     */\n    abstract render(ctx: CanvasRenderingContext2D): void;\n\n    /**\n     * Each time a property of the node that effects how it renders changes\n     * the `dirty` property of the node should be set to `true`. The change\n     * to the `dirty` property of the node will propagate up to its parents\n     * and eventually to the scene, at which point an animation frame callback\n     * will be scheduled to rerender the scene and its nodes and reset the `dirty`\n     * flags of all nodes and the {@link Scene._dirty | Scene} back to `false`.\n     * Since changes to node properties are not rendered immediately, it's possible\n     * to change as many properties on as many nodes as needed and the rendering\n     * will still only happen once in the next animation frame callback.\n     * The animation frame callback is only scheduled if it hasn't been already.\n     */\n    private _dirty = true;\n    set dirty(value: boolean) {\n        // TODO: check if we are already dirty (e.g. if (this._dirty !== value))\n        //       if we are, then all parents and the scene have been\n        //       notified already, and we are doing redundant work\n        //       (but test if this is indeed the case)\n        this._dirty = value;\n        if (value) {\n            if (this.parent) {\n                this.parent.dirty = true;\n            } else if (this.scene) {\n                this.scene.dirty = true;\n            }\n        }\n    }\n    get dirty(): boolean {\n        return this._dirty;\n    }\n\n    private _visible: boolean = true;\n    set visible(value: boolean) {\n        if (this._visible !== value) {\n            this._visible = value;\n            this.dirty = true;\n        }\n    }\n    get visible(): boolean {\n        return this._visible;\n    }\n\n    pointerEvents: PointerEvents = PointerEvents.All;\n}\n","/Users/vitaliikravchenko/Sites/nova/client/src/charts/scene/shape/text.ts",[],"/Users/vitaliikravchenko/Sites/nova/client/src/charts/scene/matrix.ts",[],"/Users/vitaliikravchenko/Sites/nova/client/src/charts/scene/bbox.ts",[],"/Users/vitaliikravchenko/Sites/nova/client/src/charts/scene/scene.ts",[],"/Users/vitaliikravchenko/Sites/nova/client/src/charts/chart/shapes/rangeSelector.ts",[],"/Users/vitaliikravchenko/Sites/nova/client/src/charts/scale/timeScale.ts",["506","507"],"import ContinuousScale from \"./continuousScale\";\nimport timeMillisecond from \"../util/time/millisecond\";\nimport timeSecond from \"../util/time/second\";\nimport timeMinute from \"../util/time/minute\";\nimport timeHour from \"../util/time/hour\";\nimport timeDay from \"../util/time/day\";\nimport timeWeek from \"../util/time/week\";\nimport timeMonth from \"../util/time/month\";\nimport timeYear from \"../util/time/year\";\nimport {\n    durationSecond,\n    durationMinute,\n    durationHour,\n    durationDay,\n    durationWeek,\n    durationMonth,\n    durationYear\n} from \"../util/time/duration\";\nimport { CountableTimeInterval, TimeInterval } from \"../util/time/interval\";\nimport { complexBisectRight } from \"../util/bisect\";\nimport { tickStep } from \"../util/ticks\";\nimport { locale } from \"../util/time/format/defaultLocale\";\n\nexport class TimeScale extends ContinuousScale {\n\n    private year: CountableTimeInterval = timeYear;\n    private month: CountableTimeInterval = timeMonth;\n    private week: CountableTimeInterval = timeWeek;\n    private day: CountableTimeInterval = timeDay;\n    private hour: CountableTimeInterval = timeHour;\n    private minute: CountableTimeInterval = timeMinute;\n    private second: CountableTimeInterval = timeSecond;\n    private millisecond: CountableTimeInterval = timeMillisecond;\n    private format: (specifier: string) => (date: Date) => string = locale.format;\n\n    /**\n     * Array of default tick intervals in the following format:\n     *\n     *     [\n     *         interval (unit of time),\n     *         number of units (step),\n     *         the length of that number of units in milliseconds\n     *     ]\n     */\n    private tickIntervals: [CountableTimeInterval, number, number][] = [\n        [this.second,  1,      durationSecond],\n        [this.second,  5,  5 * durationSecond],\n        [this.second, 15, 15 * durationSecond],\n        [this.second, 30, 30 * durationSecond],\n        [this.minute,  1,      durationMinute],\n        [this.minute,  5,  5 * durationMinute],\n        [this.minute, 15, 15 * durationMinute],\n        [this.minute, 30, 30 * durationMinute],\n        [  this.hour,  1,      durationHour  ],\n        [  this.hour,  3,  3 * durationHour  ],\n        [  this.hour,  6,  6 * durationHour  ],\n        [  this.hour, 12, 12 * durationHour  ],\n        [   this.day,  1,      durationDay   ],\n        [   this.day,  2,  2 * durationDay   ],\n        [  this.week,  1,      durationWeek  ],\n        [ this.month,  1,      durationMonth ],\n        [ this.month,  3,  3 * durationMonth ],\n        [  this.year,  1,      durationYear  ]\n    ];\n\n    private formatMillisecond = this.format('.%L');\n    private formatSecond = this.format(':%S');\n    private formatMinute = this.format('%I:%M');\n    private formatHour = this.format('%I %p');\n    private formatDay = this.format('%a %d');\n    private formatWeek = this.format('%b %d');\n    private formatMonth = this.format('%B');\n    private formatYear = this.format('%Y');\n\n    defaultTickFormat(date: Date) {\n        return (this.second.floor(date) < date\n            ? this.formatMillisecond\n            : this.minute.floor(date) < date\n                ? this.formatSecond\n                : this.hour.floor(date) < date\n                    ? this.formatMinute\n                    : this.day.floor(date) < date\n                        ? this.formatHour\n                        : this.month.floor(date) < date\n                            ? (this.week.floor(date) < date ? this.formatDay : this.formatWeek)\n                            : this.year.floor(date) < date\n                                ? this.formatMonth\n                                : this.formatYear)(date);\n    }\n\n    /**\n     *\n     * @param interval If the `interval` is a number, it's interpreted as the desired tick count\n     * and the method tries to pick an appropriate interval automatically, based on the extent of the domain.\n     * If the `interval` is `undefined`, it defaults to `10`.\n     * If the `interval` is a time interval, simply use it.\n     * @param start The start time (timestamp).\n     * @param stop The end time (timestamp).\n     * @param step Number of intervals between ticks.\n     */\n    tickInterval(interval: number | CountableTimeInterval, start: number, stop: number, step?: number): CountableTimeInterval | TimeInterval | undefined {\n        if (typeof interval === 'number') {\n            const tickCount = interval;\n            const tickIntervals = this.tickIntervals;\n            const target = Math.abs(stop - start) / tickCount;\n            const i = complexBisectRight(tickIntervals, target, interval => interval[2]);\n            if (i === tickIntervals.length) {\n                step = tickStep(start / durationYear, stop / durationYear, tickCount);\n                interval = this.year;\n            } else if (i) {\n                [interval, step] = tickIntervals[target / tickIntervals[i - 1][2] < tickIntervals[i][2] / target ? i - 1 : i];\n            } else {\n                step = Math.max(tickStep(start, stop, interval), 1);\n                interval = this.millisecond;\n            }\n        }\n\n        return step == undefined ? interval : interval.every(step);\n    }\n\n    protected _domain: Date[] = [new Date(2000, 0, 1), new Date(2000, 0, 2)];\n    set domain(values: Date[]) {\n        super.setDomain(Array.prototype.map.call(values, (t: any) => t instanceof Date ? +t : +new Date(+t)));\n    }\n    get domain(): Date[] {\n        return super.getDomain().map((t: any) => new Date(t));\n    }\n\n    invert(y: number): Date {\n        return new Date(super.invert(y));\n    }\n\n    /**\n     * Returns uniformly-spaced dates that represent the scale's domain.\n     * @param interval The desired tick count or a time interval object.\n     */\n    ticks(interval: number | CountableTimeInterval = 10): Date[] {\n        const d = super.getDomain();\n        let t0 = d[0];\n        let t1 = d[d.length - 1];\n        const reverse = t1 < t0;\n\n        if (reverse) {\n            const _ = t0;\n            t0 = t1;\n            t1 = _;\n        }\n        const t = this.tickInterval(interval, t0, t1);\n        const i = t ? t.range(t0, t1 + 1) : []; // inclusive stop\n\n        return reverse ? i.reverse() : i;\n    }\n\n    /**\n     * Returns a time format function suitable for displaying tick values.\n     * @param count Ignored. Used only to satisfy the {@link Scale} interface.\n     * @param specifier If the specifier string is provided, this method is equivalent to\n     * the {@link TimeLocaleObject.format} method.\n     * If no specifier is provided, this method returns the default time format function.\n     */\n    tickFormat(count: any, specifier?: string): (date: Date) => string {\n        return specifier == undefined ? this.defaultTickFormat.bind(this) : this.format(specifier);\n    }\n\n    /**\n     * Extends the domain so that it starts and ends on nice round values.\n     * This method typically modifies the scales domain, and may only extend the bounds to the nearest round value.\n     * @param interval\n     */\n    nice(interval: number | CountableTimeInterval = 10): void {\n        const d = super.getDomain();\n        const i = this.tickInterval(interval, d[0], d[d.length - 1]);\n\n        if (i) {\n            this.domain = this._nice(d, i);\n        }\n    }\n\n    private _nice(domain: Date[], interval: TimeInterval): Date[] {\n        domain = domain.slice();\n        let i0 = 0;\n        let i1 = domain.length - 1;\n        let x0 = domain[i0];\n        let x1 = domain[i1];\n\n        if (x1 < x0) {\n            [i0, i1] = [i1, i0];\n            [x0, x1] = [x1, x0];\n        }\n\n        domain[i0] = interval.floor(x0);\n        domain[i1] = interval.ceil(x1);\n\n        return domain;\n    }\n}\n","/Users/vitaliikravchenko/Sites/nova/client/src/charts/scene/shape/path.ts",[],"/Users/vitaliikravchenko/Sites/nova/client/src/charts/chart/marker/circle.ts",[],"/Users/vitaliikravchenko/Sites/nova/client/src/charts/chart/shapes/rangeMask.ts",[],"/Users/vitaliikravchenko/Sites/nova/client/src/charts/chart/shapes/rangeHandle.ts",[],"/Users/vitaliikravchenko/Sites/nova/client/src/charts/util/ticks.ts",["508"],"export default function (a: number, b: number, count: number): NumericTicks {\n    const step = tickStep(a, b, count);\n    a = Math.ceil(a / step) * step;\n    b = Math.floor(b / step) * step + step / 2;\n    // Add half a step here so that the array returned by `range` includes the last tick.\n    return range(a, b, step);\n}\n\nconst e10 = Math.sqrt(50);\nconst e5 = Math.sqrt(10);\nconst e2 = Math.sqrt(2);\n\nexport function tickStep(a: number, b: number, count: number): number {\n    const rawStep = Math.abs(b - a) / Math.max(0, count);\n    let step = Math.pow(10, Math.floor(Math.log(rawStep) / Math.LN10)); // = Math.log10(rawStep)\n    const error = rawStep / step;\n\n    if (error >= e10) {\n        step *= 10;\n    } else if (error >= e5) {\n        step *= 5;\n    } else if (error >= e2) {\n        step *= 2;\n    }\n    return b < a ? -step : step;\n}\n\nexport function tickIncrement(a: number, b: number, count: number): number {\n    const rawStep = (b - a) / Math.max(0, count);\n    const power = Math.floor(Math.log(rawStep) / Math.LN10);\n    const error = rawStep / Math.pow(10, power);\n\n    return power >= 0\n        ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power)\n        : -Math.pow(10, -power) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);\n}\n\nexport class NumericTicks extends Array<number> {\n    readonly fractionDigits: number;\n\n    constructor(fractionDigits: number, size = 0) {\n        super(size);\n        this.fractionDigits = fractionDigits;\n    }\n}\n\nfunction range(a: number, b: number, step: number = 1): NumericTicks {\n    const absStep = Math.abs(step);\n    const fractionDigits = (absStep > 0 && absStep < 1)\n        ? Math.abs(Math.floor(Math.log(absStep) / Math.LN10))\n        : 0;\n    const f = Math.pow(10, fractionDigits);\n    const n = Math.max(0, Math.ceil((b - a) / step)) || 0;\n    const values = new NumericTicks(fractionDigits, n);\n\n    for (let i = 0; i < n; i++) {\n        const value = a + step * i;\n        values[i] = Math.round(value * f) / f;\n    }\n\n    return values;\n}\n","/Users/vitaliikravchenko/Sites/nova/client/src/charts/util/time/format/defaultLocale.ts",[],"/Users/vitaliikravchenko/Sites/nova/client/src/charts/util/time/duration.ts",[],"/Users/vitaliikravchenko/Sites/nova/client/src/charts/util/bisect.ts",[],"/Users/vitaliikravchenko/Sites/nova/client/src/charts/util/time/year.ts",[],"/Users/vitaliikravchenko/Sites/nova/client/src/charts/util/time/month.ts",[],"/Users/vitaliikravchenko/Sites/nova/client/src/charts/util/time/week.ts",[],"/Users/vitaliikravchenko/Sites/nova/client/src/charts/util/time/day.ts",[],"/Users/vitaliikravchenko/Sites/nova/client/src/charts/util/time/hour.ts",[],"/Users/vitaliikravchenko/Sites/nova/client/src/charts/util/time/minute.ts",[],"/Users/vitaliikravchenko/Sites/nova/client/src/charts/scene/path2D.ts",[],"/Users/vitaliikravchenko/Sites/nova/client/src/charts/util/time/second.ts",[],"/Users/vitaliikravchenko/Sites/nova/client/src/charts/chart/marker/marker.ts",[],"/Users/vitaliikravchenko/Sites/nova/client/src/charts/util/time/millisecond.ts",[],"/Users/vitaliikravchenko/Sites/nova/client/src/charts/scale/continuousScale.ts",["509"],"import interpolateValue from \"../interpolate/value\";\nimport interpolateNumber from \"../interpolate/number\";\nimport Scale, {\n    Deinterpolator,\n    Reinterpolator\n} from './scale';\n\nexport const constant = (x: any) => () => x;\nexport const identity = (x: any) => x;\n\nfunction clamper(domain: number[]): (x: number) => number {\n    let a = domain[0];\n    let b = domain[domain.length - 1];\n\n    if (a > b) {\n        [a, b] = [b, a];\n    }\n\n    return x => Math.max(a, Math.min(b, x));\n}\n\n/**\n * An Interpolator factory returns an interpolator function.\n *\n * The first generic corresponds to the data type of the interpolation boundaries.\n * The second generic corresponds to the data type of the return type of the interpolator.\n */\nexport interface InterpolatorFactory<T, U> {\n    /**\n     * Construct a new interpolator function, based on the provided interpolation boundaries.\n     *\n     * @param a Start boundary of the interpolation interval.\n     * @param b End boundary of the interpolation interval.\n     */\n    (a: T, b: T): ((t: number) => U);\n}\n\nexport default abstract class ContinuousScale implements Scale<any, any> {\n    /**\n     * The output value of the scale for `undefined` or `NaN` input values.\n     */\n    unknown: any = undefined;\n\n    constructor() {\n        this.rescale();\n    }\n\n    private _clamp = identity;\n    set clamp(value: boolean) {\n        this._clamp = value ? clamper(this.domain) : identity;\n    }\n    get clamp(): boolean {\n        return this._clamp !== identity;\n    }\n\n    protected _domain: any[] = [0, 1];\n    protected setDomain(values: any[]) {\n        this._domain = Array.prototype.map.call(values, (v: any) => +v);\n        if (this._clamp !== identity) {\n            this._clamp = clamper(this.domain);\n        }\n        this.rescale();\n    }\n    protected getDomain(): any[] {\n        return this._domain.slice();\n    }\n    set domain(values: any[]) {\n        this.setDomain(values);\n    }\n    get domain(): any[] {\n        return this.getDomain();\n    }\n\n    protected _range: any[] = [0, 1];\n    set range(values: any[]) {\n        this._range = Array.prototype.slice.call(values);\n        this.rescale();\n    }\n    get range(): any[] {\n        return this._range.slice();\n    }\n\n    private input?: (y: any) => any;   // y -> x\n    private output?: (x: any) => any;  // x -> y\n    private piecewise?: (domain: any[], range: any[], interpolate: (a: any, b: any) => (t: number) => any) => (x: any) => any;\n\n    protected transform: (x: any) => any = identity;   // transforms domain value\n    protected untransform: (x: any) => any = identity; // untransforms domain value\n\n    private _interpolate: (a: any, b: any) => (t: any) => any = interpolateValue;\n    set interpolate(value: any) {\n        this._interpolate = value;\n        this.rescale();\n    }\n    get interpolate(): any {\n        return this._interpolate;\n    }\n\n    protected rescale() {\n        if (Math.min(this.domain.length, this.range.length) > 2) {\n            // this.piecewise = this.polymap;\n        } else {\n            this.piecewise = this.bimap;\n        }\n        this.output = undefined;\n        this.input = undefined;\n    }\n\n    /**\n     * Returns a function that converts `x` in `[a, b]` to `t` in `[0, 1]`. Non-clamping.\n     * @param a\n     * @param b\n     */\n    private normalize(a: any, b: any): (x: any) => number {\n        return (b -= (a = +a))\n            ? (x: any) => (x - a) / b\n            : constant(isNaN(b) ? NaN : 0.5);\n    }\n\n    private bimap(domain: any[], range: any[], interpolate: (a: any, b: any) => (t: number) => any): (x: any) => any {\n        const x0 = domain[0];\n        const x1 = domain[1];\n        const y0 = range[0];\n        const y1 = range[1];\n\n        let xt: Deinterpolator<any>;\n        let ty: Reinterpolator<any>;\n\n        if (x1 < x0) {\n            xt = this.normalize(x1, x0);\n            ty = interpolate(y1, y0);\n        } else {\n            xt = this.normalize(x0, x1);\n            ty = interpolate(y0, y1);\n        }\n\n        return (x) => ty(xt(x)); // domain value x --> t in [0, 1] --> range value y\n    }\n\n    // private polymap(domain: any[], range: any[], interpolate: (a: any, b: any) => (t: number) => any): Reinterpolator<any> {\n    //     // number of segments in the polylinear scale\n    //     const n = Math.min(domain.length, range.length) - 1;\n\n    //     if (domain[n] < domain[0]) {\n    //         domain = domain.slice().reverse();\n    //         range = range.slice().reverse();\n    //     }\n\n    //     // deinterpolators from domain segment value to t\n    //     const dt = Array.from( {length: n}, (_, i) => this.normalize(domain[i], domain[i+1]) );\n    //     // reinterpolators from t to range segment value\n    //     const tr = Array.from( {length: n}, (_, i) => interpolate(range[i], range[i+1]) );\n\n    //     return (x) => {\n    //         const i = bisectRight(domain, x, ascending, 1, n) - 1; // Find the domain segment that `x` belongs to.\n    //         // This also tells us which deinterpolator/reinterpolator pair to use.\n    //         return tr[i](dt[i](x));\n    //     };\n    // }\n\n    convert(x: any): any {\n        x = +x;\n        if (isNaN(x)) {\n            return this.unknown;\n        } else {\n            if (!this.output) {\n                this.output = this.piecewise!(this.domain.map(this.transform), this.range, this.interpolate);\n            }\n            return this.output(this.transform(this._clamp(x)));\n        }\n    }\n\n    invert(y: any): any {\n        if (!this.input) {\n            this.input = this.piecewise!(this.range, this.domain.map(this.transform), interpolateNumber);\n        }\n        return this._clamp(this.untransform(this.input(y)));\n    }\n}\n","/Users/vitaliikravchenko/Sites/nova/client/src/charts/util/time/format/locale.ts",["510","511","512"],"import timeDay from \"../day\";\nimport year from \"../year\";\nimport {\n    sunday as timeSunday,\n    monday as timeMonday,\n    thursday as timeThursday,\n} from \"../week\";\nimport utcDay from \"../utcDay\";\nimport utcYear from \"../utcYear\";\nimport utcSunday, { utcMonday, utcThursday } from \"../utcWeek\";\n\ntype FormatKeys = 'a' | 'A' | 'b' | 'B' | 'c' | 'd' | 'e' | 'f' | 'H' | 'I' | 'j' | 'L' | 'm' | 'M' |\n                  'p' | 'Q' | 's' | 'S' | 'u' | 'U' | 'V' | 'w' | 'W' | 'x' | 'X' | 'y' | 'Y' | 'Z' | '%';\n// The keys in the DateMap are actually FormatKeys, not all will be defined though, so to prevent\n// many checks and to avoid creating a more complicated type we just use `key in string` here.\ntype ParsedDate = { [key in string]: number };\n/**\n * Parses part of the `string` (for example, full year part) starting at `i` position\n * and, if successful, poluates the corresponding field in `d` with a number,\n * returning the next position after the parsed part. Returns `-1` if parsing failed.\n */\ntype Parse = (d: ParsedDate, string: string, i: number) => number;\ntype StringFormat = (date: Date, fill: string) => string;\ntype NumberFormat = (date: Date) => number;\ntype FormatMap = { [key in FormatKeys]?: StringFormat | NumberFormat };\n\n/**\n * Specification of time locale to use when creating a new TimeLocaleObject.\n */\nexport interface TimeLocaleDefinition {\n    /**\n     * The date and time (%c) format specifier (e.g., \"%a %b %e %X %Y\").\n     */\n    dateTime: string;\n    /**\n     * The date (%x) format specifier (e.g., \"%m/%d/%Y\").\n     */\n    date: string;\n    /**\n     *  The time (%X) format specifier (e.g., \"%H:%M:%S\").\n     */\n    time: string;\n    /**\n     * The A.M. and P.M. equivalents (e.g., [\"AM\", \"PM\"]).\n     */\n    periods: [string, string];\n    /**\n     * The full names of the weekdays, starting with Sunday.\n     */\n    days: [string, string, string, string, string, string, string];\n    /**\n     * The abbreviated names of the weekdays, starting with Sunday.\n     */\n    shortDays: [string, string, string, string, string, string, string];\n    /**\n     * The full names of the months (starting with January).\n     */\n    months: [string, string, string, string, string, string, string, string, string, string, string, string];\n    /**\n     * The abbreviated names of the months (starting with January).\n     */\n    shortMonths: [string, string, string, string, string, string, string, string, string, string, string, string];\n}\n\n/**\n * Interface describing a time-locale-based object which exposes time-formatting/parsing\n * methods for a specified locale definition.\n */\nexport interface TimeLocaleObject {\n    /**\n     * Returns a new formatter for the given string specifier. The specifier string may contain the following directives:\n     * - %a - abbreviated weekday name.*\n     * - %A - full weekday name.*\n     * - %b - abbreviated month name.*\n     * - %B - full month name.*\n     * - %c - the locales date and time, such as %x, %X.*\n     * - %d - zero-padded day of the month as a decimal number [01,31].\n     * - %e - space-padded day of the month as a decimal number [ 1,31]; equivalent to %_d.\n     * - %f - microseconds as a decimal number [000000, 999999].\n     * - %H - hour (24-hour clock) as a decimal number [00,23].\n     * - %I - hour (12-hour clock) as a decimal number [01,12].\n     * - %j - day of the year as a decimal number [001,366].\n     * - %m - month as a decimal number [01,12].\n     * - %M - minute as a decimal number [00,59].\n     * - %L - milliseconds as a decimal number [000, 999].\n     * - %p - either AM or PM.*\n     * - %Q - milliseconds since UNIX epoch.\n     * - %s - seconds since UNIX epoch.\n     * - %S - second as a decimal number [00,61].\n     * - %u - Monday-based (ISO) weekday as a decimal number [1,7].\n     * - %U - Sunday-based week of the year as a decimal number [00,53].\n     * - %V - ISO 8601 week number of the year as a decimal number [01, 53].\n     * - %w - Sunday-based weekday as a decimal number [0,6].\n     * - %W - Monday-based week of the year as a decimal number [00,53].\n     * - %x - the locales date, such as %-m/%-d/%Y.*\n     * - %X - the locales time, such as %-I:%M:%S %p.*\n     * - %y - year without century as a decimal number [00,99].\n     * - %Y - year with century as a decimal number.\n     * - %Z - time zone offset, such as -0700, -07:00, -07, or Z.\n     * - %% - a literal percent sign (%).\n     *\n     * Directives marked with an asterisk (*) may be affected by the locale definition.\n     *\n     * For %U, all days in a new year preceding the first Sunday are considered to be in week 0.\n     * For %W, all days in a new year preceding the first Monday are considered to be in week 0.\n     * Week numbers are computed using interval.count. For example, 2015-52 and 2016-00 represent\n     * Monday, December 28, 2015, while 2015-53 and 2016-01 represent Monday, January 4, 2016.\n     * This differs from the ISO week date specification (%V), which uses a more complicated definition!\n     *\n     * For %V, per the strftime man page:\n     *\n     * In this system, weeks start on a Monday, and are numbered from 01, for the first week, up to 52 or 53, for the last week.\n     * Week 1 is the first week where four or more days fall within the new year (or, synonymously,\n     * week 01 is: the first week of the year that contains a Thursday; or, the week that has 4 January in it).\n     *\n     * The % sign indicating a directive may be immediately followed by a padding modifier:\n     *\n     * 1) 0 - zero-padding\n     * 2) _ - space-padding\n     * 3) - disable padding\n     *\n     * If no padding modifier is specified, the default is 0 for all directives except %e, which defaults to _.\n     * (In some implementations of strftime and strptime, a directive may include an optional field width or precision;\n     * this feature is not yet implemented.)\n     *\n     * The returned function formats a specified date, returning the corresponding string.\n     *\n     * @param specifier A specifier string for the date format.\n     */\n    format(specifier: string): (date: Date | number) => string;\n    /**\n     * Returns a new parser for the given string specifier.\n     * The specifier string may contain the same directives as locale.format (TimeLocaleObject.format).\n     * The %d and %e directives are considered equivalent for parsing.\n     *\n     * The returned function parses a specified string, returning the corresponding date or undefined\n     * if the string could not be parsed according to this formats specifier.\n     * Parsing is strict: if the specified string does not exactly match the associated specifier, this method returns undefined.\n     *\n     * For example, if the associated specifier is %Y-%m-%dT%H:%M:%SZ, then the string \"2011-07-01T19:15:28Z\"\n     * will be parsed as expected, but \"2011-07-01T19:15:28\", \"2011-07-01 19:15:28\" and \"2011-07-01\" will return undefined.\n     * (Note that the literal Z here is different from the time zone offset directive %Z.)\n     * If a more flexible parser is desired, try multiple formats sequentially until one returns non-undefined.\n     *\n     * @param specifier A specifier string for the date format.\n     */\n    parse(specifier: string): (dateString: string) => (Date | undefined);\n    /**\n     * Equivalent to locale.format (TimeLocaleObject.format),\n     * except all directives are interpreted as Coordinated Universal Time (UTC) rather than local time.\n     *\n     * @param specifier A specifier string for the date format.\n     */\n    utcFormat(specifier: string): (date: Date | number) => string;\n    /**\n     * Equivalent to locale.parse (TimeLocaleObject.parse),\n     * except all directives are interpreted as Coordinated Universal Time (UTC) rather than local time.\n     *\n     * @param specifier A specifier string for the date format.\n     */\n    utcParse(specifier: string): (dateString: string) => (Date | undefined);\n}\n\nfunction localDate(d: ParsedDate): Date {\n    // For JS Dates the [0, 100) interval is a time warp, a fast forward to the 20th century.\n    // For example, -1 is -0001 BC, 0 is already 1900 AD.\n    if (d.y >= 0 && d.y < 100) {\n        const date = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);\n        date.setFullYear(d.y);\n        return date;\n    }\n    return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);\n}\n\nfunction utcDate(d: ParsedDate): Date {\n    if (d.y >= 0 && d.y < 100) {\n        const date = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));\n        date.setUTCFullYear(d.y);\n        return date;\n    }\n    return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));\n}\n\n/**\n * Creates a lookup map for array of names to go from a name to index.\n * @param names\n */\nfunction formatLookup(names: string[]): typeof map {\n    const map: { [key in string]: number } = {};\n    for (let i = 0, n = names.length; i < n; i++) {\n        map[names[i].toLowerCase()] = i;\n    }\n    return map;\n}\n\nfunction newYear(y: number): ParsedDate {\n    return {\n        y,\n        m: 0,\n        d: 1,\n        H: 0,\n        M: 0,\n        S: 0,\n        L: 0\n    };\n}\n\nconst percentCharCode = 37;\nconst numberRe = /^\\s*\\d+/; // ignores next directive\nconst percentRe = /^%/;\nconst requoteRe = /[\\\\^$*+?|[\\]().{}]/g;\n/**\n * Prepends any character in the `requoteRe` set with a backslash.\n * @param s\n */\nexport const requote = (s: string) => s.replace(requoteRe, '\\\\$&'); // $& - matched substring\n/**\n * Returns a RegExp that matches any string that starts with any of the given names (case insensitive).\n * @param names\n */\nexport const formatRe = (names: string[]) => new RegExp('^(?:' + names.map(requote).join('|') + ')', 'i');\n\n// A map of padding modifiers to padding strings. Default is `0`.\nconst pads: { [key in string]: string } = {\n    '-': '',\n    '_': ' ',\n    '0': '0'\n};\n\nexport function pad(value: number, fill: string, width: number): string {\n    const sign = value < 0 ? '-' : '';\n    const string = String(sign ? -value : value);\n    const length = string.length;\n\n    return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);\n}\n\n/**\n * Create a new time-locale-based object which exposes time-formatting\n * methods for the specified locale definition.\n *\n * @param timeLocale A time locale definition.\n */\nexport default function formatLocale(timeLocale: TimeLocaleDefinition): TimeLocaleObject {\n    const lDateTime = timeLocale.dateTime;\n    const lDate = timeLocale.date;\n    const lTime = timeLocale.time;\n    const lPeriods = timeLocale.periods;\n    const lWeekdays = timeLocale.days;\n    const lShortWeekdays = timeLocale.shortDays;\n    const lMonths = timeLocale.months;\n    const lShortMonths = timeLocale.shortMonths;\n\n    const periodRe = formatRe(lPeriods);\n    const periodLookup = formatLookup(lPeriods);\n\n    const weekdayRe = formatRe(lWeekdays);\n    const weekdayLookup = formatLookup(lWeekdays);\n\n    const shortWeekdayRe = formatRe(lShortWeekdays);\n    const shortWeekdayLookup = formatLookup(lShortWeekdays);\n\n    const monthRe = formatRe(lMonths);\n    const monthLookup = formatLookup(lMonths);\n\n    const shortMonthRe = formatRe(lShortMonths);\n    const shortMonthLookup = formatLookup(lShortMonths);\n\n    const formats: FormatMap = {\n        'a': formatShortWeekday,\n        'A': formatWeekday,\n        'b': formatShortMonth,\n        'B': formatMonth,\n        'c': undefined,\n        'd': formatDayOfMonth,\n        'e': formatDayOfMonth,\n        'f': formatMicroseconds,\n        'H': formatHour24,\n        'I': formatHour12,\n        'j': formatDayOfYear,\n        'L': formatMilliseconds,\n        'm': formatMonthNumber,\n        'M': formatMinutes,\n        'p': formatPeriod,\n        'Q': formatUnixTimestamp,\n        's': formatUnixTimestampSeconds,\n        'S': formatSeconds,\n        'u': formatWeekdayNumberMonday,\n        'U': formatWeekNumberSunday,\n        'V': formatWeekNumberISO,\n        'w': formatWeekdayNumberSunday,\n        'W': formatWeekNumberMonday,\n        'x': undefined,\n        'X': undefined,\n        'y': formatYear,\n        'Y': formatFullYear,\n        'Z': formatZone,\n        '%': formatLiteralPercent\n    };\n\n    const utcFormats: FormatMap = {\n        'a': formatUTCShortWeekday,\n        'A': formatUTCWeekday,\n        'b': formatUTCShortMonth,\n        'B': formatUTCMonth,\n        'c': undefined,\n        'd': formatUTCDayOfMonth,\n        'e': formatUTCDayOfMonth,\n        'f': formatUTCMicroseconds,\n        'H': formatUTCHour24,\n        'I': formatUTCHour12,\n        'j': formatUTCDayOfYear,\n        'L': formatUTCMilliseconds,\n        'm': formatUTCMonthNumber,\n        'M': formatUTCMinutes,\n        'p': formatUTCPeriod,\n        'Q': formatUnixTimestamp,\n        's': formatUnixTimestampSeconds,\n        'S': formatUTCSeconds,\n        'u': formatUTCWeekdayNumberMonday,\n        'U': formatUTCWeekNumberSunday,\n        'V': formatUTCWeekNumberISO,\n        'w': formatUTCWeekdayNumberSunday,\n        'W': formatUTCWeekNumberMonday,\n        'x': undefined,\n        'X': undefined,\n        'y': formatUTCYear,\n        'Y': formatUTCFullYear,\n        'Z': formatUTCZone,\n        '%': formatLiteralPercent\n    };\n\n    const parses: { [key in FormatKeys]: Parse } = {\n        'a': parseShortWeekday,\n        'A': parseWeekday,\n        'b': parseShortMonth,\n        'B': parseMonth,\n        'c': parseLocaleDateTime,\n        'd': parseDayOfMonth,\n        'e': parseDayOfMonth,\n        'f': parseMicroseconds,\n        'H': parseHour24,\n        'I': parseHour24,\n        'j': parseDayOfYear,\n        'L': parseMilliseconds,\n        'm': parseMonthNumber,\n        'M': parseMinutes,\n        'p': parsePeriod,\n        'Q': parseUnixTimestamp,\n        's': parseUnixTimestampSeconds,\n        'S': parseSeconds,\n        'u': parseWeekdayNumberMonday,\n        'U': parseWeekNumberSunday,\n        'V': parseWeekNumberISO,\n        'w': parseWeekdayNumberSunday,\n        'W': parseWeekNumberMonday,\n        'x': parseLocaleDate,\n        'X': parseLocaleTime,\n        'y': parseYear,\n        'Y': parseFullYear,\n        'Z': parseZone,\n        '%': parseLiteralPercent\n    };\n\n    // Recursive definitions.\n    formats.x = newFormat(lDate, formats);\n    formats.X = newFormat(lTime, formats);\n    formats.c = newFormat(lDateTime, formats);\n    utcFormats.x = newFormat(lDate, utcFormats);\n    utcFormats.X = newFormat(lTime, utcFormats);\n    utcFormats.c = newFormat(lDateTime, utcFormats);\n\n    function newParse(specifier: string, newDate: (d: ParsedDate) => Date): (str: string) => Date | undefined {\n        return function(str: string) {\n            const d = newYear(1900);\n            const i = parseSpecifier(d, specifier, str += '', 0);\n\n            if (i != str.length) {\n                return undefined;\n            }\n\n            // If a UNIX timestamp is specified, return it.\n            if ('Q' in d) {\n                return new Date(d.Q);\n            }\n\n            // The am-pm flag is 0 for AM, and 1 for PM.\n            if ('p' in d) {\n                d.H = d.H % 12 + d.p * 12;\n            }\n\n            // Convert day-of-week and week-of-year to day-of-year.\n            if ('V' in d) {\n                if (d.V < 1 || d.V > 53) {\n                    return undefined;\n                }\n                if (!('w' in d)) {\n                    d.w = 1;\n                }\n                if ('Z' in d) {\n                    let week = utcDate(newYear(d.y));\n                    const day = week.getUTCDay();\n                    week = day > 4 || day === 0 ? utcMonday.ceil(week) : utcMonday.floor(week);\n                    week = utcDay.offset(week, (d.V - 1) * 7);\n                    d.y = week.getUTCFullYear();\n                    d.m = week.getUTCMonth();\n                    d.d = week.getUTCDate() + (d.w + 6) % 7;\n                } else {\n                    let week = newDate(newYear(d.y));\n                    const day = week.getDay();\n                    week = day > 4 || day === 0 ? timeMonday.ceil(week) : timeMonday.floor(week);\n                    week = timeDay.offset(week, (d.V - 1) * 7);\n                    d.y = week.getFullYear();\n                    d.m = week.getMonth();\n                    d.d = week.getDate() + (d.w + 6) % 7;\n                }\n            } else if ('W' in d || 'U' in d) {\n                if (!('w' in d)) {\n                    d.w = 'u' in d\n                        ? d.u % 7\n                        : 'W' in d ? 1 : 0;\n                }\n                const day = 'Z' in d ? utcDate(newYear(d.y)).getUTCDay() : newDate(newYear(d.y)).getDay();\n                d.m = 0;\n                d.d = 'W' in d ? (d.w + 6) % 7 + d.W * 7 - (day + 5) % 7 : d.w + d.U * 7 - (day + 6) % 7;\n            }\n\n            // If a time zone is specified, all fields are interpreted as UTC and then\n            // offset according to the specified time zone.\n            if ('Z' in d) {\n                d.H += d.Z / 100 | 0;\n                d.M += d.Z % 100;\n                return utcDate(d);\n            }\n\n            // Otherwise, all fields are in local time.\n            return newDate(d);\n        };\n    }\n\n    /**\n     * Creates a new function that formats the given Date or timestamp according to specifier.\n     * @param specifier\n     * @param formats\n     */\n    function newFormat(specifier: string, formats: FormatMap): (date: Date | number) => string {\n        return date => {\n            const string: (string | number)[] = [];\n            const n = specifier.length;\n            let i = -1;\n            let j = 0;\n\n            if (!(date instanceof Date)) {\n                date = new Date(+date);\n            }\n\n            while (++i < n) {\n                if (specifier.charCodeAt(i) === percentCharCode) {\n                    string.push(specifier.slice(j, i)); // copy the chunks of specifier with no directives as is\n                    let c: string | number = specifier.charAt(++i);\n                    let pad = pads[c];\n                    if (pad != undefined) { // if format directive has a padding modifier in front of it\n                        c = specifier.charAt(++i);   // fetch the directive itself\n                    } else {\n                        pad = c === 'e' ? ' ' : '0'; // use the default padding modifier\n                    }\n                    const format = formats[c as FormatKeys];\n                    if (format) { // if the directive has a corresponding formatting function\n                        c = format(date, pad); // replace the directive with the formatted date\n                    }\n                    string.push(c);\n                    j = i + 1;\n                }\n            }\n            string.push(specifier.slice(j, i));\n\n            return string.join('');\n        };\n    }\n\n    // Simultaneously walks over the specifier and the parsed string, populating the `d` map with parsed values.\n    // The returned number is expected to equal the length of the parsed `string`, if parsing succeeded.\n    function parseSpecifier(d: ParsedDate, specifier: string, string: string, j: number): number {\n        // i - `specifier` string index\n        // j - parsed `string` index\n        let i = 0;\n        const n = specifier.length;\n        const m = string.length;\n\n        while (i < n) {\n            if (j >= m) {\n                return -1;\n            }\n            const code = specifier.charCodeAt(i++);\n            if (code === percentCharCode) {\n                const char = specifier.charAt(i++);\n                const parse = parses[(char in pads ? specifier.charAt(i++) : char) as FormatKeys];\n                if (!parse || ((j = parse(d, string, j)) < 0)) {\n                    return -1;\n                }\n            } else if (code != string.charCodeAt(j++)) {\n                return -1;\n            }\n        }\n\n        return j;\n    }\n\n    // ----------------------------- formats ----------------------------------\n\n    function formatMicroseconds(date: Date, fill: string): string {\n        return formatMilliseconds(date, fill) + '000';\n    }\n    function formatMilliseconds(date: Date, fill: string): string {\n        return pad(date.getMilliseconds(), fill, 3);\n    }\n    function formatSeconds(date: Date, fill: string): string {\n        return pad(date.getSeconds(), fill, 2);\n    }\n    function formatMinutes(date: Date, fill: string): string {\n        return pad(date.getMinutes(), fill, 2);\n    }\n    function formatHour12(date: Date, fill: string): string {\n        return pad(date.getHours() % 12 || 12, fill, 2);\n    }\n    function formatHour24(date: Date, fill: string): string {\n        return pad(date.getHours(), fill, 2);\n    }\n    function formatPeriod(date: Date): string {\n        return lPeriods[date.getHours() >= 12 ? 1 : 0];\n    }\n    function formatShortWeekday(date: Date): string {\n        return lShortWeekdays[date.getDay()];\n    }\n    function formatWeekday(date: Date): string {\n        return lWeekdays[date.getDay()];\n    }\n    function formatWeekdayNumberMonday(date: Date): number {\n        const dayOfWeek = date.getDay();\n        return dayOfWeek === 0 ? 7 : dayOfWeek;\n    }\n    function formatWeekNumberSunday(date: Date, fill: string): string {\n        return pad(timeSunday.count(year.floor(date), date), fill, 2);\n    }\n    function formatWeekNumberISO(date: Date, fill: string): string {\n        const day = date.getDay();\n        date = (day >= 4 || day === 0) ? timeThursday.floor(date) : timeThursday.ceil(date);\n        const yearStart = year.floor(date);\n        return pad(timeThursday.count(yearStart, date) + (yearStart.getDay() === 4 ? 1 : 0), fill, 2);\n    }\n    function formatWeekdayNumberSunday(date: Date): number {\n        return date.getDay();\n    }\n    function formatWeekNumberMonday(date: Date, fill: string): string {\n        return pad(timeMonday.count(year.floor(date), date), fill, 2);\n    }\n    function formatDayOfMonth(date: Date, fill: string): string {\n        return pad(date.getDate(), fill, 2);\n    }\n    function formatDayOfYear(date: Date, fill: string): string {\n        return pad(1 + timeDay.count(year.floor(date), date), fill, 3);\n    }\n    function formatShortMonth(date: Date): string {\n        return lShortMonths[date.getMonth()];\n    }\n    function formatMonth(date: Date): string {\n        return lMonths[date.getMonth()];\n    }\n    function formatMonthNumber(date: Date, fill: string): string {\n        return pad(date.getMonth() + 1, fill, 2);\n    }\n    function formatYear(date: Date, fill: string): string {\n        return pad(date.getFullYear() % 100, fill, 2);\n    }\n    function formatFullYear(date: Date, fill: string): string {\n        return pad(date.getFullYear() % 10000, fill, 4);\n    }\n    function formatZone(date: Date): string {\n        let z = date.getTimezoneOffset();\n        return (z > 0 ? '-' : (z *= -1, '+')) + pad(Math.floor(z / 60), '0', 2) + pad(z % 60, '0', 2);\n    }\n\n    // -------------------------- UTC formats -----------------------------------\n\n    function formatUTCMicroseconds(date: Date, fill: string): string {\n        return formatUTCMilliseconds(date, fill) + '000';\n    }\n    function formatUTCMilliseconds(date: Date, fill: string): string {\n        return pad(date.getUTCMilliseconds(), fill, 3);\n    }\n    function formatUTCSeconds(date: Date, fill: string): string {\n        return pad(date.getUTCSeconds(), fill, 2);\n    }\n    function formatUTCMinutes(date: Date, fill: string): string {\n        return pad(date.getUTCMinutes(), fill, 2);\n    }\n    function formatUTCHour12(date: Date, fill: string): string {\n        return pad(date.getUTCHours() % 12 || 12, fill, 2);\n    }\n    function formatUTCHour24(date: Date, fill: string): string {\n        return pad(date.getUTCHours(), fill, 2);\n    }\n    function formatUTCPeriod(date: Date): string {\n        return lPeriods[date.getUTCHours() >= 12 ? 1 : 0];\n    }\n    function formatUTCDayOfMonth(date: Date, fill: string): string {\n        return pad(date.getUTCDate(), fill, 2);\n    }\n    function formatUTCDayOfYear(date: Date, fill: string): string {\n        return pad(1 + utcDay.count(utcYear.floor(date), date), fill, 3);\n    }\n    function formatUTCMonthNumber(date: Date, fill: string): string {\n        return pad(date.getUTCMonth() + 1, fill, 2);\n    }\n    function formatUTCShortMonth(date: Date): string {\n        return lShortMonths[date.getUTCMonth()];\n    }\n    function formatUTCMonth(date: Date): string {\n        return lMonths[date.getUTCMonth()];\n    }\n    function formatUTCShortWeekday(date: Date): string {\n        return lShortWeekdays[date.getUTCDay()];\n    }\n    function formatUTCWeekday(date: Date): string {\n        return lWeekdays[date.getUTCDay()];\n    }\n    function formatUTCWeekdayNumberMonday(date: Date): number {\n        const dayOfWeek = date.getUTCDay();\n        return dayOfWeek === 0 ? 7 : dayOfWeek;\n    }\n    function formatUTCWeekNumberSunday(date: Date, fill: string): string {\n        return pad(utcSunday.count(utcYear.floor(date), date), fill, 2);\n    }\n    function formatUTCWeekNumberISO(date: Date, fill: string): string {\n        const day = date.getUTCDay();\n        date = (day >= 4 || day === 0) ? utcThursday.floor(date) : utcThursday.ceil(date);\n        const yearStart = utcYear.floor(date);\n        return pad(utcThursday.count(yearStart, date) + (yearStart.getUTCDay() === 4 ? 1 : 0), fill, 4);\n    }\n    function formatUTCWeekdayNumberSunday(date: Date): number {\n        return date.getUTCDay();\n    }\n    function formatUTCWeekNumberMonday(date: Date, fill: string): string {\n        return pad(utcMonday.count(utcYear.floor(date), date), fill, 2);\n    }\n    function formatUTCYear(date: Date, fill: string): string {\n        return pad(date.getUTCFullYear() % 100, fill, 2);\n    }\n    function formatUTCFullYear(date: Date, fill: string): string {\n        return pad(date.getUTCFullYear() % 10000, fill, 4);\n    }\n    function formatUTCZone(): string {\n        return '+0000';\n    }\n    function formatLiteralPercent(date: Date): string {\n        return '%';\n    }\n    function formatUnixTimestamp(date: Date): number {\n        return date.getTime();\n    }\n    function formatUnixTimestampSeconds(date: Date): number {\n        return Math.floor(date.getTime() / 1000);\n    }\n\n    // ------------------------------- parsers ------------------------------------\n\n    function parseMicroseconds(d: ParsedDate, string: string, i: number): number {\n        const n = numberRe.exec(string.slice(i, i + 6));\n        return n ? (d.L = Math.floor(parseFloat(n[0]) / 1000), i + n[0].length) : -1;\n    }\n    function parseMilliseconds(d: ParsedDate, string: string, i: number): number {\n        const n = numberRe.exec(string.slice(i, i + 3));\n        return n ? (d.L = +n[0], i + n[0].length) : -1;\n    }\n    function parseSeconds(d: ParsedDate, string: string, i: number): number {\n        const n = numberRe.exec(string.slice(i, i + 2));\n        return n ? (d.S = +n[0], i + n[0].length) : -1;\n    }\n    function parseMinutes(d: ParsedDate, string: string, i: number): number {\n        const n = numberRe.exec(string.slice(i, i + 2));\n        return n ? (d.M = +n[0], i + n[0].length) : -1;\n    }\n    function parseHour24(d: ParsedDate, string: string, i: number): number {\n        const n = numberRe.exec(string.slice(i, i + 2));\n        return n ? (d.H = +n[0], i + n[0].length) : -1;\n    }\n    function parsePeriod(d: ParsedDate, string: string, i: number): number {\n        const n = periodRe.exec(string.slice(i));\n        return n ? (d.p = periodLookup[n[0].toLowerCase()], i + n[0].length) : -1;\n    }\n    function parseDayOfMonth(d: ParsedDate, string: string, i: number): number {\n        const n = numberRe.exec(string.slice(i, i + 2));\n        return n ? (d.d = +n[0], i + n[0].length) : -1;\n    }\n    function parseDayOfYear(d: ParsedDate, string: string, i: number): number {\n        const n = numberRe.exec(string.slice(i, i + 3));\n        return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;\n    }\n    function parseShortWeekday(d: ParsedDate, string: string, i: number): number {\n        const n = shortWeekdayRe.exec(string.slice(i));\n        return n ? (d.w = shortWeekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;\n    }\n    function parseWeekday(d: ParsedDate, string: string, i: number): number {\n        const n = weekdayRe.exec(string.slice(i));\n        return n ? (d.w = weekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;\n    }\n    function parseWeekdayNumberMonday(d: ParsedDate, string: string, i: number): number {\n        const n = numberRe.exec(string.slice(i, i + 1));\n        return n ? (d.u = +n[0], i + n[0].length) : -1;\n    }\n    function parseWeekNumberSunday(d: ParsedDate, string: string, i: number): number {\n        const n = numberRe.exec(string.slice(i, i + 2));\n        return n ? (d.U = +n[0], i + n[0].length) : -1;\n    }\n    function parseWeekNumberISO(d: ParsedDate, string: string, i: number): number {\n        const n = numberRe.exec(string.slice(i, i + 2));\n        return n ? (d.V = +n[0], i + n[0].length) : -1;\n    }\n    function parseWeekNumberMonday(d: ParsedDate, string: string, i: number): number {\n        const n = numberRe.exec(string.slice(i, i + 2));\n        return n ? (d.W = +n[0], i + n[0].length) : -1;\n    }\n    function parseWeekdayNumberSunday(d: ParsedDate, string: string, i: number): number {\n        const n = numberRe.exec(string.slice(i, i + 1));\n        return n ? (d.w = +n[0], i + n[0].length) : -1;\n    }\n    function parseShortMonth(d: ParsedDate, string: string, i: number): number {\n        const n = shortMonthRe.exec(string.slice(i));\n        return n ? (d.m = shortMonthLookup[n[0].toLowerCase()], i + n[0].length) : -1;\n    }\n    function parseMonth(d: ParsedDate, string: string, i: number): number {\n        const n = monthRe.exec(string.slice(i));\n        return n ? (d.m = monthLookup[n[0].toLowerCase()], i + n[0].length) : -1;\n    }\n    function parseMonthNumber(d: ParsedDate, string: string, i: number): number {\n        const n = numberRe.exec(string.slice(i, i + 2));\n        return n ? (d.m = parseFloat(n[0]) - 1, i + n[0].length) : -1;\n    }\n    function parseLocaleDateTime(d: ParsedDate, string: string, i: number): number {\n        return parseSpecifier(d, lDateTime, string, i);\n    }\n    function parseLocaleDate(d: ParsedDate, string: string, i: number): number {\n        return parseSpecifier(d, lDate, string, i);\n    }\n    function parseLocaleTime(d: ParsedDate, string: string, i: number): number {\n        return parseSpecifier(d, lTime, string, i);\n    }\n    function parseUnixTimestamp(d: ParsedDate, string: string, i: number): number {\n        const n = numberRe.exec(string.slice(i));\n        return n ? (d.Q = +n[0], i + n[0].length) : -1;\n    }\n    function parseUnixTimestampSeconds(d: ParsedDate, string: string, i: number): number {\n        const n = numberRe.exec(string.slice(i));\n        return n ? (d.Q = (+n[0]) * 1000, i + n[0].length) : -1;\n    }\n    function parseYear(d: ParsedDate, string: string, i: number): number {\n        const n = numberRe.exec(string.slice(i, i + 2));\n        return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2000), i + n[0].length) : -1;\n    }\n    function parseFullYear(d: ParsedDate, string: string, i: number): number {\n        const n = numberRe.exec(string.slice(i, i + 4));\n        return n ? (d.y = +n[0], i + n[0].length) : -1;\n    }\n    function parseZone(d: ParsedDate, string: string, i: number): number {\n        const n = /^(Z)|([+-]\\d\\d)(?::?(\\d\\d))?/.exec(string.slice(i, i + 6));\n        return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || '00')), i + n[0].length) : -1;\n    }\n    function parseLiteralPercent(d: ParsedDate, string: string, i: number): number {\n        const n = percentRe.exec(string.slice(i, i + 1));\n        return n ? i + n[0].length : -1;\n    }\n\n    return {\n        format: (specifier: string): ((date: number | Date) => string) => {\n            const f = newFormat(specifier, formats);\n            f.toString = () => specifier;\n            return f;\n        },\n        parse: (specifier: string): ((dateString: string) => (Date | undefined)) => {\n            const p = newParse(specifier, localDate);\n            p.toString = () => specifier;\n            return p;\n        },\n        utcFormat: (specifier: string): ((date: number | Date) => string) => {\n            const f = newFormat(specifier, utcFormats);\n            f.toString = () => specifier;\n            return f;\n        },\n        utcParse: (specifier: string): ((dateString: string) => (Date | undefined)) => {\n            const p = newParse(specifier, utcDate);\n            p.toString = () => specifier;\n            return p;\n        }\n    };\n}\n","/Users/vitaliikravchenko/Sites/nova/client/src/charts/scene/shape/arc.ts",[],"/Users/vitaliikravchenko/Sites/nova/client/src/charts/scene/shape/line.ts",[],"/Users/vitaliikravchenko/Sites/nova/client/src/charts/util/angle.ts",[],"/Users/vitaliikravchenko/Sites/nova/client/src/charts/scene/selection.ts",["513","514"],"import { Node } from \"./node\";\nimport { Scene } from \"./scene\";\n\ntype ValueFn<P, GDatum, PDatum> = (parent: P, data: PDatum, index: number, groups: (P | undefined)[]) => GDatum[];\ntype KeyFn<N, G, GDatum> = (node: N, datum: GDatum, index: number, groups: (G | undefined)[]) => string;\ntype NodeCallback<G, GDatum> = (node: G, datum: GDatum, index: number, group: (G | undefined)[]) => void;\ntype NodeSelector<N, G, GDatum> = (node: G, datum: GDatum, index: number, group: (G | undefined)[]) => N;\ntype NodeSelectorAll<N, G, GDatum> = (node: G, datum: GDatum, index: number, group: (G | undefined)[]) => N[];\n\nexport class EnterNode {\n\n    constructor(parent: Node | EnterNode, datum: any) {\n        this.scene = parent.scene;\n        this.parent = parent;\n        this.datum = datum;\n    }\n\n    scene?: Scene;\n    parent: Node | EnterNode;\n    datum: any;\n    next: Node | EnterNode | null = null;\n\n    appendChild<T extends Node>(node: T): T {\n        // This doesn't work without the `strict: true` in the `tsconfig.json`,\n        // so we must have two `if` checks below, instead of this single one.\n        // if (this.next && !Node.isNode(this.next)) {\n        //     throw new Error(`${this.next} is not a Node.`);\n        // }\n        if (this.next === null) {\n            return this.parent.insertBefore(node, null);\n        }\n        if (!Node.isNode(this.next)) {\n            throw new Error(`${this.next} is not a Node.`);\n        }\n        return this.parent.insertBefore(node, this.next);\n    }\n\n    insertBefore<T extends Node>(node: T, nextNode?: Node | null): T {\n        return this.parent.insertBefore(node, nextNode);\n    }\n}\n\n/**\n * G - type of the selected node(s).\n * GDatum - type of the datum of the selected node(s).\n * P - type of the parent node(s).\n * PDatum - type of the datum of the parent node(s).\n */\nexport class Selection<G extends Node | EnterNode, P extends Node | EnterNode, GDatum = any, PDatum = any> {\n\n    constructor(groups: (G | undefined)[][], parents: (P | undefined)[]) {\n        this.groups = groups;\n        this.parents = parents;\n    }\n\n    groups: (G | undefined)[][];\n    parents: (P | undefined)[];\n\n    static select<G extends Node, P extends Node | EnterNode>(node: G | (() => G)) {\n        return new Selection<G, P>([[typeof node === 'function' ? node() : node]], [undefined]);\n    }\n\n    static selectAll<G extends Node>(nodes?: G[] | null) {\n        return new Selection([nodes == null ? [] : nodes], [undefined]);\n    }\n\n    /**\n     * Creates new nodes, appends them to the nodes of this selection and returns them\n     * as a new selection. The created nodes inherit the datums and the parents of the nodes\n     * they replace.\n     * @param Class The constructor function to use to create the new nodes.\n     */\n    append<N extends Node>(Class: new () => N): Selection<N, P, GDatum, GDatum> {\n        return this.select<N>(node => {\n            return node.appendChild(new Class());\n        });\n    }\n\n    /**\n     * Same as the {@link append}, but accepts a custom creator function with the\n     * {@link NodeSelector} signature rather than a constructor function.\n     * @param creator\n     */\n    private appendFn<N extends Node>(creator: NodeSelector<N, G, GDatum>): Selection<N, P, GDatum, GDatum> {\n        return this.select<N>((node, data, index, group) => {\n            return node.appendChild(creator(node, data, index, group));\n        });\n    }\n\n    /**\n     * Runs the given selector that returns a single node for every node in each group.\n     * The original nodes are then replaced by the nodes returned by the selector\n     * and returned as a new selection.\n     * The selected nodes inherit the datums and the parents of the original nodes.\n     */\n    select<N extends Node>(selector: (node: G, datum: GDatum, index: number, group: (G | undefined)[]) => N | undefined): Selection<N, P, GDatum, GDatum> {\n        const groups = this.groups;\n        const numGroups = groups.length;\n\n        const subgroups: (N | undefined)[][] = [];\n\n        for (let j = 0; j < numGroups; j++) {\n            const group = groups[j];\n            const groupSize = group.length;\n            const subgroup = subgroups[j] = new Array<N | undefined>(groupSize);\n\n            for (let i = 0; i < groupSize; i++) {\n                const node = group[i];\n\n                if (node) {\n                    const subnode = selector(node, node.datum, i, group);\n\n                    if (subnode) {\n                        subnode.datum = node.datum;\n                    }\n                    subgroup[i] = subnode;\n                }\n                // else this can be a group of the `enter` selection,\n                // for example, with no nodes at the i-th position,\n                // only nodes at the end of the group\n            }\n        }\n\n        return new Selection(subgroups, this.parents);\n    }\n\n    /**\n     * Same as {@link select}, but uses the given {@param Class} (constructor) as a selector.\n     * @param Class The constructor function to use to find matching nodes.\n     */\n    selectByClass<N extends Node>(Class: new () => N): Selection<N, P, GDatum, GDatum> {\n        return this.select(node => {\n            if (Node.isNode(node)) {\n                const children = node.children;\n                const n = children.length;\n\n                for (let i = 0; i < n; i++) {\n                    const child = children[i];\n                    if (child instanceof Class) {\n                        return child;\n                    }\n                }\n            }\n        });\n    }\n\n    selectByTag<N extends Node>(tag: number): Selection<N, P, GDatum, GDatum> {\n        return this.select<N>(node => {\n            if (Node.isNode(node)) {\n                const children = node.children;\n                const n = children.length;\n\n                for (let i = 0; i < n; i++) {\n                    const child = children[i];\n                    if (child.tag === tag) {\n                        return child as N;\n                    }\n                }\n            }\n        });\n    }\n\n    selectAllByClass<N extends Node, NDatum = any>(Class: new () => N): Selection<N, G, NDatum, GDatum> {\n        return this.selectAll<N, NDatum>(node => {\n            const nodes: N[] = [];\n\n            if (Node.isNode(node)) {\n                const children = node.children;\n                const n = children.length;\n\n                for (let i = 0; i < n; i++) {\n                    const child = children[i];\n                    if (child instanceof Class) {\n                        nodes.push(child);\n                    }\n                }\n            }\n            return nodes;\n        });\n    }\n\n    selectAllByTag<N extends Node, NDatum = any>(tag: number): Selection<N, G, NDatum, GDatum> {\n        return this.selectAll<N, NDatum>(node => {\n            const nodes: N[] = [];\n\n            if (Node.isNode(node)) {\n                const children = node.children;\n                const n = children.length;\n\n                for (let i = 0; i < n; i++) {\n                    const child = children[i];\n                    if (child.tag === tag) {\n                        nodes.push(child as N);\n                    }\n                }\n            }\n            return nodes;\n        });\n    }\n\n    private selectNone(): [] {\n        return [];\n    }\n\n    /**\n     * Runs the given selector that returns a group of nodes for every node in each group.\n     * The original nodes are then replaced by the groups of nodes returned by the selector\n     * and returned as a new selection. The original nodes become the parent nodes for each\n     * group in the new selection. The selected nodes do not inherit the datums of the original nodes.\n     * If called without any parameters, creates a new selection with an empty group for each\n     * node in this selection.\n     */\n    selectAll<N extends Node, NDatum = any>(\n        selectorAll?: (node: G, datum: GDatum, index: number, group: (G | undefined)[]) => N[]\n    ): Selection<N, G, NDatum, GDatum> {\n\n        if (!selectorAll) {\n            selectorAll = this.selectNone;\n        }\n\n        // Each subgroup is populated with the selector (run on each group node) results.\n        const subgroups: N[][] = [];\n        // In the new selection that we return, subgroups become groups,\n        // and group nodes become parents.\n        const parents: G[] = [];\n\n        const groups = this.groups;\n        const groupCount = groups.length;\n\n        for (let j = 0; j < groupCount; j++) {\n            const group = groups[j];\n            const groupLength = group.length;\n\n            for (let i = 0; i < groupLength; i++) {\n                const node = group[i];\n\n                if (node) {\n                    subgroups.push(selectorAll(node, node.datum, i, group));\n                    parents.push(node);\n                }\n            }\n        }\n\n        return new Selection<N, G, NDatum, GDatum>(subgroups, parents);\n    }\n\n    /**\n     * Runs the given callback for every node in this selection and returns this selection.\n     * @param cb\n     */\n    each(cb: (node: G, datum: GDatum, index: number, group: (G | undefined)[]) => void): this {\n        const groups = this.groups;\n        const numGroups = groups.length;\n\n        for (let j = 0; j < numGroups; j++) {\n            const group = groups[j];\n            const groupSize = group.length;\n\n            for (let i = 0; i < groupSize; i++) {\n                const node = group[i];\n\n                if (node) {\n                    cb(node, node.datum as GDatum, i, group);\n                }\n            }\n        }\n\n        return this;\n    }\n\n    remove(): this {\n        return this.each(node => {\n            if (Node.isNode(node)) {\n                const parent = node.parent;\n                if (parent) {\n                    parent.removeChild(node as unknown as Node);\n                }\n            }\n        });\n    }\n\n    merge(other: Selection<G, P, GDatum, PDatum>): Selection<G, P, GDatum, PDatum> {\n        const groups0 = this.groups;\n        const groups1 = other.groups;\n        const m0 = groups0.length;\n        const m1 = groups1.length;\n        const m = Math.min(m0, m1);\n        const merges = new Array<(G | undefined)[]>(m0);\n\n        let j = 0;\n\n        for (; j < m; j++) {\n            const group0 = groups0[j];\n            const group1 = groups1[j];\n            const n = group0.length;\n            const merge = merges[j] = new Array<G | undefined>(n);\n\n            for (let i = 0; i < n; i++) {\n                const node = group0[i] || group1[i];\n\n                merge[i] = node || undefined;\n            }\n        }\n\n        for (; j < m0; j++) {\n            merges[j] = groups0[j];\n        }\n\n        return new Selection<G, P, GDatum, PDatum>(merges, this.parents);\n    }\n\n    /**\n     * Return the first non-null element in this selection.\n     * If the selection is empty, returns null.\n     */\n    node(): G | null {\n        const groups = this.groups;\n        const numGroups = groups.length;\n\n        for (let j = 0; j < numGroups; j++) {\n            const group = groups[j];\n            const groupSize = group.length;\n\n            for (let i = 0; i < groupSize; i++) {\n                const node = group[i];\n\n                if (node) {\n                    return node;\n                }\n            }\n        }\n\n        return null;\n    }\n\n    attr<K extends keyof G>(name: K, value: Exclude<G[K], Function>): this {\n        this.each(node => {\n            node[name] = value;\n        });\n\n        return this;\n    }\n\n    attrFn<K extends keyof G>(name: K, value: (node: G, datum: GDatum, index: number, group: (G | undefined)[]) => Exclude<G[K], Function>): this {\n        this.each((node, datum, index, group) => {\n            node[name] = value(node, datum, index, group);\n        });\n\n        return this;\n    }\n\n    /**\n     * Invokes the given function once, passing in this selection.\n     * Returns this selection. Facilitates method chaining.\n     * @param cb\n     */\n    call(cb: (selection: this) => void) {\n        cb(this);\n\n        return this;\n    }\n\n    /**\n     * Returns the total number of nodes in this selection.\n     */\n    get size(): number {\n        let size = 0;\n\n        this.each(() => size++);\n\n        return size;\n    }\n\n    /**\n     * Returns the array of data for the selected elements.\n     */\n    get data(): GDatum[] {\n        const data: GDatum[] = [];\n\n        this.each((_, datum) => data.push(datum));\n\n        return data;\n    }\n\n    private enterGroups?: (EnterNode | undefined)[][];\n    private exitGroups?: (G | undefined)[][];\n\n    get enter() {\n        return new Selection<EnterNode, P, GDatum, PDatum>(\n            this.enterGroups ? this.enterGroups : [[]],\n            this.parents\n        );\n    }\n\n    get exit() {\n        return new Selection<G, P, GDatum, PDatum>(\n            this.exitGroups ? this.exitGroups : [[]],\n            this.parents\n        );\n    }\n\n    /**\n     * Binds the given value to each selected node and returns this selection\n     * with its {@link GDatum} type changed to the type of the given value.\n     * This method doesn't compute a join and doesn't affect indexes or the enter and exit selections.\n     * This method can also be used to clear bound data.\n     * @param value\n     */\n    setDatum<GDatum>(value: GDatum): Selection<G, P, GDatum, PDatum> {\n        return this.each(node => {\n            node.datum = value;\n        }) as unknown as Selection<G, P, GDatum, PDatum>;\n    }\n\n    /**\n     * Returns the bound datum for the first non-null element in the selection.\n     * This is generally useful only if you know the selection contains exactly one element.\n     */\n    get datum(): GDatum {\n        const node = this.node();\n        return node ? node.datum : null;\n    }\n\n    /**\n     * Binds the specified array of values with the selected nodes, returning a new selection\n     * that represents the _update_ selection: the nodes successfully bound to the values.\n     * Also defines the {@link enter} and {@link exit} selections on the returned selection,\n     * which can be used to add or remove the nodes to correspond to the new data.\n     * The `values` is an array of values of a particular type, or a function that returns\n     * an array of values for each group.\n     * When values are assigned to the nodes, they are stored in the {@link Node.datum} property.\n     * @param values\n     * @param key\n     */\n    setData<GDatum>(values: GDatum[] | ValueFn<P, GDatum, PDatum>,\n                    key?: KeyFn<Node | EnterNode, G | GDatum, GDatum>): Selection<G, P, GDatum, PDatum> {\n\n        if (typeof values !== 'function') {\n            const data = values;\n            values = () => data;\n        }\n\n        const groups = this.groups;\n        const parents = this.parents;\n        const numGroups = groups.length;\n        const updateGroups: (G | undefined)[][] = new Array(numGroups);\n        const enterGroups: (EnterNode | undefined)[][] = new Array(numGroups);\n        const exitGroups: (G | undefined)[][] = new Array(numGroups);\n\n        for (let j = 0; j < numGroups; j++) {\n            const group = groups[j];\n            const parent = parents[j];\n\n            if (!parent) {\n                throw new Error(`Group #${j} has no parent: ${group}`);\n            }\n\n            const groupSize = group.length;\n            const data: GDatum[] = values(parent, parent.datum, j, parents);\n            const dataSize = data.length;\n\n            const enterGroup = enterGroups[j] = new Array<EnterNode | undefined>(dataSize);\n            const updateGroup = updateGroups[j] = new Array<G | undefined>(dataSize);\n            const exitGroup = exitGroups[j] = new Array<G | undefined>(groupSize);\n\n            if (key) {\n                this.bindKey(parent, group, enterGroup, updateGroup, exitGroup, data, key);\n            }\n            else {\n                this.bindIndex(parent, group, enterGroup, updateGroup, exitGroup, data);\n            }\n\n            // Now connect the enter nodes to their following update node, such that\n            // appendChild can insert the materialized enter node before this node,\n            // rather than at the end of the parent node.\n            for (let i0 = 0, i1 = 0; i0 < dataSize; i0++) {\n                const previous = enterGroup[i0];\n                if (previous) {\n                    if (i0 >= i1) {\n                        i1 = i0 + 1;\n                    }\n                    let next;\n                    while (!(next = updateGroup[i1]) && i1 < dataSize) { i1++; }\n                    previous.next = next || null;\n                }\n            }\n        }\n\n        const result = new Selection<G, P, GDatum, PDatum>(updateGroups, parents);\n        result.enterGroups = enterGroups;\n        result.exitGroups = exitGroups;\n\n        return result;\n    }\n\n    private bindIndex<GDatum>(parent: P, group: (G | undefined)[],\n                              enter: (EnterNode | undefined)[], update: (G | undefined)[], exit: (G | undefined)[],\n                              data: GDatum[]) {\n\n        const groupSize = group.length;\n        const dataSize = data.length;\n\n        let i = 0;\n\n        for (; i < dataSize; i++) {\n            const node = group[i];\n\n            if (node) {\n                node.datum = data[i];\n                update[i] = node;\n            } else { // more datums than group nodes\n                enter[i] = new EnterNode(parent, data[i]);\n            }\n        }\n\n        // more group nodes than datums\n        for (; i < groupSize; i++) {\n            const node = group[i];\n\n            if (node) {\n                exit[i] = node;\n            }\n        }\n    }\n\n    private static keyPrefix = '$'; // Protect against keys like '__proto__'.\n\n    private bindKey<GDatum>(parent: P, group: (G | undefined)[],\n                            enter: (EnterNode | undefined)[], update: (G | undefined)[], exit: (G | undefined)[],\n                            data: GDatum[], key: KeyFn<Node | EnterNode, G | GDatum, GDatum>) {\n\n        const groupSize = group.length;\n        const dataSize = data.length;\n        const keyValues = new Array(groupSize);\n        const nodeByKeyValue: { [key: string]: G | undefined } = {};\n\n        // Compute the key for each node.\n        // If multiple nodes have the same key, the duplicates are added to exit.\n        for (let i = 0; i < groupSize; i++) {\n            const node = group[i];\n\n            if (node) {\n                const keyValue = keyValues[i] = Selection.keyPrefix + key(node, node.datum, i, group);\n                if (keyValue in nodeByKeyValue) {\n                    exit[i] = node;\n                } else {\n                    nodeByKeyValue[keyValue] = node;\n                }\n            }\n        }\n\n        // Compute the key for each datum.\n        // If there is a node associated with this key, join and add it to update.\n        // If there is not (or the key is a duplicate), add it to enter.\n        for (let i = 0; i < dataSize; i++) {\n            const keyValue = Selection.keyPrefix + key(parent, data[i], i, data);\n            const node = nodeByKeyValue[keyValue];\n\n            if (node) {\n                update[i] = node;\n                node.datum = data[i];\n                nodeByKeyValue[keyValue] = undefined;\n            } else {\n                enter[i] = new EnterNode(parent, data[i]);\n            }\n        }\n\n        // Add any remaining nodes that were not bound to data to exit.\n        for (let i = 0; i < groupSize; i++) {\n            const node = group[i];\n\n            if (node && (nodeByKeyValue[keyValues[i]] === node)) {\n                exit[i] = node;\n            }\n        }\n    }\n}\n","/Users/vitaliikravchenko/Sites/nova/client/src/charts/util/compare.ts",[],"/Users/vitaliikravchenko/Sites/nova/client/src/charts/util/time/interval.ts",["515","516","517","518","519"],"type FloorFn = (date: Date) => void;                 // mutates the passed date\ntype OffsetFn = (date: Date, step: number) => void;  // mutates the passed date\ntype CountFn = (start: Date, end: Date) => number;\n// Returns the number of boundaries between this date (exclusive) and the latest previous parent boundary.\n// This date is already floored to the current interval.\n// For example, for the d3.timeDay interval, this returns the number of days since the start of the month.\ntype FieldFn = (date: Date) => number;\n\nconst t0 = new Date;\nconst t1 = new Date;\n\n/**\n * The interval methods don't mutate Date parameters.\n */\nexport class TimeInterval {\n    protected readonly _floor: FloorFn;\n    protected readonly _offset: OffsetFn;\n\n    constructor(floor: FloorFn, offset: OffsetFn) {\n        this._floor = floor;\n        this._offset = offset;\n    }\n\n    /**\n     * Returns a new date representing the latest interval boundary date before or equal to date.\n     * For example, `day.floor(date)` typically returns 12:00 AM local time on the given date.\n     * @param date\n     */\n    floor(date: Date | number): Date {\n        date = new Date(+date);\n        this._floor(date);\n        return date;\n    }\n\n    /**\n     * Returns a new date representing the earliest interval boundary date after or equal to date.\n     * @param date\n     */\n    ceil(date: Date | number): Date {\n        date = new Date(+date - 1);\n        this._floor(date);\n        this._offset(date, 1);\n        this._floor(date);\n        return date;\n    }\n\n    /**\n     * Returns a new date representing the closest interval boundary date to date.\n     * @param date\n     */\n    round(date: Date | number): Date {\n        const d0 = this.floor(date);\n        const d1 = this.ceil(date);\n        const ms = +date;\n        return ms - d0.getTime() < d1.getTime() - ms ? d0 : d1;\n    }\n\n    /**\n     * Returns a new date equal to date plus step intervals.\n     * @param date\n     * @param step\n     */\n    offset(date: Date | number, step: number = 1): Date {\n        date = new Date(+date);\n        this._offset(date, Math.floor(step));\n        return date;\n    }\n\n    /**\n     * Returns an array of dates representing every interval boundary after or equal to start (inclusive) and before stop (exclusive).\n     * @param start\n     * @param stop\n     * @param step\n     */\n    range(start: Date, stop: Date, step: number = 1): Date[] {\n        const range: Date[] = [];\n\n        start = this.ceil(start);\n        step = Math.floor(step);\n        if (start > stop || step <= 0) {\n            return range;\n        }\n\n        let previous: Date;\n        do {\n            previous = new Date(+start);\n            range.push(previous);\n            this._offset(start, step);\n            this._floor(start);\n        } while (previous < start && start < stop);\n\n        return range;\n    }\n\n    // Returns an interval that is a subset of this interval.\n    // For example, to create an interval that return 1st, 11th, 21st and 31st of each month:\n    // day.filter(date => (date.getDate() - 1) % 10 === 0)\n    filter(test: (date: Date) => boolean): TimeInterval {\n        const floor = (date: Date): Date => {\n            if (date >= date) {\n                while (this._floor(date), !test(date)) {\n                    date.setTime(date.getTime() - 1);\n                }\n            }\n            return date;\n        };\n        const offset = (date: Date, step: number): Date => {\n            if (date >= date) {\n                if (step < 0) {\n                    while (++step <= 0) {\n                        do {\n                            this._offset(date, -1);\n                        } while (!test(date));\n                    }\n                } else {\n                    while (--step >= 0) {\n                        do {\n                            this._offset(date, 1);\n                        } while (!test(date));\n                    }\n                }\n            }\n            return date;\n        };\n        return new TimeInterval(floor, offset);\n    }\n}\n\nexport class CountableTimeInterval extends TimeInterval {\n\n    private readonly _count: CountFn;\n    private readonly _field?: FieldFn;\n\n    constructor(floor: FloorFn, offset: OffsetFn, count: CountFn, field?: FieldFn) {\n        super(floor, offset);\n\n        this._count = count;\n        this._field = field;\n    }\n\n    /**\n     * Returns the number of interval boundaries after start (exclusive) and before or equal to end (inclusive).\n     * @param start\n     * @param end\n     */\n    count(start: Date | number, end: Date | number): number {\n        t0.setTime(+start);\n        t1.setTime(+end);\n        this._floor(t0);\n        this._floor(t1);\n        return Math.floor(this._count(t0, t1));\n    }\n\n    /**\n     * Returns a filtered view of this interval representing every step'th date.\n     * The meaning of step is dependent on this intervals parent interval as defined by the `field` function.\n     * @param step\n     */\n    every(step: number): TimeInterval | undefined {\n        let result: TimeInterval | undefined;\n\n        step = Math.floor(step);\n        if (isFinite(step) && step > 0) {\n            if (step > 1) {\n                const field = this._field;\n                if (field) {\n                    result = this.filter(d => field(d) % step === 0);\n                } else {\n                    result = this.filter(d => this.count(0, d) % step === 0);\n                }\n            } else {\n                result = this;\n            }\n        }\n\n        return result;\n    }\n}\n","/Users/vitaliikravchenko/Sites/nova/client/src/charts/scene/intersection.ts",[],"/Users/vitaliikravchenko/Sites/nova/client/src/charts/interpolate/value.ts",["520","521","522"],"import constant from \"./constant\";\nimport number from \"./number\";\nimport date from \"./date\";\nimport array from \"./array\";\nimport object from \"./object\";\n\nexport default function (a: any, b: any): (t: number) => any {\n    const t = typeof b;\n    // let c;\n\n    return b == null || t === 'boolean' ? constant(b)\n        : (t === 'number' ? number\n            // : t === 'string' ? ((c = color(b)) ? (b = c, rgb) : string)\n            //     : b instanceof color ? rgb\n                    : b instanceof Date ? date\n                        : Array.isArray(b) ? array\n                            : typeof b.valueOf !== 'function' && typeof b.toString !== 'function' || isNaN(b) ? object\n                                : number)(a, b);\n}\n","/Users/vitaliikravchenko/Sites/nova/client/src/charts/interpolate/number.ts",["523"],"export default function (a: number, b: number): (t: number) => number {\n    a = +a;\n    b = +b;\n    return t => a * (1 - t) + b * t;\n}\n","/Users/vitaliikravchenko/Sites/nova/client/src/charts/util/time/utcWeek.ts",[],"/Users/vitaliikravchenko/Sites/nova/client/src/charts/util/time/utcYear.ts",[],"/Users/vitaliikravchenko/Sites/nova/client/src/charts/util/time/utcDay.ts",[],"/Users/vitaliikravchenko/Sites/nova/client/src/charts/util/number.ts",[],"/Users/vitaliikravchenko/Sites/nova/client/src/charts/scene/polyRoots.ts",[],"/Users/vitaliikravchenko/Sites/nova/client/src/charts/interpolate/object.ts",["524"],"import value from \"./value\";\n\nexport default function (a: any, b: any): (t: number) => object {\n    const i: any = {};\n    const c: any = {};\n    let k;\n\n    if (a === null || typeof a !== 'object') {\n        a = {};\n    }\n    if (b === null || typeof b !== 'object') {\n        b = {};\n    }\n\n    for (k in b) {\n        if (k in a) {\n            i[k] = value(a[k], b[k]);\n        } else {\n            c[k] = b[k];\n        }\n    }\n\n    return t => {\n        for (k in i) {\n            c[k] = i[k](t);\n        }\n        return c;\n    };\n}\n","/Users/vitaliikravchenko/Sites/nova/client/src/charts/interpolate/date.ts",["525","526"],"export default function (a: Date | number, b: Date | number): (t: number) => Date {\n    const date = new Date;\n    const msA = +a;\n    const msB = +b;\n    return function (t: number) {\n        date.setTime(msA * (1 - t) + msB * t);\n        return date;\n    };\n}","/Users/vitaliikravchenko/Sites/nova/client/src/charts/interpolate/array.ts",["527"],"import value from \"./value\";\n\nexport default function(a: any[], b: any[]): (t: number) => any[] {\n    const nb = b ? b.length : 0;\n    const na = a ? Math.min(nb, a.length) : 0;\n    const x = new Array(na);\n    const c = new Array(nb);\n    let i;\n\n    for (i = 0; i < na; ++i) {\n        x[i] = value(a[i], b[i]);\n    }\n    for (; i < nb; ++i) {\n        c[i] = b[i];\n    }\n\n    return function (t: number) {\n        for (i = 0; i < na; ++i) {\n            c[i] = x[i](t);\n        }\n        return c;\n    };\n}\n","/Users/vitaliikravchenko/Sites/nova/client/src/charts/interpolate/constant.ts",["528"],"export default (x: any) => () => x;\n","/Users/vitaliikravchenko/Sites/nova/client/src/charts/chart/polarChart.ts",[],"/Users/vitaliikravchenko/Sites/nova/client/src/charts/chart/series/cartesian/areaSeries.ts",["529","530","531","532"],"import { Group } from \"../../../scene/group\";\nimport { Selection } from \"../../../scene/selection\";\nimport { DropShadow } from \"../../../scene/dropShadow\";\nimport {\n    SeriesNodeDatum,\n    CartesianTooltipRendererParams,\n    HighlightStyle,\n    SeriesTooltip,\n} from \"../series\";\nimport { PointerEvents } from \"../../../scene/node\";\nimport { LegendDatum } from \"../../legend\";\nimport { Path } from \"../../../scene/shape/path\";\nimport { Marker } from \"../../marker/marker\";\nimport { CartesianSeries, CartesianSeriesMarker, CartesianSeriesMarkerFormat } from \"./cartesianSeries\";\nimport { ChartAxisDirection } from \"../../chartAxis\";\nimport { getMarker } from \"../../marker/util\";\nimport { TooltipRendererResult, toTooltipHtml } from \"../../chart\";\nimport { findMinMax } from \"../../../util/array\";\nimport { toFixed } from \"../../../util/number\";\nimport { equal } from \"../../../util/equal\";\nimport { reactive, TypedEvent } from \"../../../util/observable\";\nimport { interpolate } from \"../../../util/string\";\n\ninterface AreaSelectionDatum {\n    readonly yKey: string;\n    readonly points: { x: number, y: number }[];\n}\n\nexport interface AreaSeriesNodeClickEvent extends TypedEvent {\n    readonly type: 'nodeClick';\n    readonly event: MouseEvent;\n    readonly series: AreaSeries;\n    readonly datum: any;\n    readonly xKey: string;\n    readonly yKey: string;\n}\n\ninterface MarkerSelectionDatum extends SeriesNodeDatum {\n    readonly point: {\n        readonly x: number;\n        readonly y: number;\n    };\n    readonly fill?: string;\n    readonly stroke?: string;\n    readonly yKey: string;\n    readonly yValue: number;\n}\n\nexport class AreaSeriesTooltip extends SeriesTooltip {\n    @reactive('change') renderer?: (params: CartesianTooltipRendererParams) => string | TooltipRendererResult;\n    @reactive('change') format?: string;\n}\n\nexport class AreaSeries extends CartesianSeries {\n\n    static className = 'AreaSeries';\n    static type = 'area';\n\n    tooltip: AreaSeriesTooltip = new AreaSeriesTooltip();\n\n    private areaGroup = this.group.appendChild(new Group());\n    private strokeGroup = this.group.appendChild(new Group());\n    private markerGroup = this.group.appendChild(new Group());\n\n    private areaSelection: Selection<Path, Group, AreaSelectionDatum, any> = Selection.select(this.areaGroup).selectAll<Path>();\n    private strokeSelection: Selection<Path, Group, AreaSelectionDatum, any> = Selection.select(this.strokeGroup).selectAll<Path>();\n    private markerSelection: Selection<Marker, Group, any, any> = Selection.select(this.markerGroup).selectAll<Marker>();\n    private markerSelectionData: MarkerSelectionDatum[] = [];\n\n    /**\n     * The assumption is that the values will be reset (to `true`)\n     * in the {@link yKeys} setter.\n     */\n    private readonly seriesItemEnabled = new Map<string, boolean>();\n\n    private xData: string[] = [];\n    private yData: number[][] = [];\n    private yDomain: any[] = [];\n\n    directionKeys = {\n        x: ['xKey'],\n        y: ['yKeys']\n    };\n\n    readonly marker = new CartesianSeriesMarker();\n\n    @reactive('dataChange') fills: string[] = [\n        '#c16068',\n        '#a2bf8a',\n        '#ebcc87',\n        '#80a0c3',\n        '#b58dae',\n        '#85c0d1'\n    ];\n\n    @reactive('dataChange') strokes: string[] = [\n        '#874349',\n        '#718661',\n        '#a48f5f',\n        '#5a7088',\n        '#7f637a',\n        '#5d8692'\n    ];\n\n    @reactive('update') fillOpacity = 1;\n    @reactive('update') strokeOpacity = 1;\n\n    @reactive('update') lineDash?: number[] = undefined;\n    @reactive('update') lineDashOffset: number = 0;\n\n    constructor() {\n        super();\n\n        this.addEventListener('update', this.update);\n\n        this.marker.enabled = false;\n        this.marker.addPropertyListener('shape', this.onMarkerShapeChange, this);\n        this.marker.addEventListener('change', this.update, this);\n    }\n\n    onMarkerShapeChange() {\n        this.markerSelection = this.markerSelection.setData([]);\n        this.markerSelection.exit.remove();\n        this.update();\n\n        this.fireEvent({ type: 'legendChange' });\n    }\n\n    protected _xKey: string = '';\n    set xKey(value: string) {\n        if (this._xKey !== value) {\n            this._xKey = value;\n            this.xData = [];\n            this.scheduleData();\n        }\n    }\n\n    get xKey(): string {\n        return this._xKey;\n    }\n\n    @reactive('update') xName: string = '';\n\n    protected _yKeys: string[] = [];\n    set yKeys(values: string[]) {\n        if (!equal(this._yKeys, values)) {\n            this._yKeys = values;\n            this.yData = [];\n\n            const { seriesItemEnabled } = this;\n            seriesItemEnabled.clear();\n            values.forEach(key => seriesItemEnabled.set(key, true));\n\n            this.scheduleData();\n        }\n    }\n\n    get yKeys(): string[] {\n        return this._yKeys;\n    }\n\n    setColors(fills: string[], strokes: string[]) {\n        this.fills = fills;\n        this.strokes = strokes;\n    }\n\n    @reactive('update') yNames: string[] = [];\n\n    private _normalizedTo?: number;\n    set normalizedTo(value: number | undefined) {\n        const absValue = value ? Math.abs(value) : undefined;\n\n        if (this._normalizedTo !== absValue) {\n            this._normalizedTo = absValue;\n            this.scheduleData();\n        }\n    }\n\n    get normalizedTo(): number | undefined {\n        return this._normalizedTo;\n    }\n\n    @reactive('update') strokeWidth = 2;\n    @reactive('update') shadow?: DropShadow;\n\n    highlightStyle: HighlightStyle = { fill: 'yellow' };\n\n    protected highlightedDatum?: MarkerSelectionDatum;\n\n    onHighlightChange() {\n        this.updateMarkerNodes();\n    }\n\n    processData(): boolean {\n        const { xKey, yKeys, seriesItemEnabled } = this;\n        const data = xKey && yKeys.length && this.data ? this.data : [];\n\n        // if (!(chart && chart.xAxis && chart.yAxis)) {\n        //     return false;\n        // }\n\n        // If the data is an array of rows like so:\n        //\n        // [{\n        //   xKy: 'Jan',\n        //   yKey1: 5,\n        //   yKey2: 7,\n        //   yKey3: -9,\n        // }, {\n        //   xKey: 'Feb',\n        //   yKey1: 10,\n        //   yKey2: -15,\n        //   yKey3: 20\n        // }]\n        //\n\n        let keysFound = true; // only warn once\n        this.xData = data.map(datum => {\n            if (keysFound && !(xKey in datum)) {\n                keysFound = false;\n                console.warn(`The key '${xKey}' was not found in the data: `, datum);\n            }\n            return datum[xKey];\n        });\n\n        this.yData = data.map(datum => yKeys.map(yKey => {\n            if (keysFound && !(yKey in datum)) {\n                keysFound = false;\n                console.warn(`The key '${yKey}' was not found in the data: `, datum);\n            }\n            const value = datum[yKey];\n\n            return isFinite(value) && seriesItemEnabled.get(yKey) ? value : 0;\n        }));\n\n        // xData: ['Jan', 'Feb']\n        //\n        // yData: [\n        //   [5, 7, -9],\n        //   [10, -15, 20]\n        // ]\n\n        const { yData, normalizedTo } = this;\n\n        const yMinMax = yData.map(values => findMinMax(values)); // used for normalization\n        const yLargestMinMax = this.findLargestMinMax(yMinMax);\n\n        let yMin: number;\n        let yMax: number;\n\n        if (normalizedTo && isFinite(normalizedTo)) {\n            yMin = yLargestMinMax.min < 0 ? -normalizedTo : 0;\n            yMax = normalizedTo;\n            yData.forEach((stack, i) => stack.forEach((y, j) => {\n                if (y < 0) {\n                    stack[j] = -y / yMinMax[i].min * normalizedTo;\n                } else {\n                    stack[j] = y / yMinMax[i].max * normalizedTo;\n                }\n            }));\n        } else {\n            yMin = yLargestMinMax.min;\n            yMax = yLargestMinMax.max;\n        }\n\n        if (yMin === 0 && yMax === 0) {\n            yMax = 1;\n        }\n\n        this.yDomain = this.fixNumericExtent([yMin, yMax], 'y');\n\n        this.fireEvent({ type: 'dataProcessed' });\n\n        return true;\n    }\n\n    findLargestMinMax(totals: { min: number, max: number }[]): { min: number, max: number } {\n        let min = 0;\n        let max = 0;\n\n        for (const total of totals) {\n            if (total.min < min) {\n                min = total.min;\n            }\n            if (total.max > max) {\n                max = total.max;\n            }\n        }\n\n        return { min, max };\n    }\n\n    getDomain(direction: ChartAxisDirection): any[] {\n        if (direction === ChartAxisDirection.X) {\n            return this.xData;\n        } else {\n            return this.yDomain;\n        }\n    }\n\n    update(): void {\n        const { visible, chart, xAxis, yAxis, xData, yData } = this;\n\n        this.group.visible = visible && !!(xData.length && yData.length);\n\n        if (!xAxis || !yAxis || !visible || !chart || chart.layoutPending || chart.dataPending || !xData.length || !yData.length) {\n            return;\n        }\n\n        const selectionData = this.generateSelectionData();\n        if (!selectionData) {\n            return;\n        }\n\n        const { areaSelectionData, markerSelectionData } = selectionData;\n        this.updateAreaSelection(areaSelectionData);\n        this.updateStrokeSelection(areaSelectionData);\n        this.updateMarkerSelection(markerSelectionData);\n        this.updateMarkerNodes();\n        this.markerSelectionData = markerSelectionData;\n    }\n\n    private generateSelectionData(): {\n        areaSelectionData: AreaSelectionDatum[],\n        markerSelectionData: MarkerSelectionDatum[]\n    } | undefined {\n        const { xAxis, yAxis } = this;\n\n        if (!this.data || !xAxis || !yAxis) {\n            return;\n        }\n\n        const { yKeys, data, xData, yData, marker, fills, strokes } = this;\n        const xScale = xAxis.scale;\n        const yScale = yAxis.scale;\n\n        const xOffset = (xScale.bandwidth || 0) / 2;\n        const yOffset = (yScale.bandwidth || 0) / 2;\n        const areaSelectionData: AreaSelectionDatum[] = [];\n        const markerSelectionData: MarkerSelectionDatum[] = [];\n        const last = xData.length * 2 - 1;\n\n        xData.forEach((xDatum, i) => {\n            const yDatum = yData[i];\n            const seriesDatum = data[i];\n            const x = xScale.convert(xDatum) + xOffset;\n\n            let prevMin = 0;\n            let prevMax = 0;\n\n            yDatum.forEach((curr, j) => {\n                const prev = curr < 0 ? prevMin : prevMax;\n                const y = yScale.convert(prev + curr) + yOffset;\n                const yKey = yKeys[j];\n                const yValue = seriesDatum[yKey];\n\n                if (marker) {\n                    markerSelectionData.push({\n                        series: this,\n                        seriesDatum,\n                        yValue,\n                        yKey,\n                        point: { x, y },\n                        fill: fills[j % fills.length],\n                        stroke: strokes[j % strokes.length]\n                    });\n                }\n\n                const areaDatum = areaSelectionData[j] || (areaSelectionData[j] = { yKey, points: [] });\n                const areaPoints = areaDatum.points;\n\n                areaPoints[i] = { x, y };\n                areaPoints[last - i] = { x, y: yScale.convert(prev) + yOffset }; // bottom y\n\n                if (curr < 0) {\n                    prevMin += curr;\n                } else {\n                    prevMax += curr;\n                }\n            });\n        });\n\n        return { areaSelectionData, markerSelectionData };\n    }\n\n    private updateAreaSelection(areaSelectionData: AreaSelectionDatum[]): void {\n        const {\n            fills, fillOpacity, strokes, strokeOpacity, strokeWidth,\n            seriesItemEnabled, shadow\n        } = this;\n        const updateAreas = this.areaSelection.setData(areaSelectionData);\n\n        updateAreas.exit.remove();\n\n        const enterAreas = updateAreas.enter.append(Path)\n            .each(path => {\n                path.lineJoin = 'round';\n                path.stroke = undefined;\n                path.pointerEvents = PointerEvents.None;\n            });\n\n        const areaSelection = updateAreas.merge(enterAreas);\n\n        areaSelection.each((shape, datum, index) => {\n            const path = shape.path;\n\n            shape.fill = fills[index % fills.length];\n            shape.fillOpacity = fillOpacity;\n            shape.stroke = strokes[index % strokes.length];\n            shape.strokeOpacity = strokeOpacity;\n            shape.strokeWidth = strokeWidth;\n            shape.lineDash = this.lineDash;\n            shape.lineDashOffset = this.lineDashOffset;\n            shape.fillShadow = shadow;\n            shape.visible = !!seriesItemEnabled.get(datum.yKey);\n\n            path.clear();\n\n            const { points } = datum;\n\n            points.forEach(({ x, y }, i) => {\n                if (i > 0) {\n                    path.lineTo(x, y);\n                } else {\n                    path.moveTo(x, y);\n                }\n            });\n\n            path.closePath();\n        });\n\n        this.areaSelection = areaSelection;\n    }\n\n    private updateStrokeSelection(areaSelectionData: AreaSelectionDatum[]): void {\n        if (!this.data) {\n            return;\n        }\n\n        const { strokes, strokeWidth, strokeOpacity, data, seriesItemEnabled } = this;\n        const updateStrokes = this.strokeSelection.setData(areaSelectionData);\n\n        updateStrokes.exit.remove();\n\n        const enterStrokes = updateStrokes.enter.append(Path)\n            .each(path => {\n                path.fill = undefined;\n                path.lineJoin = path.lineCap = 'round';\n                path.pointerEvents = PointerEvents.None;\n            });\n\n        const strokeSelection = updateStrokes.merge(enterStrokes);\n\n        strokeSelection.each((shape, datum, index) => {\n            const path = shape.path;\n\n            shape.stroke = strokes[index % strokes.length];\n            shape.strokeWidth = strokeWidth;\n            shape.visible = !!seriesItemEnabled.get(datum.yKey);\n            shape.strokeOpacity = strokeOpacity;\n            shape.lineDash = this.lineDash;\n            shape.lineDashOffset = this.lineDashOffset;\n\n            path.clear();\n\n            const points = datum.points;\n\n            // The stroke doesn't go all the way around the fill, only on top,\n            // that's why we iterate until `data.length` (rather than `points.length`) and stop.\n            for (let i = 0; i < data.length; i++) {\n                const { x, y } = points[i];\n\n                if (i > 0) {\n                    path.lineTo(x, y);\n                } else {\n                    path.moveTo(x, y);\n                }\n            }\n        });\n\n        this.strokeSelection = strokeSelection;\n    }\n\n    private updateMarkerSelection(markerSelectionData: MarkerSelectionDatum[]): void {\n        const { marker } = this;\n        const data = marker.shape ? markerSelectionData : [];\n        const MarkerShape = getMarker(marker.shape);\n        const updateMarkers = this.markerSelection.setData(data);\n        updateMarkers.exit.remove();\n        const enterMarkers = updateMarkers.enter.append(MarkerShape);\n        this.markerSelection = updateMarkers.merge(enterMarkers);\n    }\n\n    private updateMarkerNodes(): void {\n        if (!this.chart) {\n            return;\n        }\n\n        const { marker } = this;\n        const markerFormatter = marker.formatter;\n        const markerStrokeWidth = marker.strokeWidth !== undefined ? marker.strokeWidth : this.strokeWidth;\n        const markerSize = marker.size;\n        const { xKey, seriesItemEnabled } = this;\n        const { highlightedDatum } = this.chart;\n        const { fill: highlightFill, stroke: highlightStroke } = this.highlightStyle;\n\n        this.markerSelection.each((node, datum) => {\n            const highlighted = datum === highlightedDatum;\n            const markerFill = highlighted && highlightFill !== undefined ? highlightFill : marker.fill || datum.fill;\n            const markerStroke = highlighted && highlightStroke !== undefined ? highlightStroke : marker.stroke || datum.stroke;\n            let markerFormat: CartesianSeriesMarkerFormat | undefined = undefined;\n\n            if (markerFormatter) {\n                markerFormat = markerFormatter({\n                    datum: datum.seriesDatum,\n                    xKey,\n                    yKey: datum.yKey,\n                    fill: markerFill,\n                    stroke: markerStroke,\n                    strokeWidth: markerStrokeWidth,\n                    size: markerSize,\n                    highlighted\n                });\n            }\n\n            node.fill = markerFormat && markerFormat.fill || markerFill;\n            node.stroke = markerFormat && markerFormat.stroke || markerStroke;\n            node.strokeWidth = markerFormat && markerFormat.strokeWidth !== undefined\n                ? markerFormat.strokeWidth\n                : markerStrokeWidth;\n            node.size = markerFormat && markerFormat.size !== undefined\n                ? markerFormat.size\n                : markerSize;\n\n            node.translationX = datum.point.x;\n            node.translationY = datum.point.y;\n            node.visible = marker.enabled && node.size > 0 && !!seriesItemEnabled.get(datum.yKey);\n        });\n    }\n\n    getNodeData(): MarkerSelectionDatum[] {\n        return this.markerSelectionData;\n    }\n\n    fireNodeClickEvent(event: MouseEvent, datum: MarkerSelectionDatum): void {\n        this.fireEvent<AreaSeriesNodeClickEvent>({\n            type: 'nodeClick',\n            event,\n            series: this,\n            datum: datum.seriesDatum,\n            xKey: this.xKey,\n            yKey: datum.yKey\n        });\n    }\n\n    getTooltipHtml(nodeDatum: MarkerSelectionDatum): string {\n        const { xKey } = this;\n        const { yKey } = nodeDatum;\n\n        if (!xKey || !yKey) {\n            return '';\n        }\n\n        const { xName, yKeys, yNames, fills, tooltip } = this;\n        const {\n            renderer: tooltipRenderer,\n            format: tooltipFormat\n        } = tooltip;\n        const datum = nodeDatum.seriesDatum;\n        const xValue = datum[xKey];\n        const yValue = datum[yKey];\n        const yKeyIndex = yKeys.indexOf(yKey);\n        const yName = yNames[yKeyIndex];\n        const color = fills[yKeyIndex % fills.length];\n        const xString = typeof xValue === 'number' ? toFixed(xValue) : String(xValue);\n        const yString = typeof yValue === 'number' ? toFixed(yValue) : String(yValue);\n        const title = yName;\n        const content = xString + ': ' + yString;\n        const defaults: TooltipRendererResult = {\n            title,\n            backgroundColor: color,\n            content\n        };\n\n        if (tooltipFormat || tooltipRenderer) {\n            const params = {\n                datum,\n                xKey,\n                xName,\n                xValue,\n                yKey,\n                yValue,\n                yName,\n                color\n            };\n            if (tooltipFormat) {\n                return toTooltipHtml({\n                    content: interpolate(tooltipFormat, params)\n                }, defaults);\n            }\n            if (tooltipRenderer) {\n                return toTooltipHtml(tooltipRenderer(params), defaults);\n            }\n        }\n\n        return toTooltipHtml(defaults);\n    }\n\n    listSeriesItems(legendData: LegendDatum[]): void {\n        const {\n            data, id, xKey, yKeys, yNames, seriesItemEnabled,\n            marker, fills, strokes, fillOpacity, strokeOpacity\n        } = this;\n\n        if (data && data.length && xKey && yKeys.length) {\n            yKeys.forEach((yKey, index) => {\n                legendData.push({\n                    id,\n                    itemId: yKey,\n                    enabled: seriesItemEnabled.get(yKey) || false,\n                    label: {\n                        text: yNames[index] || yKeys[index]\n                    },\n                    marker: {\n                        shape: marker.shape,\n                        fill: marker.fill || fills[index % fills.length],\n                        stroke: marker.stroke || strokes[index % strokes.length],\n                        fillOpacity,\n                        strokeOpacity\n                    }\n                });\n            });\n        }\n    }\n\n    toggleSeriesItem(itemId: string, enabled: boolean): void {\n        this.seriesItemEnabled.set(itemId, enabled);\n        this.scheduleData();\n    }\n}\n","/Users/vitaliikravchenko/Sites/nova/client/src/charts/chart/series/cartesian/scatterSeries.ts",["533","534","535","536"],"import { Selection } from \"../../../scene/selection\";\nimport { Group } from \"../../../scene/group\";\nimport { SeriesNodeDatum, CartesianTooltipRendererParams, HighlightStyle, SeriesTooltip } from \"../series\";\nimport { finiteExtent } from \"../../../util/array\";\nimport { toFixed } from \"../../../util/number\";\nimport { LegendDatum } from \"../../legend\";\nimport { LinearScale } from \"../../../scale/linearScale\";\nimport { reactive, TypedEvent } from \"../../../util/observable\";\nimport { CartesianSeries, CartesianSeriesMarker, CartesianSeriesMarkerFormat } from \"./cartesianSeries\";\nimport { ChartAxisDirection } from \"../../chartAxis\";\nimport { getMarker } from \"../../marker/util\";\nimport { TooltipRendererResult, toTooltipHtml } from \"../../chart\";\nimport ContinuousScale from \"../../../scale/continuousScale\";\n\ninterface ScatterNodeDatum extends SeriesNodeDatum {\n    readonly point: {\n        readonly x: number;\n        readonly y: number;\n    };\n    readonly size: number;\n}\n\nexport interface ScatterSeriesNodeClickEvent extends TypedEvent {\n    readonly type: 'nodeClick';\n    readonly event: MouseEvent;\n    readonly series: ScatterSeries;\n    readonly datum: any;\n    readonly xKey: string;\n    readonly yKey: string;\n    readonly sizeKey?: string;\n}\n\nexport interface ScatterTooltipRendererParams extends CartesianTooltipRendererParams {\n    readonly sizeKey?: string;\n    readonly sizeName?: string;\n\n    readonly labelKey?: string;\n    readonly labelName?: string;\n}\n\nexport class ScatterSeriesTooltip extends SeriesTooltip {\n    @reactive('change') renderer?: (params: ScatterTooltipRendererParams) => string | TooltipRendererResult;\n}\n\nexport class ScatterSeries extends CartesianSeries {\n\n    static className = 'ScatterSeries';\n    static type = 'scatter';\n\n    private xDomain: number[] = [];\n    private yDomain: number[] = [];\n    private xData: any[] = [];\n    private yData: any[] = [];\n    private sizeData: number[] = [];\n    private sizeScale = new LinearScale();\n\n    private nodeSelection: Selection<Group, Group, ScatterNodeDatum, any> = Selection.select(this.group).selectAll<Group>();\n    private nodeData: ScatterNodeDatum[] = [];\n\n    readonly marker = new CartesianSeriesMarker();\n\n    private _fill: string | undefined = '#c16068';\n    set fill(value: string | undefined) {\n        if (this._fill !== value) {\n            this._fill = value;\n            this.scheduleData();\n        }\n    }\n\n    get fill(): string | undefined {\n        return this._fill;\n    }\n\n    private _stroke: string | undefined = '#874349';\n    set stroke(value: string | undefined) {\n        if (this._stroke !== value) {\n            this._stroke = value;\n            this.scheduleData();\n        }\n    }\n\n    get stroke(): string | undefined {\n        return this._stroke;\n    }\n\n    private _strokeWidth: number = 2;\n    set strokeWidth(value: number) {\n        if (this._strokeWidth !== value) {\n            this._strokeWidth = value;\n            this.update();\n        }\n    }\n\n    get strokeWidth(): number {\n        return this._strokeWidth;\n    }\n\n    private _fillOpacity: number = 1;\n    set fillOpacity(value: number) {\n        if (this._fillOpacity !== value) {\n            this._fillOpacity = value;\n            this.scheduleLayout();\n        }\n    }\n\n    get fillOpacity(): number {\n        return this._fillOpacity;\n    }\n\n    private _strokeOpacity: number = 1;\n    set strokeOpacity(value: number) {\n        if (this._strokeOpacity !== value) {\n            this._strokeOpacity = value;\n            this.scheduleLayout();\n        }\n    }\n\n    get strokeOpacity(): number {\n        return this._strokeOpacity;\n    }\n\n    highlightStyle: HighlightStyle = { fill: 'yellow' };\n\n    onHighlightChange() {\n        this.updateNodes();\n    }\n\n    @reactive('layoutChange') title?: string;\n    @reactive('dataChange') xKey: string = '';\n    @reactive('dataChange') yKey: string = '';\n    @reactive('dataChange') sizeKey?: string;\n    @reactive('dataChange') labelKey?: string;\n\n    xName: string = '';\n    yName: string = '';\n    sizeName?: string = 'Size';\n    labelName?: string = 'Label';\n\n    tooltip: ScatterSeriesTooltip = new ScatterSeriesTooltip();\n\n    constructor() {\n        super();\n\n        const { marker } = this;\n        marker.addPropertyListener('shape', this.onMarkerShapeChange, this);\n        marker.addEventListener('change', this.update, this);\n\n        this.addPropertyListener('xKey', () => this.xData = []);\n        this.addPropertyListener('yKey', () => this.yData = []);\n        this.addPropertyListener('sizeKey', () => this.sizeData = []);\n    }\n\n    onMarkerShapeChange() {\n        this.nodeSelection = this.nodeSelection.setData([]);\n        this.nodeSelection.exit.remove();\n        this.update();\n\n        this.fireEvent({ type: 'legendChange' });\n    }\n\n    setColors(fills: string[], strokes: string[]) {\n        this.fill = fills[0];\n        this.stroke = strokes[0];\n        this.marker.fill = fills[0];\n        this.marker.stroke = strokes[0];\n    }\n\n    processData(): boolean {\n        const { xKey, yKey, sizeKey, xAxis, yAxis } = this;\n\n        if (!xAxis || !yAxis) {\n            return false;\n        }\n\n        const data = xKey && yKey && this.data ? this.data : [];\n\n        this.xData = data.map(d => d[xKey]);\n        this.yData = data.map(d => d[yKey]);\n\n        if (sizeKey) {\n            this.sizeData = data.map(d => d[sizeKey]);\n        } else {\n            this.sizeData = [];\n        }\n\n        this.sizeScale.domain = finiteExtent(this.sizeData) || [1, 1];\n        if (xAxis.scale instanceof ContinuousScale) {\n            this.xDomain = this.fixNumericExtent(finiteExtent(this.xData), 'x');\n        } else {\n            this.xDomain = this.xData;\n        }\n        if (yAxis.scale instanceof ContinuousScale) {\n            this.yDomain = this.fixNumericExtent(finiteExtent(this.yData), 'y');\n        } else {\n            this.yDomain = this.yData;\n        }\n\n        return true;\n    }\n\n    getDomain(direction: ChartAxisDirection): any[] {\n        if (direction === ChartAxisDirection.X) {\n            return this.xDomain;\n        } else {\n            return this.yDomain;\n        }\n    }\n\n    getNodeData(): ScatterNodeDatum[] {\n        return this.nodeData;\n    }\n\n    fireNodeClickEvent(event: MouseEvent, datum: ScatterNodeDatum): void {\n        this.fireEvent<ScatterSeriesNodeClickEvent>({\n            type: 'nodeClick',\n            event,\n            series: this,\n            datum: datum.seriesDatum,\n            xKey: this.xKey,\n            yKey: this.yKey,\n            sizeKey: this.sizeKey\n        });\n    }\n\n    private generateNodeData(): ScatterNodeDatum[] {\n        const { xAxis, yAxis } = this;\n\n        if (!this.data || !xAxis || !yAxis) {\n            return [];\n        }\n\n        const xScale = xAxis.scale;\n        const yScale = yAxis.scale;\n        const isContinuousX = xScale instanceof ContinuousScale;\n        const isContinuousY = yScale instanceof ContinuousScale;\n        const xOffset = (xScale.bandwidth || 0) / 2;\n        const yOffset = (yScale.bandwidth || 0) / 2;\n\n        const { data, xData, yData, sizeData, sizeScale, marker } = this;\n\n        sizeScale.range = [marker.size, marker.maxSize];\n\n        const nodeData: ScatterNodeDatum[] = [];\n        for (let i = 0; i < xData.length; i++) {\n            const xDatum = xData[i];\n            const yDatum = yData[i];\n            const noDatum =\n                yDatum == null || (isContinuousY && (isNaN(yDatum) || !isFinite(yDatum))) ||\n                xDatum == null || (isContinuousX && (isNaN(xDatum) || !isFinite(xDatum)));\n            if (noDatum) {\n                continue;\n            }\n\n            const x = xScale.convert(xDatum) + xOffset;\n            if (!xAxis.inRange(x)) {\n                continue;\n            }\n            nodeData.push({\n                series: this,\n                seriesDatum: data[i],\n                point: {\n                    x,\n                    y: yScale.convert(yData[i]) + yOffset\n                },\n                size: sizeData.length ? sizeScale.convert(sizeData[i]) : marker.size\n            });\n        }\n\n        return nodeData;\n    }\n\n    update(): void {\n        const { visible, chart, xAxis, yAxis } = this;\n\n        this.group.visible = visible;\n\n        if (!visible || !chart || chart.layoutPending || chart.dataPending || !xAxis || !yAxis) {\n            return;\n        }\n\n        const nodeData = this.nodeData = this.generateNodeData();\n\n        this.updateNodeSelection(nodeData);\n        this.updateNodes();\n    }\n\n    private updateNodeSelection(nodeData: ScatterNodeDatum[]): void {\n        const MarkerShape = getMarker(this.marker.shape);\n\n        const updateSelection = this.nodeSelection.setData(nodeData);\n        updateSelection.exit.remove();\n\n        const enterSelection = updateSelection.enter.append(Group);\n        enterSelection.append(MarkerShape);\n\n        this.nodeSelection = updateSelection.merge(enterSelection);\n    }\n\n    private updateNodes(): void {\n        if (!this.chart) {\n            return;\n        }\n\n        const { highlightedDatum } = this.chart;\n        const { marker, xKey, yKey, fill, stroke, strokeWidth, fillOpacity, strokeOpacity } = this;\n        const { fill: highlightFill, stroke: highlightStroke } = this.highlightStyle;\n        const markerStrokeWidth = marker.strokeWidth !== undefined ? marker.strokeWidth : strokeWidth;\n        const MarkerShape = getMarker(marker.shape);\n        const markerFormatter = marker.formatter;\n\n        this.nodeSelection.selectByClass(MarkerShape)\n            .each((node, datum) => {\n                const highlighted = datum === highlightedDatum;\n                const markerFill = highlighted && highlightFill !== undefined ? highlightFill : marker.fill || fill;\n                const markerStroke = highlighted && highlightStroke !== undefined ? highlightStroke : marker.stroke || stroke;\n                let markerFormat: CartesianSeriesMarkerFormat | undefined = undefined;\n\n                if (markerFormatter) {\n                    markerFormat = markerFormatter({\n                        datum: datum.seriesDatum,\n                        xKey,\n                        yKey,\n                        fill: markerFill,\n                        stroke: markerStroke,\n                        strokeWidth: markerStrokeWidth,\n                        size: datum.size,\n                        highlighted\n                    });\n                }\n\n                node.fill = markerFormat && markerFormat.fill || markerFill;\n                node.stroke = markerFormat && markerFormat.stroke || markerStroke;\n                node.strokeWidth = markerFormat && markerFormat.strokeWidth !== undefined\n                    ? markerFormat.strokeWidth\n                    : markerStrokeWidth;\n                node.size = markerFormat && markerFormat.size !== undefined\n                    ? markerFormat.size\n                    : datum.size;\n                node.fillOpacity = fillOpacity;\n                node.strokeOpacity = strokeOpacity;\n                node.translationX = datum.point.x;\n                node.translationY = datum.point.y;\n                node.visible = marker.enabled && node.size > 0;\n            });\n    }\n\n    getTooltipHtml(nodeDatum: ScatterNodeDatum): string {\n        const { xKey, yKey } = this;\n\n        if (!xKey || !yKey) {\n            return '';\n        }\n\n        const {\n            tooltip,\n            xName,\n            yName,\n            sizeKey,\n            sizeName,\n            labelKey,\n            labelName,\n            fill\n        } = this;\n\n        const { renderer: tooltipRenderer } = tooltip;\n        const color = fill || 'gray';\n        const title = this.title || yName;\n        const datum = nodeDatum.seriesDatum;\n        const xValue = datum[xKey];\n        const yValue = datum[yKey];\n\n        let content = `<b>${xName || xKey}</b>: ${typeof xValue === 'number' ? toFixed(xValue) : xValue}`\n            + `<br><b>${yName || yKey}</b>: ${typeof yValue === 'number' ? toFixed(yValue) : yValue}`;\n\n        if (sizeKey) {\n            content += `<br><b>${sizeName}</b>: ${datum[sizeKey]}`;\n        }\n\n        if (labelKey) {\n            content = `<b>${labelName}</b>: ${datum[labelKey]}<br>` + content;\n        }\n\n        const defaults: TooltipRendererResult = {\n            title,\n            backgroundColor: color,\n            content\n        };\n\n        if (tooltipRenderer) {\n            return toTooltipHtml(tooltipRenderer({\n                datum,\n                xKey,\n                xValue,\n                xName,\n                yKey,\n                yValue,\n                yName,\n                sizeKey,\n                sizeName,\n                labelKey,\n                labelName,\n                title,\n                color\n            }), defaults);\n        }\n\n        return toTooltipHtml(defaults);\n    }\n\n    listSeriesItems(legendData: LegendDatum[]): void {\n        const {\n            id, data, xKey, yKey, yName,\n            title, visible, marker, fill, stroke, fillOpacity, strokeOpacity\n        } = this;\n\n        if (data && data.length && xKey && yKey) {\n            legendData.push({\n                id,\n                itemId: undefined,\n                enabled: visible,\n                label: {\n                    text: title || yName || yKey\n                },\n                marker: {\n                    shape: marker.shape,\n                    fill: marker.fill || fill || 'rgba(0, 0, 0, 0)',\n                    stroke: marker.stroke || stroke || 'rgba(0, 0, 0, 0)',\n                    fillOpacity,\n                    strokeOpacity\n                }\n            });\n        }\n    }\n}\n","/Users/vitaliikravchenko/Sites/nova/client/src/charts/chart/series/cartesian/histogramSeries.ts",[],"/Users/vitaliikravchenko/Sites/nova/client/src/charts/chart/series/cartesian/barSeries.ts",["537","538","539","540"],"import { Group } from \"../../../scene/group\";\nimport { Selection } from \"../../../scene/selection\";\nimport { Rect } from \"../../../scene/shape/rect\";\nimport { Text, FontStyle, FontWeight } from \"../../../scene/shape/text\";\nimport { BandScale } from \"../../../scale/bandScale\";\nimport { DropShadow } from \"../../../scene/dropShadow\";\nimport {\n    HighlightStyle,\n    SeriesNodeDatum,\n    CartesianTooltipRendererParams, SeriesTooltip\n} from \"../series\";\nimport { Label } from \"../../label\";\nimport { PointerEvents } from \"../../../scene/node\";\nimport { LegendDatum } from \"../../legend\";\nimport { CartesianSeries } from \"./cartesianSeries\";\nimport { ChartAxisDirection, flipChartAxisDirection } from \"../../chartAxis\";\nimport { TooltipRendererResult, toTooltipHtml } from \"../../chart\";\nimport { findMinMax } from \"../../../util/array\";\nimport { toFixed } from \"../../../util/number\";\nimport { equal } from \"../../../util/equal\";\nimport { reactive, TypedEvent } from \"../../../util/observable\";\n\nexport interface BarSeriesNodeClickEvent extends TypedEvent {\n    readonly type: 'nodeClick';\n    readonly event: MouseEvent;\n    readonly series: BarSeries;\n    readonly datum: any;\n    readonly xKey: string;\n    readonly yKey: string;\n}\n\ninterface BarNodeDatum extends SeriesNodeDatum {\n    readonly yKey: string;\n    readonly yValue: number;\n    readonly x: number;\n    readonly y: number;\n    readonly width: number;\n    readonly height: number;\n    readonly fill?: string;\n    readonly stroke?: string;\n    readonly strokeWidth: number;\n    readonly label?: {\n        readonly text: string;\n        readonly fontStyle?: FontStyle;\n        readonly fontWeight?: FontWeight;\n        readonly fontSize: number;\n        readonly fontFamily: string;\n        readonly fill: string;\n        readonly x: number;\n        readonly y: number;\n    };\n}\n\nenum BarSeriesNodeTag {\n    Bar,\n    Label\n}\n\nclass BarSeriesLabel extends Label {\n    @reactive('change') formatter?: (params: { value: number }) => string;\n}\n\nexport interface BarSeriesFormatterParams {\n    readonly datum: any;\n    readonly fill?: string;\n    readonly stroke?: string;\n    readonly strokeWidth: number;\n    readonly highlighted: boolean;\n    readonly xKey: string;\n    readonly yKey: string;\n}\n\nexport interface BarSeriesFormat {\n    fill?: string;\n    stroke?: string;\n    strokeWidth?: number;\n}\n\nexport class BarSeriesTooltip extends SeriesTooltip {\n    @reactive('change') renderer?: (params: CartesianTooltipRendererParams) => string | TooltipRendererResult;\n}\n\nexport class BarSeries extends CartesianSeries {\n\n    static className = 'BarSeries';\n    static type = 'bar';\n\n    // Need to put bar and label nodes into separate groups, because even though label nodes are\n    // created after the bar nodes, this only guarantees that labels will always be on top of bars\n    // on the first run. If on the next run more bars are added, they might clip the labels\n    // rendered during the previous run.\n    private rectGroup = this.group.appendChild(new Group());\n    private textGroup = this.group.appendChild(new Group());\n\n    private rectSelection: Selection<Rect, Group, BarNodeDatum, any> = Selection.select(this.rectGroup).selectAll<Rect>();\n    private textSelection: Selection<Text, Group, BarNodeDatum, any> = Selection.select(this.textGroup).selectAll<Text>();\n\n    private xData: string[] = [];\n    private yData: number[][][] = [];\n    private yDomain: number[] = [];\n\n    readonly label = new BarSeriesLabel();\n\n    /**\n     * The assumption is that the values will be reset (to `true`)\n     * in the {@link yKeys} setter.\n     */\n    private readonly seriesItemEnabled = new Map<string, boolean>();\n\n    tooltip: BarSeriesTooltip = new BarSeriesTooltip();\n\n    @reactive('layoutChange') flipXY = false;\n\n    @reactive('dataChange') fills: string[] = [\n        '#c16068',\n        '#a2bf8a',\n        '#ebcc87',\n        '#80a0c3',\n        '#b58dae',\n        '#85c0d1'\n    ];\n\n    @reactive('dataChange') strokes: string[] = [\n        '#874349',\n        '#718661',\n        '#a48f5f',\n        '#5a7088',\n        '#7f637a',\n        '#5d8692'\n    ];\n\n    @reactive('layoutChange') fillOpacity = 1;\n    @reactive('layoutChange') strokeOpacity = 1;\n\n    @reactive('update') lineDash?: number[] = undefined;\n    @reactive('update') lineDashOffset: number = 0;\n\n    @reactive('update') formatter?: (params: BarSeriesFormatterParams) => BarSeriesFormat;\n\n    constructor() {\n        super();\n\n        this.addEventListener('update', this.update);\n\n        this.label.enabled = false;\n        this.label.addEventListener('change', this.update, this);\n    }\n\n    /**\n     * Used to get the position of bars within each group.\n     */\n    private groupScale = new BandScale<string>();\n\n    directionKeys = {\n        [ChartAxisDirection.X]: ['xKey'],\n        [ChartAxisDirection.Y]: ['yKeys']\n    };\n\n    getKeys(direction: ChartAxisDirection): string[] {\n        const { directionKeys } = this;\n        const keys = directionKeys && directionKeys[this.flipXY ? flipChartAxisDirection(direction) : direction];\n        const values: string[] = [];\n\n        if (keys) {\n            keys.forEach(key => {\n                const value = (this as any)[key];\n\n                if (value) {\n                    if (Array.isArray(value)) {\n                        values.push(...value);\n                    } else {\n                        values.push(value);\n                    }\n                }\n            });\n        }\n\n        return values;\n    }\n\n    protected _xKey: string = '';\n    set xKey(value: string) {\n        if (this._xKey !== value) {\n            this._xKey = value;\n            this.xData = [];\n            this.scheduleData();\n        }\n    }\n\n    get xKey(): string {\n        return this._xKey;\n    }\n\n    protected _xName: string = '';\n    set xName(value: string) {\n        if (this._xName !== value) {\n            this._xName = value;\n            this.update();\n        }\n    }\n\n    get xName(): string {\n        return this._xName;\n    }\n\n    private cumYKeyCount: number[] = [];\n    private flatYKeys: string[] | undefined = undefined; // only set when a user used a flat array for yKeys\n\n    @reactive('layoutChange') hideInLegend: string[] = [];\n\n    /**\n     * yKeys: [['coffee']] - regular bars, each category has a single bar that shows a value for coffee\n     * yKeys: [['coffee'], ['tea'], ['milk']] - each category has three bars that show values for coffee, tea and milk\n     * yKeys: [['coffee', 'tea', 'milk']] - each category has a single bar with three stacks that show values for coffee, tea and milk\n     * yKeys: [['coffee', 'tea', 'milk'], ['paper', 'ink']] - each category has 2 stacked bars,\n     *     first showing values for coffee, tea and milk and second values for paper and ink\n     */\n    protected _yKeys: string[][] = [];\n    set yKeys(yKeys: string[][]) {\n        if (!equal(this._yKeys, yKeys)) {\n            // Convert from flat y-keys to grouped y-keys.\n            if (yKeys.length && !Array.isArray(yKeys[0])) {\n                const keys = this.flatYKeys = yKeys as any as string[];\n                if (this.grouped) {\n                    yKeys = keys.map(k => [k]);\n                } else {\n                    yKeys = [keys];\n                }\n            } else {\n                this.flatYKeys = undefined;\n            }\n\n            this._yKeys = yKeys;\n\n            let prevYKeyCount = 0;\n            this.cumYKeyCount = [];\n            const visibleStacks: string[] = [];\n            yKeys.forEach((stack, index) => {\n                if (stack.length > 0) {\n                    visibleStacks.push(String(index));\n                }\n                this.cumYKeyCount.push(prevYKeyCount);\n                prevYKeyCount += stack.length;\n            });\n            this.yData = [];\n\n            const { seriesItemEnabled } = this;\n            seriesItemEnabled.clear();\n            yKeys.forEach(stack => {\n                stack.forEach(yKey => seriesItemEnabled.set(yKey, true));\n            });\n\n            const { groupScale } = this;\n            groupScale.domain = visibleStacks;\n            groupScale.padding = 0.1;\n            groupScale.round = true;\n\n            this.scheduleData();\n        }\n    }\n\n    get yKeys(): string[][] {\n        return this._yKeys;\n    }\n\n    protected _grouped: boolean = false;\n    set grouped(value: boolean) {\n        if (this._grouped !== value) {\n            this._grouped = value;\n            if (this.flatYKeys) {\n                this.yKeys = this.flatYKeys as any;\n            }\n        }\n    }\n    get grouped(): boolean {\n        return this._grouped;\n    }\n\n    /**\n     * A map of `yKeys` to their names (used in legends and tooltips).\n     * For example, if a key is `product_name` it's name can be a more presentable `Product Name`.\n     */\n    protected _yNames: { [key in string]: string } = {};\n    set yNames(values: { [key in string]: string }) {\n        if (Array.isArray(values) && this.flatYKeys) {\n            const map: { [key in string]: string } = {};\n            this.flatYKeys.forEach((k, i) => {\n                map[k] = values[i];\n            });\n            values = map;\n        }\n        this._yNames = values;\n        this.scheduleData();\n    }\n\n    get yNames(): { [key in string]: string } {\n        return this._yNames;\n    }\n\n    setColors(fills: string[], strokes: string[]) {\n        this.fills = fills;\n        this.strokes = strokes;\n    }\n\n    /**\n     * The value to normalize the bars to.\n     * Should be a finite positive value or `undefined`.\n     * Defaults to `undefined` - bars are not normalized.\n     */\n    private _normalizedTo?: number;\n    set normalizedTo(value: number | undefined) {\n        const absValue = value ? Math.abs(value) : undefined;\n\n        if (this._normalizedTo !== absValue) {\n            this._normalizedTo = absValue;\n            this.scheduleData();\n        }\n    }\n\n    get normalizedTo(): number | undefined {\n        return this._normalizedTo;\n    }\n\n    private _strokeWidth: number = 1;\n    set strokeWidth(value: number) {\n        if (this._strokeWidth !== value) {\n            this._strokeWidth = value;\n            this.update();\n        }\n    }\n\n    get strokeWidth(): number {\n        return this._strokeWidth;\n    }\n\n    private _shadow?: DropShadow;\n    set shadow(value: DropShadow | undefined) {\n        if (this._shadow !== value) {\n            this._shadow = value;\n            this.update();\n        }\n    }\n\n    get shadow(): DropShadow | undefined {\n        return this._shadow;\n    }\n\n    highlightStyle: HighlightStyle = { fill: 'yellow' };\n\n    onHighlightChange() {\n        this.updateRectNodes();\n    }\n\n    processData(): boolean {\n        const { xKey, yKeys, seriesItemEnabled } = this;\n        const data = xKey && yKeys.length && this.data ? this.data : [];\n\n        let keysFound = true; // only warn once\n        this.xData = data.map(datum => {\n            if (keysFound && !(xKey in datum)) {\n                keysFound = false;\n                console.warn(`The key '${xKey}' was not found in the data: `, datum);\n            }\n            return datum[xKey];\n        });\n\n        this.yData = data.map(datum => yKeys.map(stack => {\n            return stack.map(yKey => {\n                if (keysFound && !(yKey in datum)) {\n                    keysFound = false;\n                    console.warn(`The key '${yKey}' was not found in the data: `, datum);\n                }\n                const value = datum[yKey];\n\n                return isFinite(value) && seriesItemEnabled.get(yKey) ? value : 0;\n            });\n        }));\n\n        // Used for normalization of stacked bars. Contains min/max values for each stack in each group,\n        // where min is zero and max is a positive total of all values in the stack\n        // or min is a negative total of all values in the stack and max is zero.\n        const yMinMax = this.yData.map(group => group.map(stack => findMinMax(stack)));\n        const { yData, normalizedTo } = this;\n\n        const yLargestMinMax = this.findLargestMinMax(yMinMax);\n\n        let yMin: number;\n        let yMax: number;\n        if (normalizedTo && isFinite(normalizedTo)) {\n            yMin = yLargestMinMax.min < 0 ? -normalizedTo : 0;\n            yMax = normalizedTo;\n            yData.forEach((group, i) => {\n                group.forEach((stack, j) => {\n                    stack.forEach((y, k) => {\n                        if (y < 0) {\n                            stack[k] = -y / yMinMax[i][j].min * normalizedTo;\n                        } else {\n                            stack[k] = y / yMinMax[i][j].max * normalizedTo;\n                        }\n                    });\n                });\n            });\n        } else {\n            yMin = yLargestMinMax.min;\n            yMax = yLargestMinMax.max;\n        }\n\n        this.yDomain = this.fixNumericExtent([yMin, yMax], 'y');\n\n        this.fireEvent({ type: 'dataProcessed' });\n\n        return true;\n    }\n\n    findLargestMinMax(groups: { min: number, max: number }[][]): { min: number, max: number } {\n        let tallestStackMin = 0;\n        let tallestStackMax = 0;\n\n        for (const group of groups) {\n            for (const stack of group) {\n                if (stack.min < tallestStackMin) {\n                    tallestStackMin = stack.min;\n                }\n                if (stack.max > tallestStackMax) {\n                    tallestStackMax = stack.max;\n                }\n            }\n        }\n\n        return { min: tallestStackMin, max: tallestStackMax };\n    }\n\n    getDomain(direction: ChartAxisDirection): any[] {\n        if (this.flipXY) {\n            direction = flipChartAxisDirection(direction);\n        }\n        if (direction === ChartAxisDirection.X) {\n            return this.xData;\n        } else {\n            return this.yDomain;\n        }\n    }\n\n    fireNodeClickEvent(event: MouseEvent, datum: BarNodeDatum): void {\n        this.fireEvent<BarSeriesNodeClickEvent>({\n            type: 'nodeClick',\n            event,\n            series: this,\n            datum: datum.seriesDatum,\n            xKey: this.xKey,\n            yKey: datum.yKey\n        });\n    }\n\n    private generateNodeData(): BarNodeDatum[] {\n        const { flipXY } = this;\n        const xAxis = flipXY ? this.yAxis : this.xAxis;\n        const yAxis = flipXY ? this.xAxis : this.yAxis;\n\n        if (!this.data || !xAxis || !yAxis) {\n            return [];\n        }\n\n        const xScale = xAxis.scale;\n        const yScale = yAxis.scale;\n\n        const {\n            groupScale,\n            yKeys,\n            cumYKeyCount,\n            fills,\n            strokes,\n            strokeWidth,\n            seriesItemEnabled,\n            data,\n            xData,\n            yData,\n        } = this;\n\n        const label = this.label;\n        const labelFontStyle = label.fontStyle;\n        const labelFontWeight = label.fontWeight;\n        const labelFontSize = label.fontSize;\n        const labelFontFamily = label.fontFamily;\n        const labelColor = label.color;\n        const labelFormatter = label.formatter;\n\n        groupScale.range = [0, xScale.bandwidth!];\n\n        const grouped = true;\n        const barWidth = grouped ? groupScale.bandwidth : xScale.bandwidth!;\n        const nodeData: BarNodeDatum[] = [];\n\n        xData.forEach((group, groupIndex) => {\n            const seriesDatum = data[groupIndex];\n            const x = xScale.convert(group);\n\n            const groupYs = yData[groupIndex]; // y-data for groups of stacks\n            for (let stackIndex = 0; stackIndex < groupYs.length; stackIndex++) {\n                const stackYs = groupYs[stackIndex]; // y-data for a stack withing a group\n\n                let prevMinY = 0;\n                let prevMaxY = 0;\n\n                for (let levelIndex = 0; levelIndex < stackYs.length; levelIndex++) {\n                    const currY = stackYs[levelIndex];\n                    const yKey = yKeys[stackIndex][levelIndex];\n                    const barX = grouped ? x + groupScale.convert(String(stackIndex)) : x;\n\n                    // Bars outside of visible range are not rendered, so we generate node data\n                    // only for the visible subset of user data.\n                    if (!xAxis.inRange(barX, barWidth)) {\n                        continue;\n                    }\n\n                    const prevY = currY < 0 ? prevMinY : prevMaxY;\n                    const y = yScale.convert(prevY + currY);\n                    const bottomY = yScale.convert(prevY);\n                    const yValue = seriesDatum[yKey]; // unprocessed y-value\n                    const yValueIsNumber = typeof yValue === 'number';\n\n                    let labelText: string;\n\n                    if (labelFormatter) {\n                        labelText = labelFormatter({ value: yValueIsNumber ? yValue : undefined });\n                    } else {\n                        labelText = yValueIsNumber && isFinite(yValue) ? yValue.toFixed(2) : '';\n                    }\n\n                    const colorIndex = cumYKeyCount[stackIndex] + levelIndex;\n                    nodeData.push({\n                        series: this,\n                        seriesDatum,\n                        yValue,\n                        yKey,\n                        x: flipXY ? Math.min(y, bottomY) : barX,\n                        y: flipXY ? barX : Math.min(y, bottomY),\n                        width: flipXY ? Math.abs(bottomY - y) : barWidth,\n                        height: flipXY ? barWidth : Math.abs(bottomY - y),\n                        fill: fills[colorIndex % fills.length],\n                        stroke: strokes[colorIndex % strokes.length],\n                        strokeWidth,\n                        label: seriesItemEnabled.get(yKey) && labelText ? {\n                            text: labelText,\n                            fontStyle: labelFontStyle,\n                            fontWeight: labelFontWeight,\n                            fontSize: labelFontSize,\n                            fontFamily: labelFontFamily,\n                            fill: labelColor,\n                            x: flipXY ? y + (yValue >= 0 ? -1 : 1) * Math.abs(bottomY - y) / 2 : barX + barWidth / 2,\n                            y: flipXY ? barX + barWidth / 2 : y + (yValue >= 0 ? 1 : -1) * Math.abs(bottomY - y) / 2\n                        } : undefined\n                    });\n\n                    if (currY < 0) {\n                        prevMinY += currY;\n                    } else {\n                        prevMaxY += currY;\n                    }\n                }\n            }\n        });\n\n        return nodeData;\n    }\n\n    update(): void {\n        const { visible, chart, xAxis, yAxis, xData, yData } = this;\n\n        this.group.visible = visible;\n\n        if (!chart || chart.layoutPending || chart.dataPending ||\n            !xAxis || !yAxis || !visible || !xData.length || !yData.length) {\n            return;\n        }\n\n        const nodeData = this.generateNodeData();\n\n        this.updateRectSelection(nodeData);\n        this.updateRectNodes();\n\n        this.updateTextSelection(nodeData);\n        this.updateTextNodes();\n    }\n\n    private updateRectSelection(selectionData: BarNodeDatum[]): void {\n        const updateRects = this.rectSelection.setData(selectionData);\n        updateRects.exit.remove();\n        const enterRects = updateRects.enter.append(Rect).each(rect => {\n            rect.tag = BarSeriesNodeTag.Bar;\n            rect.crisp = true;\n        });\n        this.rectSelection = updateRects.merge(enterRects);\n    }\n\n    private updateRectNodes(): void {\n        if (!this.chart) {\n            return;\n        }\n\n        const {\n            fillOpacity, strokeOpacity,\n            highlightStyle: { fill, stroke },\n            shadow,\n            formatter,\n            xKey,\n            flipXY\n        } = this;\n        const { highlightedDatum } = this.chart;\n\n        this.rectSelection.each((rect, datum) => {\n            const highlighted = datum === highlightedDatum;\n            const rectFill = highlighted && fill !== undefined ? fill : datum.fill;\n            const rectStroke = highlighted && stroke !== undefined ? stroke : datum.stroke;\n            let format: BarSeriesFormat | undefined = undefined;\n\n            if (formatter) {\n                format = formatter({\n                    datum: datum.seriesDatum,\n                    fill: rectFill,\n                    stroke: rectStroke,\n                    strokeWidth: datum.strokeWidth,\n                    highlighted,\n                    xKey,\n                    yKey: datum.yKey\n                });\n            }\n            rect.x = datum.x;\n            rect.y = datum.y;\n            rect.width = datum.width;\n            rect.height = datum.height;\n            rect.fill = format && format.fill || rectFill;\n            rect.stroke = format && format.stroke || rectStroke;\n            rect.strokeWidth = format && format.strokeWidth !== undefined ? format.strokeWidth : datum.strokeWidth;\n            rect.fillOpacity = fillOpacity;\n            rect.strokeOpacity = strokeOpacity;\n            rect.lineDash = this.lineDash;\n            rect.lineDashOffset = this.lineDashOffset;\n            rect.fillShadow = shadow;\n            // Prevent stroke from rendering for zero height columns and zero width bars.\n            rect.visible = flipXY ? datum.width > 0 : datum.height > 0;\n        });\n    }\n\n    private updateTextSelection(selectionData: BarNodeDatum[]): void {\n        const updateTexts = this.textSelection.setData(selectionData);\n\n        updateTexts.exit.remove();\n\n        const enterTexts = updateTexts.enter.append(Text).each(text => {\n            text.tag = BarSeriesNodeTag.Label;\n            text.pointerEvents = PointerEvents.None;\n            text.textAlign = 'center';\n            text.textBaseline = 'middle';\n        });\n\n        this.textSelection = updateTexts.merge(enterTexts);\n    }\n\n    private updateTextNodes(): void {\n        const labelEnabled = this.label.enabled;\n\n        this.textSelection.each((text, datum) => {\n            const label = datum.label;\n\n            if (label && labelEnabled) {\n                text.fontStyle = label.fontStyle;\n                text.fontWeight = label.fontWeight;\n                text.fontSize = label.fontSize;\n                text.fontFamily = label.fontFamily;\n                text.text = label.text;\n                text.x = label.x;\n                text.y = label.y;\n                text.fill = label.fill;\n                text.visible = true;\n            } else {\n                text.visible = false;\n            }\n        });\n    }\n\n    getTooltipHtml(nodeDatum: BarNodeDatum): string {\n        const { xKey, yKeys } = this;\n        const { yKey } = nodeDatum;\n\n        if (!xKey || !yKey) {\n            return '';\n        }\n\n        let yKeyIndex = 0;\n        for (const stack of yKeys) {\n            const i = stack.indexOf(yKey);\n            if (i >= 0) {\n                yKeyIndex += i;\n                break;\n            }\n            yKeyIndex += stack.length;\n        }\n\n        const { xName, yNames, fills, tooltip } = this;\n        const { renderer: tooltipRenderer } = tooltip; // TODO: remove deprecated tooltipRenderer\n        const datum = nodeDatum.seriesDatum;\n        const yName = yNames[yKey];\n        const color = fills[yKeyIndex % fills.length];\n        const xValue = datum[xKey];\n        const yValue = datum[yKey];\n        const xString = typeof xValue === 'number' ? toFixed(xValue) : String(xValue);\n        const yString = typeof yValue === 'number' ? toFixed(yValue) : String(yValue);\n        const title = yName;\n        const content = xString + ': ' + yString;\n        const defaults: TooltipRendererResult = {\n            title,\n            backgroundColor: color,\n            content\n        };\n\n        if (tooltipRenderer) {\n            return toTooltipHtml(tooltipRenderer({\n                datum,\n                xKey,\n                xValue,\n                xName,\n                yKey,\n                yValue,\n                yName,\n                color\n            }), defaults);\n        }\n\n        return toTooltipHtml(defaults);\n    }\n\n    listSeriesItems(legendData: LegendDatum[]): void {\n        const {\n            id, data, xKey, yKeys, yNames, cumYKeyCount, seriesItemEnabled, hideInLegend,\n            fills, strokes, fillOpacity, strokeOpacity\n        } = this;\n\n        if (data && data.length && xKey && yKeys.length) {\n            this.yKeys.forEach((stack, stackIndex) => {\n                stack.forEach((yKey, levelIndex) => {\n                    if (hideInLegend.indexOf(yKey) < 0) {\n                        const colorIndex = cumYKeyCount[stackIndex] + levelIndex;\n                        legendData.push({\n                            id,\n                            itemId: yKey,\n                            enabled: seriesItemEnabled.get(yKey) || false,\n                            label: {\n                                text: yNames[yKey] || yKey\n                            },\n                            marker: {\n                                fill: fills[colorIndex % fills.length],\n                                stroke: strokes[colorIndex % strokes.length],\n                                fillOpacity: fillOpacity,\n                                strokeOpacity: strokeOpacity\n                            }\n                        });\n                    }\n                });\n            });\n        }\n    }\n\n    toggleSeriesItem(itemId: string, enabled: boolean): void {\n        const { seriesItemEnabled } = this;\n        seriesItemEnabled.set(itemId, enabled);\n\n        const yKeys = this.yKeys.map(stack => stack.slice()); // deep clone\n\n\n        seriesItemEnabled.forEach((enabled, yKey) => {\n            if (!enabled) {\n                yKeys.forEach(stack => {\n                    const index = stack.indexOf(yKey);\n                    if (index >= 0) {\n                        stack.splice(index, 1);\n                    }\n                });\n            }\n        });\n\n        const visibleStacks: string[] = [];\n        yKeys.forEach((stack, index) => {\n            if (stack.length > 0) {\n                visibleStacks.push(String(index));\n            }\n        });\n        this.groupScale.domain = visibleStacks;\n\n        this.scheduleData();\n    }\n}\n","/Users/vitaliikravchenko/Sites/nova/client/src/charts/chart/series/cartesian/lineSeries.ts",["541","542","543","544"],"import { Path } from \"../../../scene/shape/path\";\nimport ContinuousScale from \"../../../scale/continuousScale\";\nimport { Selection } from \"../../../scene/selection\";\nimport { Group } from \"../../../scene/group\";\nimport {\n    SeriesNodeDatum,\n    CartesianTooltipRendererParams,\n    HighlightStyle, SeriesTooltip\n} from \"../series\";\nimport { numericExtent } from \"../../../util/array\";\nimport { toFixed } from \"../../../util/number\";\nimport { PointerEvents } from \"../../../scene/node\";\nimport { LegendDatum } from \"../../legend\";\nimport { CartesianSeries, CartesianSeriesMarker, CartesianSeriesMarkerFormat } from \"./cartesianSeries\";\nimport { ChartAxisDirection } from \"../../chartAxis\";\nimport { getMarker } from \"../../marker/util\";\nimport { reactive, PropertyChangeEvent, TypedEvent } from \"../../../util/observable\";\nimport { TooltipRendererResult, toTooltipHtml } from \"../../chart\";\nimport Scale from \"../../../scale/scale\";\nimport { interpolate } from \"../../../util/string\";\n\ninterface LineNodeDatum extends SeriesNodeDatum {\n    readonly point: {\n        readonly x: number;\n        readonly y: number;\n    }\n}\n\nexport interface LineSeriesNodeClickEvent extends TypedEvent {\n    readonly type: 'nodeClick';\n    readonly event: MouseEvent;\n    readonly series: LineSeries;\n    readonly datum: any;\n    readonly xKey: string;\n    readonly yKey: string;\n}\n\nexport class LineSeriesTooltip extends SeriesTooltip {\n    @reactive('change') renderer?: (params: CartesianTooltipRendererParams) => string | TooltipRendererResult;\n    @reactive('change') format?: string;\n}\n\nexport class LineSeries extends CartesianSeries {\n\n    static className = 'LineSeries';\n    static type = 'line';\n\n    private xDomain: any[] = [];\n    private yDomain: any[] = [];\n    private xData: any[] = [];\n    private yData: any[] = [];\n\n    private lineNode = new Path();\n\n    // We use groups for this selection even though each group only contains a marker ATM\n    // because in the future we might want to add label support as well.\n    private nodeSelection: Selection<Group, Group, LineNodeDatum, any> = Selection.select(this.group).selectAll<Group>();\n    private nodeData: LineNodeDatum[] = [];\n\n    readonly marker = new CartesianSeriesMarker();\n\n    @reactive('layoutChange') title?: string;\n\n    @reactive('update') stroke?: string = '#874349';\n    @reactive('update') lineDash?: number[] = undefined;\n    @reactive('update') lineDashOffset: number = 0;\n    @reactive('update') strokeWidth: number = 2;\n    @reactive('update') strokeOpacity: number = 1;\n\n    tooltip: LineSeriesTooltip = new LineSeriesTooltip();\n\n    constructor() {\n        super();\n\n        const lineNode = this.lineNode;\n        lineNode.fill = undefined;\n        lineNode.lineJoin = 'round';\n        lineNode.pointerEvents = PointerEvents.None;\n        this.group.append(lineNode);\n\n        this.addEventListener('update', this.update);\n\n        const { marker } = this;\n        marker.fill = '#c16068';\n        marker.stroke = '#874349';\n        marker.addPropertyListener('shape', this.onMarkerShapeChange, this);\n        marker.addPropertyListener('enabled', this.onMarkerEnabledChange, this);\n        marker.addEventListener('change', this.update, this);\n    }\n\n    onMarkerShapeChange() {\n        this.nodeSelection = this.nodeSelection.setData([]);\n        this.nodeSelection.exit.remove();\n        this.update();\n\n        this.fireEvent({ type: 'legendChange' });\n    }\n\n    protected onMarkerEnabledChange(event: PropertyChangeEvent<CartesianSeriesMarker, boolean>) {\n        if (!event.value) {\n            this.nodeSelection = this.nodeSelection.setData([]);\n            this.nodeSelection.exit.remove();\n        }\n    }\n\n    setColors(fills: string[], strokes: string[]) {\n        this.stroke = fills[0];\n        this.marker.stroke = strokes[0];\n        this.marker.fill = fills[0];\n    }\n\n    protected _xKey: string = '';\n    set xKey(value: string) {\n        if (this._xKey !== value) {\n            this._xKey = value;\n            this.xData = [];\n            this.scheduleData();\n        }\n    }\n\n    get xKey(): string {\n        return this._xKey;\n    }\n\n    @reactive('update') xName: string = '';\n\n    protected _yKey: string = '';\n    set yKey(value: string) {\n        if (this._yKey !== value) {\n            this._yKey = value;\n            this.yData = [];\n            this.scheduleData();\n        }\n    }\n\n    get yKey(): string {\n        return this._yKey;\n    }\n\n    @reactive('update') yName: string = '';\n\n    processData(): boolean {\n        const { xAxis, yAxis, xKey, yKey, xData, yData } = this;\n        const data = xKey && yKey && this.data ? this.data : [];\n\n        if (!xAxis || !yAxis) {\n            return false;\n        }\n\n        const isContinuousX = xAxis.scale instanceof ContinuousScale;\n        const isContinuousY = yAxis.scale instanceof ContinuousScale;\n\n        xData.length = 0;\n        yData.length = 0;\n\n        for (let i = 0, n = data.length; i < n; i++) {\n            const datum = data[i];\n            const x = datum[xKey];\n            const y = datum[yKey];\n\n            xData.push(x);\n            yData.push(y);\n        }\n\n        this.xDomain = isContinuousX ? this.fixNumericExtent(numericExtent(xData), 'x') : xData;\n        this.yDomain = isContinuousY ? this.fixNumericExtent(numericExtent(yData), 'y') : yData;\n\n        return true;\n    }\n\n    getDomain(direction: ChartAxisDirection): any[] {\n        if (direction === ChartAxisDirection.X) {\n            return this.xDomain;\n        }\n        return this.yDomain;\n    }\n\n    highlightStyle: HighlightStyle = { fill: 'yellow' };\n\n    onHighlightChange() {\n        this.updateNodes();\n    }\n\n    update(): void {\n        this.group.visible = this.visible;\n\n        const { chart, xAxis, yAxis } = this;\n\n        if (!chart || chart.layoutPending || chart.dataPending || !xAxis || !yAxis) {\n            return;\n        }\n\n        this.updateLinePath(); // this will generate node data too\n        this.updateNodeSelection();\n        this.updateNodes();\n    }\n\n    private getXYDatums(i: number, xData: number[], yData: number[],\n                      xScale: Scale<any, any>, yScale: Scale<any, any>): [number, number] | undefined {\n        const isContinuousX = xScale instanceof ContinuousScale;\n        const isContinuousY = yScale instanceof ContinuousScale;\n        const xDatum = xData[i];\n        const yDatum = yData[i];\n        const noDatum =\n            yDatum == null || (isContinuousY && (isNaN(yDatum) || !isFinite(yDatum))) ||\n            xDatum == null || (isContinuousX && (isNaN(xDatum) || !isFinite(xDatum)));\n        return noDatum ? undefined : [xDatum, yDatum];\n    }\n\n    private updateLinePath() {\n        const { xAxis, yAxis } = this;\n\n        if (!this.data || !xAxis || !yAxis) {\n            return;\n        }\n\n        const { data, xData, yData, lineNode } = this;\n        const xScale = xAxis.scale;\n        const yScale = yAxis.scale;\n        const xOffset = (xScale.bandwidth || 0) / 2;\n        const yOffset = (yScale.bandwidth || 0) / 2;\n        const linePath = lineNode.path;\n        const nodeData: LineNodeDatum[] = [];\n\n        linePath.clear();\n        let moveTo = true;\n        let prevXInRange: undefined | -1 | 0 | 1 = undefined;\n        let nextXYDatums: [number, number] | undefined = undefined;\n        for (let i = 0; i < xData.length; i++) {\n            const xyDatums = nextXYDatums || this.getXYDatums(i, xData, yData, xScale, yScale);\n\n            if (!xyDatums) {\n                prevXInRange = undefined;\n                moveTo = true;\n            } else {\n                const [xDatum, yDatum] = xyDatums;\n                const x = xScale.convert(xDatum) + xOffset;\n                const tolerance = (xScale.bandwidth || (this.marker.size * 0.5 + (this.marker.strokeWidth || 0))) + 1;\n\n                nextXYDatums = this.getXYDatums(i + 1, xData, yData, xScale, yScale);\n                const xInRange = xAxis.inRangeEx(x, 0, tolerance);\n                const nextXInRange = nextXYDatums && xAxis.inRangeEx(xScale.convert(nextXYDatums[0]) + xOffset, 0, tolerance);\n                if (xInRange === -1 && nextXInRange === -1) {\n                    moveTo = true;\n                    continue;\n                }\n                if (xInRange === 1 && prevXInRange === 1) {\n                    moveTo = true;\n                    continue;\n                }\n                prevXInRange = xInRange;\n\n                const y = yScale.convert(yDatum) + yOffset;\n\n                if (moveTo) {\n                    linePath.moveTo(x, y);\n                    moveTo = false;\n                } else {\n                    linePath.lineTo(x, y);\n                }\n\n                nodeData.push({\n                    series: this,\n                    seriesDatum: data[i],\n                    point: { x, y }\n                });\n            }\n        }\n\n        lineNode.stroke = this.stroke;\n        lineNode.strokeWidth = this.strokeWidth;\n        lineNode.lineDash = this.lineDash;\n        lineNode.lineDashOffset = this.lineDashOffset;\n        lineNode.strokeOpacity = this.strokeOpacity;\n\n        // Used by marker nodes and for hit-testing even when not using markers\n        // when `chart.tooltipTracking` is true.\n        this.nodeData = nodeData;\n    }\n\n    private updateNodeSelection() {\n        const { marker } = this;\n        const nodeData = marker.shape ? this.nodeData : [];\n        const MarkerShape = getMarker(marker.shape);\n        const updateSelection = this.nodeSelection.setData(nodeData);\n        updateSelection.exit.remove();\n        const enterSelection = updateSelection.enter.append(Group);\n        enterSelection.append(MarkerShape);\n        this.nodeSelection = updateSelection.merge(enterSelection);\n    }\n\n    private updateNodes() {\n        if (!this.chart) {\n            return;\n        }\n\n        const { marker, xKey, yKey, stroke, strokeWidth } = this;\n        const MarkerShape = getMarker(marker.shape);\n        const { highlightedDatum } = this.chart;\n\n        const { fill: highlightFill, stroke: highlightStroke } = this.highlightStyle;\n        const markerFormatter = marker.formatter;\n        const markerSize = marker.size;\n        const markerStrokeWidth = marker.strokeWidth !== undefined ? marker.strokeWidth : strokeWidth;\n\n        this.nodeSelection.selectByClass(MarkerShape)\n            .each((node, datum) => {\n                const highlighted = datum === highlightedDatum;\n                const markerFill = highlighted && highlightFill !== undefined ? highlightFill : marker.fill;\n                const markerStroke = highlighted && highlightStroke !== undefined ? highlightStroke : marker.stroke || stroke;\n                let markerFormat: CartesianSeriesMarkerFormat | undefined = undefined;\n\n                if (markerFormatter) {\n                    markerFormat = markerFormatter({\n                        datum: datum.seriesDatum,\n                        xKey,\n                        yKey,\n                        fill: markerFill,\n                        stroke: markerStroke,\n                        strokeWidth: markerStrokeWidth,\n                        size: markerSize,\n                        highlighted\n                    });\n                }\n\n                node.fill = markerFormat && markerFormat.fill || markerFill;\n                node.stroke = markerFormat && markerFormat.stroke || markerStroke;\n                node.strokeWidth = markerFormat && markerFormat.strokeWidth !== undefined\n                    ? markerFormat.strokeWidth\n                    : markerStrokeWidth;\n                node.size = markerFormat && markerFormat.size !== undefined\n                    ? markerFormat.size\n                    : markerSize;\n\n                node.translationX = datum.point.x;\n                node.translationY = datum.point.y;\n                node.visible = marker.enabled && node.size > 0;\n            });\n    }\n\n    getNodeData(): LineNodeDatum[] {\n        return this.nodeData;\n    }\n\n    fireNodeClickEvent(event: MouseEvent, datum: LineNodeDatum): void {\n        this.fireEvent<LineSeriesNodeClickEvent>({\n            type: 'nodeClick',\n            event,\n            series: this,\n            datum: datum.seriesDatum,\n            xKey: this.xKey,\n            yKey: this.yKey\n        });\n    }\n\n    getTooltipHtml(nodeDatum: LineNodeDatum): string {\n        const { xKey, yKey } = this;\n\n        if (!xKey || !yKey) {\n            return '';\n        }\n\n        const { xName, yName, stroke: color, tooltip } = this;\n        const {\n            renderer: tooltipRenderer,\n            format: tooltipFormat\n        } = tooltip;\n        const datum = nodeDatum.seriesDatum;\n        const xValue = datum[xKey];\n        const yValue = datum[yKey];\n        const xString = typeof xValue === 'number' ? toFixed(xValue) : String(xValue);\n        const yString = typeof yValue === 'number' ? toFixed(yValue) : String(yValue);\n        const title = this.title || yName;\n        const content = xString + ': ' + yString;\n        const defaults: TooltipRendererResult = {\n            title,\n            backgroundColor: color,\n            content\n        };\n\n        if (tooltipFormat || tooltipRenderer) {\n            const params = {\n                datum,\n                xKey,\n                xValue,\n                xName,\n                yKey,\n                yValue,\n                yName,\n                title,\n                color\n            };\n            if (tooltipFormat) {\n                return toTooltipHtml({\n                    content: interpolate(tooltipFormat, params)\n                }, defaults);\n            }\n            if (tooltipRenderer) {\n                return toTooltipHtml(tooltipRenderer(params), defaults);\n            }\n        }\n\n        return toTooltipHtml(defaults);\n    }\n\n    listSeriesItems(legendData: LegendDatum[]): void {\n        const {\n            id, data, xKey, yKey, yName, visible,\n            title, marker, stroke, strokeOpacity\n        } = this;\n\n        if (data && data.length && xKey && yKey) {\n            legendData.push({\n                id: id,\n                itemId: undefined,\n                enabled: visible,\n                label: {\n                    text: title || yName || yKey\n                },\n                marker: {\n                    shape: marker.shape,\n                    fill: marker.fill || 'rgba(0, 0, 0, 0)',\n                    stroke: marker.stroke || stroke || 'rgba(0, 0, 0, 0)',\n                    fillOpacity: 1,\n                    strokeOpacity\n                }\n            });\n        }\n    }\n}\n","/Users/vitaliikravchenko/Sites/nova/client/src/charts/chart/axis/groupedCategoryAxis.ts",["545","546","547","548"],"import { Group } from \"../../scene/group\";\nimport { Selection } from \"../../scene/selection\";\nimport { Line } from \"../../scene/shape/line\";\nimport { normalizeAngle360, toRadians } from \"../../util/angle\";\nimport { Text } from \"../../scene/shape/text\";\nimport { BBox } from \"../../scene/bbox\";\nimport { Matrix } from \"../../scene/matrix\";\n// import { Rect } from \"../../scene/shape/rect\"; debug (bbox)\nimport { BandScale } from \"../../scale/bandScale\";\nimport { ticksToTree, TreeLayout, treeLayout } from \"../../layout/tree\";\nimport { AxisLabel } from \"../../axis\";\nimport { ChartAxis } from \"../chartAxis\";\nimport { createId } from \"../../util/id\";\n\nclass GroupedCategoryAxisLabel extends AxisLabel {\n    grid: boolean = false;\n}\n\n/**\n * A general purpose linear axis with no notion of orientation.\n * The axis is always rendered vertically, with horizontal labels positioned to the left\n * of the axis line by default. The axis can be {@link rotation | rotated} by an arbitrary angle,\n * so that it can be used as a top, right, bottom, left, radial or any other kind\n * of linear axis.\n * The generic `D` parameter is the type of the domain of the axis' scale.\n * The output range of the axis' scale is always numeric (screen coordinates).\n */\nexport class GroupedCategoryAxis extends ChartAxis {\n    // debug (bbox)\n    // private bboxRect = (() => {\n    //     const rect = new Rect();\n    //     rect.fill = undefined;\n    //     rect.stroke = 'red';\n    //     rect.strokeWidth = 1;\n    //     rect.strokeOpacity = 0.7;\n    //     return rect;\n    // })();\n\n    static className = 'GroupedCategoryAxis';\n    static type = 'groupedCategory';\n\n    readonly id = createId(this);\n    // Label scale (labels are positionsed between ticks, tick count = label count + 1).\n    // We don't call is `labelScale` for consistency with other axes.\n    readonly scale!: BandScale<string | number>;\n    readonly tickScale = new BandScale<string | number>();\n    readonly group = new Group();\n\n    private gridLineSelection: Selection<Line, Group, any, any>;\n    private axisLineSelection: Selection<Line, Group, any, any>;\n    private separatorSelection: Selection<Line, Group, any, any>;\n    private labelSelection: Selection<Text, Group, any, any>;\n    private tickTreeLayout?: TreeLayout;\n    private longestSeparatorLength = 0;\n\n    constructor() {\n        super(new BandScale<string | number>());\n\n        const { group, scale, tickScale } = this;\n\n        scale.paddingOuter = 0.1;\n        scale.paddingInner = scale.paddingOuter * 2;\n        this.requestedRange = scale.range.slice();\n\n        tickScale.paddingInner = 1;\n        tickScale.paddingOuter = 0;\n\n\n        this.gridLineSelection = Selection.select(group).selectAll<Line>();\n        this.axisLineSelection = Selection.select(group).selectAll<Line>();\n        this.separatorSelection = Selection.select(group).selectAll<Line>();\n        this.labelSelection = Selection.select(group).selectAll<Text>();\n        // this.group.append(this.bboxRect); // debug (bbox)\n    }\n\n    set domain(value: any[]) {\n        this.scale.domain = value;\n        const tickTree = ticksToTree(value);\n        this.tickTreeLayout = treeLayout(tickTree);\n\n        const domain = value.slice();\n        domain.push('');\n        this.tickScale.domain = domain;\n\n        this.resizeTickTree();\n    }\n    get domain(): any[] {\n        return this.scale.domain;\n    }\n\n    set range(value: number[]) {\n        this.requestedRange = value.slice();\n        this.updateRange();\n    }\n    get range(): number[] {\n        return this.requestedRange.slice();\n    }\n\n    protected updateRange() {\n        const { requestedRange: rr, visibleRange: vr, scale } = this;\n        const span = (rr[1] - rr[0]) / (vr[1] - vr[0]);\n        const shift = span * vr[0];\n        const start = rr[0] - shift;\n\n        this.tickScale.range = scale.range = [start, start + span];\n        this.resizeTickTree();\n    }\n\n    private resizeTickTree() {\n        const s = this.scale;\n        const range = s.domain.length ? [s.convert(s.domain[0]), s.convert(s.domain[s.domain.length - 1])] : s.range;\n        const layout = this.tickTreeLayout;\n        const lineHeight = this.lineHeight;\n\n        if (layout) {\n            layout.resize(\n                Math.abs(range[1] - range[0]),\n                layout.depth * lineHeight,\n                (Math.min(range[0], range[1]) || 0) + (s.bandwidth || 0) / 2,\n                -layout.depth * lineHeight,\n                (range[1] - range[0]) < 0\n            );\n        }\n    }\n\n    readonly translation: {\n        /**\n         * The horizontal translation of the axis group.\n         */\n        x: number,\n        /**\n         * The vertical translation of the axis group.\n         */\n        y: number\n    } = {\n            x: 0,\n            y: 0\n        };\n\n    /**\n     * Axis rotation angle in degrees.\n     */\n    rotation: number = 0;\n\n    readonly line: {\n        /**\n         * The line width to be used by the axis line.\n         */\n        width: number,\n        /**\n         * The color of the axis line.\n         * Use `undefined` rather than `rgba(0, 0, 0, 0)` to make the axis line invisible.\n         */\n        color?: string\n    } = {\n            width: 1,\n            color: 'rgba(195, 195, 195, 1)'\n        };\n\n    // readonly tick = new AxisTick();\n\n    readonly label = new GroupedCategoryAxisLabel();\n\n    private get lineHeight() {\n        return this.label.fontSize * 1.5;\n    }\n\n    /**\n     * The color of the labels.\n     * Use `undefined` rather than `rgba(0, 0, 0, 0)` to make labels invisible.\n     */\n    labelColor?: string = 'rgba(87, 87, 87, 1)';\n\n    /**\n     * The length of the grid. The grid is only visible in case of a non-zero value.\n     */\n    set gridLength(value: number) {\n        // Was visible and now invisible, or was invisible and now visible.\n        if (this._gridLength && !value || !this._gridLength && value) {\n            this.gridLineSelection = this.gridLineSelection.remove().setData([]);\n            this.labelSelection = this.labelSelection.remove().setData([]);\n        }\n        this._gridLength = value;\n    }\n    get gridLength(): number {\n        return this._gridLength;\n    }\n\n    /**\n     * Creates/removes/updates the scene graph nodes that constitute the axis.\n     * Supposed to be called _manually_ after changing _any_ of the axis properties.\n     * This allows to bulk set axis properties before updating the nodes.\n     * The node changes made by this method are rendered on the next animation frame.\n     * We could schedule this method call automatically on the next animation frame\n     * when any of the axis properties change (the way we do when properties of scene graph's\n     * nodes change), but this will mean that we first wait for the next animation\n     * frame to make changes to the nodes of the axis, then wait for another animation\n     * frame to render those changes. It's nice to have everything update automatically,\n     * but this extra level of async indirection will not just introduce an unwanted delay,\n     * it will also make it harder to reason about the program.\n     */\n    update() {\n        const { group, scale, label, tickScale, requestedRange } = this;\n        const rangeStart = scale.range[0];\n        const rangeEnd = scale.range[1];\n        const rangeLength = Math.abs(rangeEnd - rangeStart);\n        const bandwidth = (rangeLength / scale.domain.length) || 0;\n        const parallelLabels = label.parallel;\n        const rotation = toRadians(this.rotation);\n        const isHorizontal = Math.abs(Math.cos(rotation)) < 1e-8;\n        const labelRotation = normalizeAngle360(toRadians(this.label.rotation));\n\n        group.translationX = this.translation.x;\n        group.translationY = this.translation.y;\n        group.rotation = rotation;\n\n        const title = this.title;\n        // The Text `node` of the Caption is not used to render the title of the grouped category axis.\n        // The phantom root of the tree layout is used instead.\n        if (title) {\n            title.node.visible = false;\n        }\n        const lineHeight = this.lineHeight;\n\n        // Render ticks and labels.\n        const tickTreeLayout = this.tickTreeLayout;\n        const labels = scale.ticks();\n        const treeLabels = tickTreeLayout ? tickTreeLayout.nodes : [];\n        const isLabelTree = tickTreeLayout ? tickTreeLayout.depth > 1 : false;\n        const ticks = tickScale.ticks();\n        // The side of the axis line to position the labels on.\n        // -1 = left (default)\n        //  1 = right\n        const sideFlag = label.mirrored ? 1 : -1;\n        // When labels are parallel to the axis line, the `parallelFlipFlag` is used to\n        // flip the labels to avoid upside-down text, when the axis is rotated\n        // such that it is in the right hemisphere, i.e. the angle of rotation\n        // is in the [0, ] interval.\n        // The rotation angle is normalized, so that we have an easier time checking\n        // if it's in the said interval. Since the axis is always rendered vertically\n        // and then rotated, zero rotation means 12 (not 3) o-clock.\n        // -1 = flip\n        //  1 = don't flip (default)\n        const parallelFlipRotation = normalizeAngle360(rotation);\n        const parallelFlipFlag = (!labelRotation && parallelFlipRotation >= 0 && parallelFlipRotation <= Math.PI) ? -1 : 1;\n\n        const regularFlipRotation = normalizeAngle360(rotation - Math.PI / 2);\n        // Flip if the axis rotation angle is in the top hemisphere.\n        const regularFlipFlag = (!labelRotation && regularFlipRotation >= 0 && regularFlipRotation <= Math.PI) ? -1 : 1;\n\n        const updateGridLines = this.gridLineSelection.setData(this.gridLength ? ticks : []);\n        updateGridLines.exit.remove();\n        const enterGridLines = updateGridLines.enter.append(Line);\n        const gridLineSelection = updateGridLines.merge(enterGridLines);\n\n        const updateLabels = this.labelSelection.setData(treeLabels);\n        updateLabels.exit.remove();\n\n        const enterLabels = updateLabels.enter.append(Text);\n        const labelSelection = updateLabels.merge(enterLabels);\n\n        const labelFormatter = label.formatter;\n        let maxLeafLabelWidth = 0;\n        labelSelection\n            .each((node, datum, index) => {\n                node.fontStyle = label.fontStyle;\n                node.fontWeight = label.fontWeight;\n                node.fontSize = label.fontSize;\n                node.fontFamily = label.fontFamily;\n                node.fill = label.color;\n                node.textBaseline = parallelFlipFlag === -1 ? 'bottom' : 'hanging';\n                // label.textBaseline = parallelLabels && !labelRotation\n                //     ? (sideFlag * parallelFlipFlag === -1 ? 'hanging' : 'bottom')\n                //     : 'middle';\n                node.textAlign = 'center';\n                node.translationX = datum.screenY - label.fontSize * 0.25;\n                node.translationY = datum.screenX;\n                if (index === 0) { // use the phantom root as the axis title\n                    if (title && title.enabled && labels.length > 0) {\n                        node.visible = true;\n                        node.text = title.text;\n                        node.fontSize = title.fontSize;\n                        node.fontStyle = title.fontStyle;\n                        node.fontWeight = title.fontWeight;\n                        node.fontFamily = title.fontFamily;\n                        node.textBaseline = 'hanging';\n                    } else {\n                        node.visible = false;\n                    }\n                } else {\n                    node.text = labelFormatter\n                        ? labelFormatter({\n                            value: String(datum.label),\n                            index\n                        })\n                        : String(datum.label);\n                    node.visible =\n                        datum.screenX >= requestedRange[0] &&\n                        datum.screenX <= requestedRange[1];\n                }\n                const bbox = node.computeBBox();\n                if (bbox && bbox.width > maxLeafLabelWidth) {\n                    maxLeafLabelWidth = bbox.width;\n                }\n            });\n\n        const labelX = sideFlag * label.padding;\n        const autoRotation = parallelLabels\n            ? parallelFlipFlag * Math.PI / 2\n            : (regularFlipFlag === -1 ? Math.PI : 0);\n\n        const labelGrid = this.label.grid;\n        const separatorData = [] as { y: number, x1: number, x2: number, toString: () => string }[];\n        labelSelection.each((label, datum, index) => {\n            label.x = labelX;\n            label.rotationCenterX = labelX;\n            if (!datum.children.length) {\n                label.rotation = labelRotation;\n                label.textAlign = 'end';\n                label.textBaseline = 'middle';\n            } else {\n                label.translationX -= maxLeafLabelWidth - lineHeight + this.label.padding;\n                if (isHorizontal) {\n                    label.rotation = autoRotation;\n                } else {\n                    label.rotation = -Math.PI / 2;\n                }\n            }\n            // Calculate positions of label separators for all nodes except the root.\n            // Each separator is placed to the top of the current label.\n            if (datum.parent && isLabelTree) {\n                let y = !datum.children.length\n                    ? datum.screenX - bandwidth / 2\n                    : datum.screenX - datum.leafCount * bandwidth / 2;\n\n                if (!datum.children.length) {\n                    if ((datum.number !== datum.children.length - 1) || labelGrid) {\n                        separatorData.push({\n                            y,\n                            x1: 0,\n                            x2: -maxLeafLabelWidth - this.label.padding * 2,\n                            toString: () => String(index)\n                        });\n                    }\n                } else {\n                    const x = -maxLeafLabelWidth - this.label.padding * 2 + datum.screenY;\n                    separatorData.push({\n                        y,\n                        x1: x + lineHeight,\n                        x2: x,\n                        toString: () => String(index)\n                    });\n                }\n            }\n        });\n\n        // Calculate the position of the long separator on the far bottom of the axis.\n        let minX = 0;\n        separatorData.forEach(d => minX = Math.min(minX, d.x2));\n        this.longestSeparatorLength = Math.abs(minX);\n        separatorData.push({\n            y: Math.max(rangeStart, rangeEnd),\n            x1: 0,\n            x2: minX,\n            toString: () => String(separatorData.length)\n        });\n\n        const updateSeparators = this.separatorSelection.setData(separatorData);\n        updateSeparators.exit.remove();\n        const enterSeparators = updateSeparators.enter.append(Line);\n        const separatorSelection = updateSeparators.merge(enterSeparators);\n        this.separatorSelection = separatorSelection;\n\n        const epsilon = 0.0000001;\n        separatorSelection.each((line, datum, i) => {\n            line.x1 = datum.x1;\n            line.x2 = datum.x2;\n            line.y1 = datum.y;\n            line.y2 = datum.y;\n            line.visible = datum.y >= requestedRange[0] - epsilon && datum.y <= requestedRange[1] + epsilon;\n            line.stroke = this.tick.color;\n            line.fill = undefined;\n            line.strokeWidth = 1;\n        });\n\n        this.gridLineSelection = gridLineSelection;\n        this.labelSelection = labelSelection;\n\n        // Render axis lines.\n        const lineCount = tickTreeLayout ? tickTreeLayout.depth + 1 : 1;\n        const lines = [];\n        for (let i = 0; i < lineCount; i++) {\n            lines.push(i);\n        }\n\n        const updateAxisLines = this.axisLineSelection.setData(lines);\n        updateAxisLines.exit.remove();\n        const enterAxisLines = updateAxisLines.enter.append(Line);\n        const axisLineSelection = updateAxisLines.merge(enterAxisLines);\n        this.axisLineSelection = axisLineSelection;\n\n        axisLineSelection.each((line, _, index) => {\n            const x = index > 0 ? -maxLeafLabelWidth - this.label.padding * 2 - (index - 1) * lineHeight : 0;\n            line.x1 = x;\n            line.x2 = x;\n            line.y1 = requestedRange[0];\n            line.y2 = requestedRange[1];\n            line.strokeWidth = this.line.width;\n            line.stroke = this.line.color;\n            line.visible = labels.length > 0 && (index === 0 || (labelGrid && isLabelTree));\n        });\n\n        if (this.gridLength) {\n            const styles = this.gridStyle;\n            const styleCount = styles.length;\n\n            gridLineSelection\n                .each((line, datum, index) => {\n                    const y = Math.round(tickScale.convert(datum));\n                    line.x1 = 0;\n                    line.x2 = -sideFlag * this.gridLength;\n                    line.y1 = y;\n                    line.y2 = y;\n                    line.visible = y >= requestedRange[0] && y <= requestedRange[1] &&\n                        Math.abs(line.parent!.translationY - rangeStart) > 1;\n\n                    const style = styles[index % styleCount];\n                    line.stroke = style.stroke;\n                    line.strokeWidth = this.tick.width;\n                    line.lineDash = style.lineDash;\n                    line.fill = undefined;\n                });\n        }\n\n        // debug (bbox)\n        // const bbox = this.computeBBox();\n        // const bboxRect = this.bboxRect;\n        // bboxRect.x = bbox.x;\n        // bboxRect.y = bbox.y;\n        // bboxRect.width = bbox.width;\n        // bboxRect.height = bbox.height;\n    }\n\n    computeBBox(options?: { excludeTitle: boolean }): BBox {\n        const includeTitle = !options || !options.excludeTitle;\n        let left = Infinity;\n        let right = -Infinity;\n        let top = Infinity;\n        let bottom = -Infinity;\n\n        this.labelSelection.each((label, _, index) => {\n            // The label itself is rotated, but not translated, the group that\n            // contains it is. So to capture the group transform in the label bbox\n            // calculation we combine the transform matrices of the label and the group.\n            // Depending on the timing of the `axis.computeBBox()` method call, we may\n            // not have the group's and the label's transform matrices updated yet (because\n            // the transform matrix is not recalculated whenever a node's transform attributes\n            // change, instead it's marked for recalculation on the next frame by setting\n            // the node's `dirtyTransform` flag to `true`), so we force them to update\n            // right here by calling `computeTransformMatrix`.\n            if (index > 0 || includeTitle) { // first node is the root (title)\n                label.computeTransformMatrix();\n                const matrix = Matrix.flyweight(label.matrix);\n                const labelBBox = label.computeBBox();\n\n                if (labelBBox) {\n                    const bbox = matrix.transformBBox(labelBBox);\n\n                    left = Math.min(left, bbox.x);\n                    right = Math.max(right, bbox.x + bbox.width);\n                    top = Math.min(top, bbox.y);\n                    bottom = Math.max(bottom, bbox.y + bbox.height);\n                }\n            }\n        });\n\n        return new BBox(\n            left,\n            top,\n            Math.max(right - left, this.longestSeparatorLength),\n            bottom - top\n        );\n    }\n}\n","/Users/vitaliikravchenko/Sites/nova/client/src/charts/chart/series/polar/pieSeries.ts",["549","550","551","552","553","554","555"],"import { Group } from \"../../../scene/group\";\nimport { Line } from \"../../../scene/shape/line\";\nimport { Text } from \"../../../scene/shape/text\";\nimport { Selection } from \"../../../scene/selection\";\nimport { DropShadow } from \"../../../scene/dropShadow\";\nimport { LinearScale } from \"../../../scale/linearScale\";\nimport { Sector } from \"../../../scene/shape/sector\";\nimport { PolarTooltipRendererParams, SeriesNodeDatum, HighlightStyle, SeriesTooltip } from \"./../series\";\nimport { Label } from \"../../label\";\nimport { PointerEvents } from \"../../../scene/node\";\nimport { normalizeAngle180, toRadians } from \"../../../util/angle\";\nimport { Color } from \"../../../util/color\";\nimport { toFixed } from \"../../../util/number\";\nimport { LegendDatum } from \"../../legend\";\nimport { Caption } from \"../../../caption\";\nimport { reactive, Observable, TypedEvent } from \"../../../util/observable\";\nimport { PolarSeries } from \"./polarSeries\";\nimport { ChartAxisDirection } from \"../../chartAxis\";\nimport { TooltipRendererResult, toTooltipHtml } from \"../../chart\";\n\nexport interface PieSeriesNodeClickEvent extends TypedEvent {\n    readonly type: 'nodeClick';\n    readonly event: MouseEvent;\n    readonly series: PieSeries;\n    readonly datum: any;\n    readonly angleKey: string;\n    readonly labelKey?: string;\n    readonly radiusKey?: string;\n}\n\ninterface PieNodeDatum extends SeriesNodeDatum {\n    readonly index: number;\n    readonly radius: number; // in the [0, 1] range\n    readonly startAngle: number;\n    readonly endAngle: number;\n    readonly midAngle: number;\n    readonly midCos: number;\n    readonly midSin: number;\n\n    readonly label?: {\n        readonly text: string;\n        readonly textAlign: CanvasTextAlign;\n        readonly textBaseline: CanvasTextBaseline;\n    };\n}\n\nexport interface PieTooltipRendererParams extends PolarTooltipRendererParams {\n    readonly labelKey?: string;\n    readonly labelName?: string;\n}\n\ninterface PieHighlightStyle extends HighlightStyle {\n    centerOffset?: number;\n}\n\nenum PieNodeTag {\n    Sector,\n    Callout,\n    Label\n}\n\nexport interface PieSeriesFormatterParams {\n    readonly datum: any;\n    readonly fill?: string;\n    readonly stroke?: string;\n    readonly strokeWidth: number;\n    readonly highlighted: boolean;\n    readonly angleKey: string;\n    readonly radiusKey?: string;\n}\n\nexport interface PieSeriesFormat {\n    fill?: string;\n    stroke?: string;\n    strokeWidth?: number;\n}\n\nclass PieSeriesLabel extends Label {\n    @reactive('change') offset = 3; // from the callout line\n    @reactive('dataChange') minAngle = 20; // in degrees\n}\n\nclass PieSeriesCallout extends Observable {\n    @reactive('change') colors: string[] = [];\n    @reactive('change') length: number = 10;\n    @reactive('change') strokeWidth: number = 1;\n}\n\nexport class PieSeriesTooltip extends SeriesTooltip {\n    @reactive('change') renderer?: (params: PieTooltipRendererParams) => string | TooltipRendererResult;\n}\n\nexport class PieSeries extends PolarSeries {\n\n    static className = 'PieSeries';\n    static type = 'pie';\n\n    private radiusScale: LinearScale = new LinearScale();\n    private groupSelection: Selection<Group, Group, PieNodeDatum, any> = Selection.select(this.group).selectAll<Group>();\n\n    /**\n     * The processed data that gets visualized.\n     */\n    private groupSelectionData: PieNodeDatum[] = [];\n\n    private angleScale: LinearScale = (() => {\n        const scale = new LinearScale();\n        // Each slice is a ratio of the whole, where all ratios add up to 1.\n        scale.domain = [0, 1];\n        // Add 90 deg to start the first pie at 12 o'clock.\n        scale.range = [-Math.PI, Math.PI].map(angle => angle + Math.PI / 2);\n        return scale;\n    })();\n\n    // When a user toggles a series item (e.g. from the legend), its boolean state is recorded here.\n    public seriesItemEnabled: boolean[] = [];\n\n    private _title?: Caption;\n    set title(value: Caption | undefined) {\n        const oldTitle = this._title;\n\n        if (oldTitle !== value) {\n            if (oldTitle) {\n                oldTitle.removeEventListener('change', this.scheduleLayout);\n                this.group.removeChild(oldTitle.node);\n            }\n\n            if (value) {\n                value.node.textBaseline = 'bottom';\n                value.addEventListener('change', this.scheduleLayout);\n                this.group.appendChild(value.node);\n            }\n\n            this._title = value;\n            this.scheduleLayout();\n        }\n    }\n    get title(): Caption | undefined {\n        return this._title;\n    }\n\n    readonly label = new PieSeriesLabel();\n    readonly callout = new PieSeriesCallout();\n\n    tooltip: PieSeriesTooltip = new PieSeriesTooltip();\n\n    constructor() {\n        super();\n\n        this.addEventListener('update', this.update, this);\n        this.label.addEventListener('change', this.scheduleLayout, this);\n        this.label.addEventListener('dataChange', this.scheduleData, this);\n        this.callout.addEventListener('change', this.scheduleLayout, this);\n        this.callout.colors = this.strokes;\n\n        this.addPropertyListener('data', event => {\n            if (event.value) {\n                event.source.seriesItemEnabled = event.value.map(() => true);\n            }\n        });\n    }\n\n    /**\n     * The key of the numeric field to use to determine the angle (for example,\n     * a pie slice angle).\n     */\n    @reactive('dataChange') angleKey = '';\n    @reactive('update') angleName = '';\n\n    /**\n     * The key of the numeric field to use to determine the radii of pie slices.\n     * The largest value will correspond to the full radius and smaller values to\n     * proportionally smaller radii.\n     */\n    @reactive('dataChange') radiusKey?: string;\n    @reactive('update') radiusName?: string;\n    @reactive('dataChange') radiusMin?: number;\n    @reactive('dataChange') radiusMax?: number;\n\n    @reactive('dataChange') labelKey?: string;\n    @reactive('update') labelName?: string;\n\n    private _fills: string[] = [\n        '#c16068',\n        '#a2bf8a',\n        '#ebcc87',\n        '#80a0c3',\n        '#b58dae',\n        '#85c0d1'\n    ];\n    set fills(values: string[]) {\n        this._fills = values;\n        this.strokes = values.map(color => Color.fromString(color).darker().toHexString());\n        this.scheduleData();\n    }\n    get fills(): string[] {\n        return this._fills;\n    }\n\n    private _strokes: string[] = [\n        '#874349',\n        '#718661',\n        '#a48f5f',\n        '#5a7088',\n        '#7f637a',\n        '#5d8692'\n    ];\n    set strokes(values: string[]) {\n        this._strokes = values;\n        this.callout.colors = values;\n        this.scheduleData();\n    }\n    get strokes(): string[] {\n        return this._strokes;\n    }\n\n    @reactive('layoutChange') fillOpacity = 1;\n    @reactive('layoutChange') strokeOpacity = 1;\n\n    @reactive('update') lineDash?: number[] = undefined;\n    @reactive('update') lineDashOffset: number = 0;\n\n    @reactive('update') formatter?: (params: PieSeriesFormatterParams) => PieSeriesFormat;\n\n    /**\n     * The series rotation in degrees.\n     */\n    @reactive('dataChange') rotation = 0;\n\n    @reactive('layoutChange') outerRadiusOffset = 0;\n\n    @reactive('dataChange') innerRadiusOffset = 0;\n\n    @reactive('layoutChange') strokeWidth = 1;\n\n    @reactive('layoutChange') shadow?: DropShadow;\n\n    highlightStyle: PieHighlightStyle = { fill: 'yellow' };\n\n    onHighlightChange() {\n        this.updateNodes();\n    }\n\n    setColors(fills: string[], strokes: string[]) {\n        this.fills = fills;\n        this.strokes = strokes;\n        this.callout.colors = strokes;\n    }\n\n    getDomain(direction: ChartAxisDirection): any[] {\n        if (direction === ChartAxisDirection.X) {\n            return this.angleScale.domain;\n        } else {\n            return this.radiusScale.domain;\n        }\n    }\n\n    processData(): boolean {\n        const { angleKey, radiusKey, seriesItemEnabled, angleScale, groupSelectionData } = this;\n        const data = angleKey && this.data ? this.data : [];\n\n        const angleData: number[] = data.map((datum, index) => seriesItemEnabled[index] && Math.abs(+datum[angleKey]) || 0);\n        const angleDataTotal = angleData.reduce((a, b) => a + b, 0);\n\n        // The ratios (in [0, 1] interval) used to calculate the end angle value for every pie slice.\n        // Each slice starts where the previous one ends, so we only keep the ratios for end angles.\n        const angleDataRatios = (() => {\n            let sum = 0;\n            return angleData.map(datum => sum += datum / angleDataTotal);\n        })();\n\n        const labelKey = this.label.enabled && this.labelKey;\n        const labelData = labelKey ? data.map(datum => String(datum[labelKey])) : [];\n        let radiusData: number[] = [];\n\n        if (radiusKey) {\n            const { radiusMin, radiusMax } = this;\n            const radii = data.map(datum => Math.abs(datum[radiusKey]));\n            const min = radiusMin !== undefined ? radiusMin : Math.min(...radii);\n            const max = radiusMax !== undefined ? radiusMax : Math.max(...radii);\n            const delta = max - min;\n\n            radiusData = radii.map(value => delta ? (value - min) / delta : 1);\n        }\n\n        groupSelectionData.length = 0;\n\n        const rotation = toRadians(this.rotation);\n        const halfPi = Math.PI / 2;\n\n        let datumIndex = 0;\n\n        // Simply use reduce here to pair up adjacent ratios.\n        angleDataRatios.reduce((start, end) => {\n            const radius = radiusKey ? radiusData[datumIndex] : 1;\n            const startAngle = angleScale.convert(start) + rotation;\n            const endAngle = angleScale.convert(end) + rotation;\n\n            const midAngle = (startAngle + endAngle) / 2;\n            const span = Math.abs(endAngle - startAngle);\n            const midCos = Math.cos(midAngle);\n            const midSin = Math.sin(midAngle);\n\n            const labelMinAngle = toRadians(this.label.minAngle);\n            const labelVisible = labelKey && span > labelMinAngle;\n            const midAngle180 = normalizeAngle180(midAngle);\n\n            // Split the circle into quadrants like so: \n            let quadrantStart = -3 * Math.PI / 4; // same as `normalizeAngle180(toRadians(-135))`\n            let textAlign: CanvasTextAlign;\n            let textBaseline: CanvasTextBaseline;\n\n            if (midAngle180 >= quadrantStart && midAngle180 < (quadrantStart += halfPi)) {\n                textAlign = 'center';\n                textBaseline = 'bottom';\n            } else if (midAngle180 >= quadrantStart && midAngle180 < (quadrantStart += halfPi)) {\n                textAlign = 'left';\n                textBaseline = 'middle';\n            } else if (midAngle180 >= quadrantStart && midAngle180 < (quadrantStart += halfPi)) {\n                textAlign = 'center';\n                textBaseline = 'hanging';\n            } else {\n                textAlign = 'right';\n                textBaseline = 'middle';\n            }\n\n            groupSelectionData.push({\n                series: this,\n                seriesDatum: data[datumIndex],\n                index: datumIndex,\n                radius,\n                startAngle,\n                endAngle,\n                midAngle,\n                midCos,\n                midSin,\n                label: labelVisible ? {\n                    text: labelData[datumIndex],\n                    textAlign,\n                    textBaseline\n                } : undefined\n            });\n\n            datumIndex++;\n\n            return end;\n        }, 0);\n\n        return true;\n    }\n\n    update(): void {\n        const { chart } = this;\n        const visible = this.group.visible = this.visible && this.seriesItemEnabled.indexOf(true) >= 0;\n\n        if (!visible || !chart || chart.dataPending || chart.layoutPending) {\n            return;\n        }\n\n        const { radius, innerRadiusOffset, outerRadiusOffset, title } = this;\n\n        this.radiusScale.range = [\n            innerRadiusOffset ? radius + innerRadiusOffset : 0,\n            radius + (outerRadiusOffset || 0)\n        ];\n\n        this.group.translationX = this.centerX;\n        this.group.translationY = this.centerY;\n\n        if (title) {\n            title.node.translationY = -radius - outerRadiusOffset - 2;\n            title.node.visible = title.enabled;\n        }\n\n        this.updateGroupSelection();\n        this.updateNodes();\n    }\n\n    private updateGroupSelection() {\n        const updateGroups = this.groupSelection.setData(this.groupSelectionData);\n        updateGroups.exit.remove();\n\n        const enterGroups = updateGroups.enter.append(Group);\n        enterGroups.append(Sector).each(node => node.tag = PieNodeTag.Sector);\n        enterGroups.append(Line).each(node => {\n            node.tag = PieNodeTag.Callout;\n            node.pointerEvents = PointerEvents.None;\n        });\n        enterGroups.append(Text).each(node => {\n            node.tag = PieNodeTag.Label;\n            node.pointerEvents = PointerEvents.None;\n        });\n\n        this.groupSelection = updateGroups.merge(enterGroups);\n    }\n\n    private updateNodes() {\n        if (!this.chart) {\n            return;\n        }\n\n        const {\n            fills, strokes, fillOpacity, strokeOpacity, strokeWidth,\n            outerRadiusOffset, radiusScale, callout, shadow,\n            highlightStyle: { fill, stroke, centerOffset },\n            angleKey, radiusKey, formatter\n        } = this;\n        const { highlightedDatum } = this.chart;\n\n        const centerOffsets: number[] = [];\n        const innerRadius = radiusScale.convert(0);\n\n        this.groupSelection.selectByTag<Sector>(PieNodeTag.Sector).each((sector, datum, index) => {\n            const radius = radiusScale.convert(datum.radius);\n            const outerRadius = Math.max(0, radius + outerRadiusOffset);\n            const highlighted = datum === highlightedDatum;\n            const sectorFill = highlighted && fill !== undefined ? fill : fills[index % fills.length];\n            const sectorStroke = highlighted && stroke !== undefined ? stroke : strokes[index % strokes.length];\n            let format: PieSeriesFormat | undefined = undefined;\n\n            if (formatter) {\n                format = formatter({\n                    datum: datum.seriesDatum,\n                    fill: sectorFill,\n                    stroke: sectorStroke,\n                    strokeWidth,\n                    highlighted,\n                    angleKey,\n                    radiusKey\n                });\n            }\n\n            sector.innerRadius = innerRadius;\n            sector.outerRadius = radius;\n\n            sector.startAngle = datum.startAngle;\n            sector.endAngle = datum.endAngle;\n\n            sector.fill = format && format.fill || sectorFill;\n            sector.stroke = format && format.stroke || sectorStroke;\n            sector.strokeWidth = format && format.strokeWidth !== undefined ? format.strokeWidth : strokeWidth;\n            sector.fillOpacity = fillOpacity;\n            sector.strokeOpacity = strokeOpacity;\n            sector.lineDash = this.lineDash;\n            sector.lineDashOffset = this.lineDashOffset;\n            sector.centerOffset = highlighted && centerOffset !== undefined ? centerOffset : 0;\n            sector.fillShadow = shadow;\n            sector.lineJoin = 'round';\n\n            centerOffsets.push(sector.centerOffset);\n        });\n\n        const { colors: calloutColors, length: calloutLength, strokeWidth: calloutStrokeWidth } = callout;\n\n        this.groupSelection.selectByTag<Line>(PieNodeTag.Callout).each((line, datum, index) => {\n            if (datum.label) {\n                const radius = radiusScale.convert(datum.radius);\n\n                line.strokeWidth = calloutStrokeWidth;\n                line.stroke = calloutColors[index % calloutColors.length];\n                line.x1 = datum.midCos * radius;\n                line.y1 = datum.midSin * radius;\n                line.x2 = datum.midCos * (radius + calloutLength);\n                line.y2 = datum.midSin * (radius + calloutLength);\n            } else {\n                line.stroke = undefined;\n            }\n        });\n\n        {\n            const { offset, fontStyle, fontWeight, fontSize, fontFamily, color } = this.label;\n\n            this.groupSelection.selectByTag<Text>(PieNodeTag.Label).each((text, datum, index) => {\n                const label = datum.label;\n\n                if (label) {\n                    const radius = radiusScale.convert(datum.radius);\n                    const labelRadius = centerOffsets[index] + radius + calloutLength + offset;\n\n                    text.fontStyle = fontStyle;\n                    text.fontWeight = fontWeight;\n                    text.fontSize = fontSize;\n                    text.fontFamily = fontFamily;\n                    text.text = label.text;\n                    text.x = datum.midCos * labelRadius;\n                    text.y = datum.midSin * labelRadius;\n                    text.fill = color;\n                    text.textAlign = label.textAlign;\n                    text.textBaseline = label.textBaseline;\n                } else {\n                    text.fill = undefined;\n                }\n            });\n        }\n    }\n\n    fireNodeClickEvent(event: MouseEvent, datum: PieNodeDatum): void {\n        this.fireEvent<PieSeriesNodeClickEvent>({\n            type: 'nodeClick',\n            event,\n            series: this,\n            datum: datum.seriesDatum,\n            angleKey: this.angleKey,\n            labelKey: this.labelKey,\n            radiusKey: this.radiusKey\n        });\n    }\n\n    getTooltipHtml(nodeDatum: PieNodeDatum): string {\n        const { angleKey } = this;\n\n        if (!angleKey) {\n            return '';\n        }\n\n        const {\n            fills,\n            tooltip,\n            angleName,\n            radiusKey,\n            radiusName,\n            labelKey,\n            labelName,\n        } = this;\n\n        const { renderer: tooltipRenderer } = tooltip;\n        const color = fills[nodeDatum.index % fills.length];\n        const datum = nodeDatum.seriesDatum;\n        const label = labelKey ? `${datum[labelKey]}: ` : '';\n        const angleValue = datum[angleKey];\n        const formattedAngleValue = typeof angleValue === 'number' ? toFixed(angleValue) : angleValue.toString();\n        const title = this.title ? this.title.text : undefined;\n        const content = label + formattedAngleValue;\n        const defaults: TooltipRendererResult = {\n            title,\n            backgroundColor: color,\n            content\n        };\n\n        if (tooltipRenderer) {\n            return toTooltipHtml(tooltipRenderer({\n                datum,\n                angleKey,\n                angleValue,\n                angleName,\n                radiusKey,\n                radiusValue: radiusKey ? datum[radiusKey] : undefined,\n                radiusName,\n                labelKey,\n                labelName,\n                title,\n                color,\n            }), defaults);\n        }\n\n        return toTooltipHtml(defaults);\n    }\n\n    listSeriesItems(legendData: LegendDatum[]): void {\n        const { labelKey, data } = this;\n\n        if (data && data.length && labelKey) {\n            const { fills, strokes, id } = this;\n\n            data.forEach((datum, index) => {\n                legendData.push({\n                    id,\n                    itemId: index,\n                    enabled: this.seriesItemEnabled[index],\n                    label: {\n                        text: String(datum[labelKey])\n                    },\n                    marker: {\n                        fill: fills[index % fills.length],\n                        stroke: strokes[index % strokes.length],\n                        fillOpacity: this.fillOpacity,\n                        strokeOpacity: this.strokeOpacity\n                    }\n                });\n            });\n        }\n    }\n\n    toggleSeriesItem(itemId: number, enabled: boolean): void {\n        this.seriesItemEnabled[itemId] = enabled;\n        this.scheduleData();\n    }\n}\n","/Users/vitaliikravchenko/Sites/nova/client/src/charts/chart/axis/categoryAxis.ts",[],"/Users/vitaliikravchenko/Sites/nova/client/src/charts/chart/axis/numberAxis.ts",[],"/Users/vitaliikravchenko/Sites/nova/client/src/charts/chart/groupedCategoryChart.ts",[],"/Users/vitaliikravchenko/Sites/nova/client/src/charts/chart/cartesianChart.ts",[],"/Users/vitaliikravchenko/Sites/nova/client/src/charts/chart/marker/util.ts",[],"/Users/vitaliikravchenko/Sites/nova/client/src/charts/chart/markerLabel.ts",[],"/Users/vitaliikravchenko/Sites/nova/client/src/charts/chart/series/polar/polarSeries.ts",[],"/Users/vitaliikravchenko/Sites/nova/client/src/charts/util/equal.ts",["556","557","558"],"export function equal(a: any, b: any): boolean {\n    if (a === b) return true;\n\n    if (a && b && typeof a == 'object' && typeof b == 'object') {\n        if (a.constructor !== b.constructor) return false;\n\n        let length, i;\n        if (Array.isArray(a)) {\n            length = a.length;\n            if (length != b.length) return false;\n            for (i = length; i-- !== 0;)\n                if (!equal(a[i], b[i])) return false;\n            return true;\n        }\n\n        // if ((a instanceof Map) && (b instanceof Map)) {\n        //     if (a.size !== b.size) return false;\n        //     for (i of a.entries())\n        //         if (!b.has(i[0])) return false;\n        //     for (i of a.entries())\n        //         if (!equal(i[1], b.get(i[0]))) return false;\n        //     return true;\n        // }\n        //\n        // if ((a instanceof Set) && (b instanceof Set)) {\n        //     if (a.size !== b.size) return false;\n        //     for (i of a.entries())\n        //         if (!b.has(i[0])) return false;\n        //     return true;\n        // }\n        //\n        // if (ArrayBuffer.isView(a) && ArrayBuffer.isView(b)) {\n        //     length = a.length;\n        //     if (length != b.length) return false;\n        //     for (i = length; i-- !== 0;)\n        //         if (a[i] !== b[i]) return false;\n        //     return true;\n        // }\n\n        if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;\n        if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\n        if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();\n\n        const keys = Object.keys(a);\n        length = keys.length;\n        if (length !== Object.keys(b).length) return false;\n\n        for (i = length; i-- !== 0;)\n            if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n\n        for (i = length; i-- !== 0;) {\n            const key = keys[i];\n            if (!equal(a[key], b[key])) return false;\n        }\n\n        return true;\n    }\n\n    // true if both NaN, false otherwise\n    return a !== a && b !== b;\n}\n","/Users/vitaliikravchenko/Sites/nova/client/src/charts/util/string.ts",[],"/Users/vitaliikravchenko/Sites/nova/client/src/charts/scale/linearScale.ts",[],"/Users/vitaliikravchenko/Sites/nova/client/src/charts/chart/label.ts",[],"/Users/vitaliikravchenko/Sites/nova/client/src/charts/scale/bandScale.ts",[],"/Users/vitaliikravchenko/Sites/nova/client/src/charts/scene/shape/sector.ts",[],"/Users/vitaliikravchenko/Sites/nova/client/src/charts/util/color.ts",["559"],"export class Color {\n\n    readonly r: number;\n    readonly g: number;\n    readonly b: number;\n    readonly a: number;\n\n    /**\n     * Every color component should be in the [0, 1] range.\n     * Some easing functions (such as elastic easing) can overshoot the target value by some amount.\n     * So, when animating colors, if the source or target color components are already near\n     * or at the edge of the allowed [0, 1] range, it is possible for the intermediate color\n     * component value to end up outside of that range mid-animation. For this reason the constructor\n     * performs range checking/constraining.\n     * @param r Red component.\n     * @param g Green component.\n     * @param b Blue component.\n     * @param a Alpha (opacity) component.\n     */\n    constructor(r: number, g: number, b: number, a: number = 1) {\n        // NaN is treated as 0.\n        this.r = Math.min(1, Math.max(0, r || 0));\n        this.g = Math.min(1, Math.max(0, g || 0));\n        this.b = Math.min(1, Math.max(0, b || 0));\n        this.a = Math.min(1, Math.max(0, a || 0));\n    }\n\n    /**\n     * The given string can be in one of the following formats:\n     * - #rgb\n     * - #rrggbb\n     * - rgb(r, g, b)\n     * - rgba(r, g, b, a)\n     * - CSS color name such as 'white', 'orange', 'cyan', etc.\n     * @param str\n     */\n    static fromString(str: string): Color {\n        // hexadecimal notation\n        if (str.indexOf('#') >= 0) { // there can be some leading whitespace\n            return Color.fromHexString(str);\n        }\n\n        // color name\n        const hex = Color.nameToHex[str];\n        if (hex) {\n            return Color.fromHexString(hex);\n        }\n\n        // rgb(a) notation\n        if (str.indexOf('rgb') >= 0) {\n            return Color.fromRgbaString(str);\n        }\n\n        throw new Error(`Invalid color string: '${str}'`);\n    }\n\n    // See https://drafts.csswg.org/css-color/#hex-notation\n    private static hexRe = /\\s*#([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})?\\s*$/;\n    private static shortHexRe = /\\s*#([0-9a-fA-F])([0-9a-fA-F])([0-9a-fA-F])([0-9a-fA-F])?\\s*$/;\n    // Using separate RegExp for the short hex notation because strings like `#abcd`\n    // are matched as ['#abcd', 'ab', 'c', 'd', undefined] when the `{1,2}` quantifier is used.\n\n    static fromHexString(str: string): Color {\n        let values = str.match(Color.hexRe);\n        if (values) {\n            const r = parseInt(values[1], 16);\n            const g = parseInt(values[2], 16);\n            const b = parseInt(values[3], 16);\n            const a = values[4] !== undefined ? parseInt(values[4], 16) : 255;\n\n            return new Color(r / 255, g / 255, b / 255, a / 255);\n        }\n\n        values = str.match(Color.shortHexRe);\n        if (values) {\n            let r = parseInt(values[1], 16);\n            let g = parseInt(values[2], 16);\n            let b = parseInt(values[3], 16);\n            let a = values[4] !== undefined ? parseInt(values[4], 16) : 15;\n\n            r += r * 16;\n            g += g * 16;\n            b += b * 16;\n            a += a * 16;\n\n            return new Color(r / 255, g / 255, b / 255, a / 255);\n        }\n\n        throw new Error(`Malformed hexadecimal color string: '${str}'`);\n    }\n\n    private static rgbRe = /\\s*rgb\\((\\d+),\\s*(\\d+),\\s*(\\d+)\\)\\s*/;\n    private static rgbaRe = /\\s*rgba\\((\\d+),\\s*(\\d+),\\s*(\\d+),\\s*([.\\d]+)\\)\\s*/;\n\n    static fromRgbaString(str: string): Color {\n        let values = str.match(Color.rgbRe);\n        if (values) {\n            return new Color(+values[1] / 255, +values[2] / 255, +values[3] / 255);\n        }\n\n        values = str.match(Color.rgbaRe);\n        if (values) {\n            return new Color(+values[1] / 255, +values[2] / 255, +values[3] / 255, +values[4]);\n        }\n\n        throw new Error(`Malformed rgb/rgba color string: '${str}'`);\n    }\n\n    static fromArray(arr: [number, number, number] | [number, number, number, number]): Color {\n        if (arr.length === 4) {\n            return new Color(arr[0], arr[1], arr[2], arr[3]);\n        }\n        if (arr.length === 3) {\n            return new Color(arr[0], arr[1], arr[2]);\n        }\n        throw new Error('The given array should contain 3 or 4 color components (numbers).');\n    }\n\n    static fromHSB(h: number, s: number, b: number, alpha = 1): Color {\n        const rgb = Color.HSBtoRGB(h, s, b);\n        return new Color(rgb[0], rgb[1], rgb[2], alpha);\n    }\n\n    private static padHex(str: string): string {\n        // Can't use `padStart(2, '0')` here because of IE.\n        return str.length === 1 ? '0' + str : str;\n    }\n\n    toHexString(): string {\n        let hex = '#'\n            + Color.padHex(Math.round(this.r * 255).toString(16))\n            + Color.padHex(Math.round(this.g * 255).toString(16))\n            + Color.padHex(Math.round(this.b * 255).toString(16));\n\n        if (this.a < 1) {\n            hex += Color.padHex(Math.round(this.a * 255).toString(16));\n        }\n\n        return hex;\n    }\n\n    toRgbaString(fractionDigits = 3): string {\n        const components: number[] = [\n            Math.round(this.r * 255),\n            Math.round(this.g * 255),\n            Math.round(this.b * 255)\n        ];\n\n        const k = Math.pow(10, fractionDigits);\n\n        if (this.a !== 1) {\n            components.push(Math.round(this.a * k) / k);\n            return `rgba(${components.join(', ')})`;\n        }\n\n        return `rgb(${components.join(', ')})`;\n    }\n\n    toString(): string {\n        if (this.a === 1) {\n            return this.toHexString();\n        }\n        return this.toRgbaString();\n    }\n\n    toHSB(): [number, number, number] {\n        return Color.RGBtoHSB(this.r, this.g, this.b);\n    }\n\n    /**\n     * Converts the given RGB triple to an array of HSB (HSV) components.\n     * The hue component will be `NaN` for achromatic colors.\n     */\n    static RGBtoHSB(r: number, g: number, b: number): [number, number, number] {\n        const min = Math.min(r, g, b);\n        const max = Math.max(r, g, b);\n\n        const S = max !== 0 ? (max - min) / max : 0;\n        let H = NaN;\n\n        // min == max, means all components are the same\n        // and the color is a shade of gray with no hue (H is NaN)\n        if (min !== max) {\n            const delta = max - min;\n            const rc = (max - r) / delta;\n            const gc = (max - g) / delta;\n            const bc = (max - b) / delta;\n            if (r === max) {\n                H = bc - gc;\n            } else if (g === max) {\n                H = 2.0 + rc - bc;\n            } else {\n                H = 4.0 + gc - rc;\n            }\n            H /= 6.0;\n            if (H < 0) {\n                H = H + 1.0;\n            }\n        }\n\n        return [H * 360, S, max];\n    }\n\n    /**\n     * Converts the given HSB (HSV) triple to an array of RGB components.\n     */\n    static HSBtoRGB(H: number, S: number, B: number): [number, number, number] {\n        if (isNaN(H)) {\n            H = 0;\n        }\n        H = (((H % 360) + 360) % 360) / 360; // normalize hue to [0, 360] interval, then scale to [0, 1]\n\n        let r = 0;\n        let g = 0;\n        let b = 0;\n\n        if (S === 0) {\n            r = g = b = B;\n        } else {\n            const h = (H - Math.floor(H)) * 6;\n            const f = h - Math.floor(h);\n            const p = B * (1 - S);\n            const q = B * (1 - S * f);\n            const t = B * (1 - (S * (1 - f)));\n            switch (h >> 0) { // discard the floating point part of the number\n            case 0:\n                r = B;\n                g = t;\n                b = p;\n                break;\n            case 1:\n                r = q;\n                g = B;\n                b = p;\n                break;\n            case 2:\n                r = p;\n                g = B;\n                b = t;\n                break;\n            case 3:\n                r = p;\n                g = q;\n                b = B;\n                break;\n            case 4:\n                r = t;\n                g = p;\n                b = B;\n                break;\n            case 5:\n                r = B;\n                g = p;\n                b = q;\n                break;\n            }\n        }\n        return [r, g, b];\n    }\n\n    private derive(hueShift: number, saturationFactor: number, brightnessFactor: number, opacityFactor: number): Color {\n        const hsb = Color.RGBtoHSB(this.r, this.g, this.b);\n\n        let b = hsb[2];\n        if (b == 0 && brightnessFactor > 1.0) {\n            b = 0.05;\n        }\n\n        const h = (((hsb[0] + hueShift) % 360) + 360) % 360;\n        const s = Math.max(Math.min(hsb[1] * saturationFactor, 1.0), 0.0);\n        b = Math.max(Math.min(b * brightnessFactor, 1.0), 0.0);\n        const a = Math.max(Math.min(this.a * opacityFactor, 1.0), 0.0);\n        const rgba = Color.HSBtoRGB(h, s, b);\n        rgba.push(a);\n        return Color.fromArray(rgba);\n    }\n\n    brighter(): Color {\n        return this.derive(0, 1.0, 1.0 / 0.7, 1.0);\n    }\n\n    darker(): Color {\n        return this.derive(0, 1.0, 0.7, 1.0);\n    }\n\n    /**\n     * CSS Color Module Level 4:\n     * https://drafts.csswg.org/css-color/#named-colors\n     */\n    private static nameToHex: { [key: string]: string } = Object.freeze({\n        aliceblue: '#F0F8FF',\n        antiquewhite: '#FAEBD7',\n        aqua: '#00FFFF',\n        aquamarine: '#7FFFD4',\n        azure: '#F0FFFF',\n        beige: '#F5F5DC',\n        bisque: '#FFE4C4',\n        black: '#000000',\n        blanchedalmond: '#FFEBCD',\n        blue: '#0000FF',\n        blueviolet: '#8A2BE2',\n        brown: '#A52A2A',\n        burlywood: '#DEB887',\n        cadetblue: '#5F9EA0',\n        chartreuse: '#7FFF00',\n        chocolate: '#D2691E',\n        coral: '#FF7F50',\n        cornflowerblue: '#6495ED',\n        cornsilk: '#FFF8DC',\n        crimson: '#DC143C',\n        cyan: '#00FFFF',\n        darkblue: '#00008B',\n        darkcyan: '#008B8B',\n        darkgoldenrod: '#B8860B',\n        darkgray: '#A9A9A9',\n        darkgreen: '#006400',\n        darkgrey: '#A9A9A9',\n        darkkhaki: '#BDB76B',\n        darkmagenta: '#8B008B',\n        darkolivegreen: '#556B2F',\n        darkorange: '#FF8C00',\n        darkorchid: '#9932CC',\n        darkred: '#8B0000',\n        darksalmon: '#E9967A',\n        darkseagreen: '#8FBC8F',\n        darkslateblue: '#483D8B',\n        darkslategray: '#2F4F4F',\n        darkslategrey: '#2F4F4F',\n        darkturquoise: '#00CED1',\n        darkviolet: '#9400D3',\n        deeppink: '#FF1493',\n        deepskyblue: '#00BFFF',\n        dimgray: '#696969',\n        dimgrey: '#696969',\n        dodgerblue: '#1E90FF',\n        firebrick: '#B22222',\n        floralwhite: '#FFFAF0',\n        forestgreen: '#228B22',\n        fuchsia: '#FF00FF',\n        gainsboro: '#DCDCDC',\n        ghostwhite: '#F8F8FF',\n        gold: '#FFD700',\n        goldenrod: '#DAA520',\n        gray: '#808080',\n        green: '#008000',\n        greenyellow: '#ADFF2F',\n        grey: '#808080',\n        honeydew: '#F0FFF0',\n        hotpink: '#FF69B4',\n        indianred: '#CD5C5C',\n        indigo: '#4B0082',\n        ivory: '#FFFFF0',\n        khaki: '#F0E68C',\n        lavender: '#E6E6FA',\n        lavenderblush: '#FFF0F5',\n        lawngreen: '#7CFC00',\n        lemonchiffon: '#FFFACD',\n        lightblue: '#ADD8E6',\n        lightcoral: '#F08080',\n        lightcyan: '#E0FFFF',\n        lightgoldenrodyellow: '#FAFAD2',\n        lightgray: '#D3D3D3',\n        lightgreen: '#90EE90',\n        lightgrey: '#D3D3D3',\n        lightpink: '#FFB6C1',\n        lightsalmon: '#FFA07A',\n        lightseagreen: '#20B2AA',\n        lightskyblue: '#87CEFA',\n        lightslategray: '#778899',\n        lightslategrey: '#778899',\n        lightsteelblue: '#B0C4DE',\n        lightyellow: '#FFFFE0',\n        lime: '#00FF00',\n        limegreen: '#32CD32',\n        linen: '#FAF0E6',\n        magenta: '#FF00FF',\n        maroon: '#800000',\n        mediumaquamarine: '#66CDAA',\n        mediumblue: '#0000CD',\n        mediumorchid: '#BA55D3',\n        mediumpurple: '#9370DB',\n        mediumseagreen: '#3CB371',\n        mediumslateblue: '#7B68EE',\n        mediumspringgreen: '#00FA9A',\n        mediumturquoise: '#48D1CC',\n        mediumvioletred: '#C71585',\n        midnightblue: '#191970',\n        mintcream: '#F5FFFA',\n        mistyrose: '#FFE4E1',\n        moccasin: '#FFE4B5',\n        navajowhite: '#FFDEAD',\n        navy: '#000080',\n        oldlace: '#FDF5E6',\n        olive: '#808000',\n        olivedrab: '#6B8E23',\n        orange: '#FFA500',\n        orangered: '#FF4500',\n        orchid: '#DA70D6',\n        palegoldenrod: '#EEE8AA',\n        palegreen: '#98FB98',\n        paleturquoise: '#AFEEEE',\n        palevioletred: '#DB7093',\n        papayawhip: '#FFEFD5',\n        peachpuff: '#FFDAB9',\n        peru: '#CD853F',\n        pink: '#FFC0CB',\n        plum: '#DDA0DD',\n        powderblue: '#B0E0E6',\n        purple: '#800080',\n        rebeccapurple: '#663399',\n        red: '#FF0000',\n        rosybrown: '#BC8F8F',\n        royalblue: '#4169E1',\n        saddlebrown: '#8B4513',\n        salmon: '#FA8072',\n        sandybrown: '#F4A460',\n        seagreen: '#2E8B57',\n        seashell: '#FFF5EE',\n        sienna: '#A0522D',\n        silver: '#C0C0C0',\n        skyblue: '#87CEEB',\n        slateblue: '#6A5ACD',\n        slategray: '#708090',\n        slategrey: '#708090',\n        snow: '#FFFAFA',\n        springgreen: '#00FF7F',\n        steelblue: '#4682B4',\n        tan: '#D2B48C',\n        teal: '#008080',\n        thistle: '#D8BFD8',\n        tomato: '#FF6347',\n        turquoise: '#40E0D0',\n        violet: '#EE82EE',\n        wheat: '#F5DEB3',\n        white: '#FFFFFF',\n        whitesmoke: '#F5F5F5',\n        yellow: '#FFFF00',\n        yellowgreen: '#9ACD32'\n    });\n}\n","/Users/vitaliikravchenko/Sites/nova/client/src/charts/layout/tree.ts",["560"],"import { find } from \"../util/array\";\n\ninterface Tick {\n    labels: string[];\n}\n\n/**\n * The tree layout is calculated in abstract x/y coordinates, where the root is at (0, 0)\n * and the tree grows downward from the root.\n */\n\nclass TreeNode {\n    label: string;\n    x: number = 0;\n    y: number = 0;\n    subtreeLeft: number = NaN;\n    subtreeRight: number = NaN;\n    screenX: number = 0;\n    screenY: number = 0;\n    parent?: TreeNode;\n    children: TreeNode[] = [];\n    leafCount: number = 0;\n    depth: number;\n    prelim: number = 0;\n    mod: number = 0;\n    thread?: TreeNode;\n    ancestor = this;\n    change: number = 0;\n    shift: number = 0;\n    number: number; // current number in sibling group (index)\n\n    constructor(label = '', parent?: any, number = 0) {\n        this.label = label;\n        // screenX and screenY are meant to be recomputed from (layout) x and y\n        // when the tree is resized (without performing another layout)\n        this.parent = parent;\n        this.depth = parent ? parent.depth + 1 : 0;\n        this.number = number;\n    }\n\n    getLeftSibling(): TreeNode | undefined {\n        return this.number > 0  && this.parent ? this.parent.children[this.number - 1] : undefined;\n    }\n\n    getLeftmostSibling(): TreeNode | undefined {\n        return this.number > 0 && this.parent ? this.parent.children[0] : undefined;\n    }\n\n    // traverse the left contour of a subtree, return the successor of v on this contour\n    nextLeft(): TreeNode | undefined {\n        return this.children ? this.children[0] : this.thread;\n    }\n    // traverse the right contour of a subtree, return the successor of v on this contour\n    nextRight(): TreeNode | undefined {\n        return this.children ? this.children[this.children.length - 1] : this.thread;\n    }\n\n    getSiblings(): TreeNode[] {\n        return this.parent ? this.parent.children.filter((_, i) => i !== this.number) : [];\n    }\n}\n\n/**\n * Converts an array of ticks, where each tick has an array of labels, to a label tree.\n * If `pad` is `true`, will ensure that every branch matches the depth of the tree by\n * creating empty labels.\n */\nexport function ticksToTree(ticks: Tick[], pad = true): TreeNode {\n    const root: any = new TreeNode();\n    let depth = 0;\n\n    if (pad) {\n        ticks.forEach(tick => depth = Math.max(depth, tick.labels.length));\n    }\n    ticks.forEach(tick => {\n        if (pad) {\n            while (tick.labels.length < depth) {\n                tick.labels.unshift('');\n            }\n        }\n        insertTick(root, tick);\n    });\n\n    return root;\n}\n\nfunction insertTick(root: TreeNode, tick: Tick) {\n    const pathParts = tick.labels.slice().reverse(); // path elements from root to leaf label\n    const lastPartIndex = pathParts.length - 1;\n\n    pathParts.forEach((pathPart, partIndex) => {\n        const children = root.children;\n        const existingNode = find(children, child => child.label === pathPart);\n        const isNotLeaf = partIndex !== lastPartIndex;\n        if (existingNode && isNotLeaf) { // the isNotLeaf check is to allow duplicate leafs\n            root = existingNode;\n        } else {\n            const node = new TreeNode(pathPart, root);\n            node.number = children.length;\n            children.push(node);\n            if (isNotLeaf) {\n                root = node;\n            }\n        }\n    });\n}\n\n// Shift the subtree.\nfunction moveSubtree(wm: TreeNode, wp: TreeNode, shift: number) {\n    const subtrees = wp.number - wm.number;\n    const ratio = shift / subtrees;\n    wp.change -= ratio;\n    wp.shift += shift;\n    wm.change += ratio;\n    wp.prelim += shift;\n    wp.mod += shift;\n}\n\nfunction ancestor(vim: TreeNode, v: TreeNode, defaultAncestor: TreeNode): TreeNode {\n    return v.getSiblings().indexOf(vim.ancestor) >= 0 ? vim.ancestor : defaultAncestor;\n}\n\n// Spaces out the children.\nfunction executeShifts(v: TreeNode) {\n    const children = v.children;\n\n    if (children) {\n        let shift = 0;\n        let change = 0;\n\n        for (let i = children.length - 1; i >= 0; i--) {\n            const w = children[i];\n            w.prelim += shift;\n            w.mod += shift;\n            change += w.change;\n            shift += w.shift + change;\n        }\n    }\n}\n\n// Moves current subtree with v as the root if some nodes are conflicting in space.\nfunction apportion(v: TreeNode, defaultAncestor: TreeNode, distance: number) {\n    const w = v.getLeftSibling();\n\n    if (w) {\n        let vop = v;\n        let vip = v;\n        let vim = w;\n        let vom = vip.getLeftmostSibling()!;\n        let sip = vip.mod;\n        let sop = vop.mod;\n        let sim = vim.mod;\n        let som = vom.mod;\n\n        while (vim.nextRight() && vip.nextLeft()) {\n            vim = vim.nextRight()!;\n            vip = vip.nextLeft()!;\n            vom = vom.nextLeft()!;\n            vop = vop.nextRight()!;\n            vop.ancestor = v;\n            const shift = (vim.prelim + sim) - (vip.prelim + sip) + distance;\n            if (shift > 0) {\n                moveSubtree(ancestor(vim, v, defaultAncestor), v , shift);\n                sip += shift;\n                sop += shift;\n            }\n            sim += vim.mod;\n            sip += vip.mod;\n            som += vom.mod;\n            sop += vop.mod;\n        }\n\n        if (vim.nextRight() && !vop.nextRight()) {\n            vop.thread = vim.nextRight();\n            vop.mod += sim - sop;\n        } else {\n            if (vip.nextLeft() && !vom.nextLeft()) {\n                vom.thread = vip.nextLeft();\n                vom.mod += sip - som;\n            }\n            defaultAncestor = v;\n        }\n    }\n\n    return defaultAncestor;\n}\n\n// Compute the preliminary x-coordinate of node and its children (recursively).\nfunction firstWalk(node: TreeNode, distance: number) {\n    const children = node.children;\n\n    if (children.length) {\n        let defaultAncestor = children[0];\n        children.forEach(child => {\n            firstWalk(child, distance);\n            defaultAncestor = apportion(child, defaultAncestor, distance);\n        });\n\n        executeShifts(node);\n\n        const midpoint = (children[0].prelim + children[children.length - 1].prelim) / 2;\n        const leftSibling = node.getLeftSibling();\n        if (leftSibling) {\n            node.prelim = leftSibling.prelim + distance;\n            node.mod = node.prelim - midpoint;\n        } else {\n            node.prelim = midpoint;\n        }\n    } else {\n        const leftSibling = node.getLeftSibling();\n        node.prelim = leftSibling ? leftSibling.prelim + distance : 0;\n    }\n}\n\nclass Dimensions {\n    top: number = Infinity;\n    right: number = -Infinity;\n    bottom: number = -Infinity;\n    left: number = Infinity;\n\n    update(node: TreeNode, xy: (node: TreeNode) => {x: number, y: number}) {\n        const {x, y} = xy(node);\n        if (x > this.right) {\n            this.right = x;\n        }\n        if (x < this.left) {\n            this.left = x;\n        }\n        if (y > this.bottom) {\n            this.bottom = y;\n        }\n        if (y < this.top) {\n            this.top = y;\n        }\n    }\n}\n\nfunction secondWalk(v: TreeNode, m: number, layout: TreeLayout) {\n    v.x = v.prelim + m;\n    v.y = v.depth;\n    layout.update(v);\n    v.children.forEach(w => secondWalk(w, m + v.mod, layout));\n}\n\n// After the second walk the parent nodes are positioned at the center of their immediate children.\n// If we want the parent nodes to be positioned at the center of the subtree for which they are roots,\n// we need a third walk to adjust the positions.\nfunction thirdWalk(v: TreeNode) {\n    const children = v.children;\n    let leafCount = 0;\n    children.forEach(w => {\n        thirdWalk(w);\n        if (w.children.length) {\n            leafCount += w.leafCount;\n        } else {\n            leafCount++;\n        }\n    });\n    v.leafCount = leafCount;\n    if (children.length) {\n        v.subtreeLeft = children[0].subtreeLeft;\n        v.subtreeRight = children[v.children.length - 1].subtreeRight;\n        v.x = (v.subtreeLeft + v.subtreeRight) / 2;\n    } else {\n        v.subtreeLeft = v.x;\n        v.subtreeRight = v.x;\n    }\n}\n\nexport function treeLayout(root: TreeNode): TreeLayout {\n    const layout = new TreeLayout();\n\n    firstWalk(root, 1);\n    secondWalk(root, -root.prelim, layout);\n    thirdWalk(root);\n\n    return layout;\n}\n\nexport class TreeLayout {\n    dimensions = new Dimensions();\n    leafCount = 0;\n    nodes: TreeNode[] = [];\n    // One might want to process leaf nodes separately from the rest of the tree.\n    // For example, position labels corresponding to leafs vertically, rather than horizontally.\n    leafNodes: TreeNode[] = [];\n    nonLeafNodes: TreeNode[] = [];\n    depth = 0;\n\n    update(node: TreeNode) {\n        this.dimensions.update(node, node => ({x: node.x, y: node.y}));\n        if (!node.children.length) {\n            this.leafCount++;\n            this.leafNodes.push(node);\n        } else {\n            this.nonLeafNodes.push(node);\n        }\n        if (node.depth > this.depth) {\n            this.depth = node.depth;\n        }\n        this.nodes.push(node);\n    }\n\n    resize(width: number, height: number, shiftX = 0, shiftY = 0, flipX: boolean = false) {\n        const xSteps = this.leafCount - 1;\n        const ySteps = this.depth;\n        const dimensions = this.dimensions;\n\n        let scalingX = 1;\n        let scalingY = 1;\n        if (width > 0 && xSteps) {\n            const existingSpacingX = (dimensions.right - dimensions.left) / xSteps;\n            const desiredSpacingX = width / xSteps;\n            scalingX = desiredSpacingX / existingSpacingX;\n            if (flipX) {\n                scalingX = -scalingX;\n            }\n        }\n        if (height > 0 && ySteps) {\n            const existingSpacingY = (dimensions.bottom - dimensions.top) / ySteps;\n            const desiredSpacingY = height / ySteps;\n            scalingY = desiredSpacingY / existingSpacingY;\n        }\n\n        const screenDimensions = new Dimensions();\n        this.nodes.forEach(node => {\n            node.screenX = node.x * scalingX;\n            node.screenY = node.y * scalingY;\n            screenDimensions.update(node, node => ({x: node.screenX, y: node.screenY}));\n        });\n        // Normalize so that root top and leftmost leaf left start at zero.\n        const offsetX = -screenDimensions.left;\n        const offsetY = -screenDimensions.top;\n        this.nodes.forEach(node => {\n            node.screenX += offsetX + shiftX;\n            node.screenY += offsetY + shiftY;\n        });\n    }\n}\n\nfunction logTree(root: TreeNode, formatter?: (node: TreeNode) => string) {\n    root.children.forEach(child => logTree(child, formatter));\n    if (formatter) {\n        console.log(formatter(root));\n    } else {\n        console.log(root);\n    }\n}\n","/Users/vitaliikravchenko/Sites/nova/client/src/charts/scene/clipRect.ts",[],"/Users/vitaliikravchenko/Sites/nova/client/src/charts/chart/marker/plus.ts",[],"/Users/vitaliikravchenko/Sites/nova/client/src/charts/chart/marker/heart.ts",[],"/Users/vitaliikravchenko/Sites/nova/client/src/charts/chart/marker/cross.ts",[],"/Users/vitaliikravchenko/Sites/nova/client/src/charts/chart/marker/square.ts",[],"/Users/vitaliikravchenko/Sites/nova/client/src/charts/chart/marker/triangle.ts",[],"/Users/vitaliikravchenko/Sites/nova/client/src/charts/chart/marker/diamond.ts",[],"/Users/vitaliikravchenko/Sites/nova/client/src/charts/hdpiCanvas.ts",[],{"ruleId":"561","replacedBy":"562"},{"ruleId":"563","replacedBy":"564"},{"ruleId":"565","severity":1,"message":"566","line":2,"column":8,"nodeType":"567","messageId":"568","endLine":2,"endColumn":12},{"ruleId":"565","severity":1,"message":"569","line":6,"column":34,"nodeType":"567","messageId":"568","endLine":6,"endColumn":38},{"ruleId":"565","severity":1,"message":"570","line":6,"column":40,"nodeType":"567","messageId":"568","endLine":6,"endColumn":46},{"ruleId":"565","severity":1,"message":"571","line":7,"column":10,"nodeType":"567","messageId":"568","endLine":7,"endColumn":24},{"ruleId":"572","severity":1,"message":"573","line":274,"column":40,"nodeType":"574","messageId":"575","endLine":274,"endColumn":42},{"ruleId":"572","severity":1,"message":"573","line":274,"column":66,"nodeType":"574","messageId":"575","endLine":274,"endColumn":68},{"ruleId":"576","severity":1,"message":"577","line":88,"column":5,"nodeType":"578","messageId":"579","endLine":90,"endColumn":6},{"ruleId":"580","severity":1,"message":"581","line":33,"column":44,"nodeType":"582","messageId":"583","endLine":33,"endColumn":58},{"ruleId":"580","severity":1,"message":"581","line":59,"column":44,"nodeType":"582","messageId":"583","endLine":59,"endColumn":58},{"ruleId":"584","severity":1,"message":"585","line":148,"column":33,"nodeType":"567","messageId":"586","endLine":148,"endColumn":38},{"ruleId":"587","severity":1,"message":"588","line":939,"column":42,"nodeType":"589","messageId":"590","endLine":948,"endColumn":14},{"ruleId":"572","severity":1,"message":"573","line":305,"column":30,"nodeType":"574","messageId":"575","endLine":305,"endColumn":32},{"ruleId":"572","severity":1,"message":"573","line":305,"column":40,"nodeType":"574","messageId":"575","endLine":305,"endColumn":42},{"ruleId":"572","severity":1,"message":"591","line":305,"column":40,"nodeType":"574","messageId":"575","endLine":305,"endColumn":42},{"ruleId":"572","severity":1,"message":"591","line":305,"column":61,"nodeType":"574","messageId":"575","endLine":305,"endColumn":63},{"ruleId":"592","severity":1,"message":"593","line":165,"column":20,"nodeType":"582","messageId":"594","endLine":165,"endColumn":22},{"ruleId":"595","severity":1,"message":"596","line":225,"column":5,"nodeType":"597","messageId":"598","endLine":225,"endColumn":20},{"ruleId":"592","severity":1,"message":"599","line":118,"column":21,"nodeType":"582","messageId":"594","endLine":118,"endColumn":23},{"ruleId":"592","severity":1,"message":"599","line":162,"column":26,"nodeType":"582","messageId":"594","endLine":162,"endColumn":28},{"ruleId":"600","severity":1,"message":"601","line":1,"column":1,"nodeType":"602","endLine":7,"endColumn":2},{"ruleId":"603","severity":1,"message":"604","line":115,"column":17,"nodeType":"605","messageId":"606","endLine":115,"endColumn":30},{"ruleId":"592","severity":1,"message":"593","line":378,"column":19,"nodeType":"582","messageId":"594","endLine":378,"endColumn":21},{"ruleId":"592","severity":1,"message":"593","line":462,"column":29,"nodeType":"582","messageId":"594","endLine":462,"endColumn":31},{"ruleId":"592","severity":1,"message":"593","line":501,"column":29,"nodeType":"582","messageId":"594","endLine":501,"endColumn":31},{"ruleId":"565","severity":1,"message":"607","line":6,"column":6,"nodeType":"567","messageId":"568","endLine":6,"endColumn":18},{"ruleId":"565","severity":1,"message":"608","line":8,"column":6,"nodeType":"567","messageId":"568","endLine":8,"endColumn":21},{"ruleId":"609","severity":1,"message":"610","line":9,"column":12,"nodeType":"611","messageId":"606","endLine":9,"endColumn":20,"fix":"612"},{"ruleId":"609","severity":1,"message":"610","line":10,"column":12,"nodeType":"611","messageId":"606","endLine":10,"endColumn":20,"fix":"613"},{"ruleId":"580","severity":1,"message":"581","line":100,"column":17,"nodeType":"582","messageId":"583","endLine":100,"endColumn":29},{"ruleId":"614","severity":1,"message":"615","line":101,"column":41,"nodeType":"616","messageId":"617","endLine":101,"endColumn":42},{"ruleId":"580","severity":1,"message":"581","line":108,"column":17,"nodeType":"582","messageId":"583","endLine":108,"endColumn":29},{"ruleId":"600","severity":1,"message":"601","line":7,"column":1,"nodeType":"602","endLine":19,"endColumn":2},{"ruleId":"572","severity":1,"message":"573","line":17,"column":63,"nodeType":"574","messageId":"575","endLine":17,"endColumn":65},{"ruleId":"572","severity":1,"message":"573","line":17,"column":99,"nodeType":"574","messageId":"575","endLine":17,"endColumn":101},{"ruleId":"600","severity":1,"message":"601","line":1,"column":1,"nodeType":"602","endLine":5,"endColumn":2},{"ruleId":"600","severity":1,"message":"601","line":3,"column":1,"nodeType":"602","endLine":29,"endColumn":2},{"ruleId":"600","severity":1,"message":"601","line":1,"column":1,"nodeType":"602","endLine":9,"endColumn":2},{"ruleId":"609","severity":1,"message":"610","line":2,"column":18,"nodeType":"611","messageId":"606","endLine":2,"endColumn":26,"fix":"618"},{"ruleId":"600","severity":1,"message":"601","line":3,"column":1,"nodeType":"602","endLine":23,"endColumn":2},{"ruleId":"600","severity":1,"message":"619","line":1,"column":1,"nodeType":"602","endLine":1,"endColumn":36},{"ruleId":"572","severity":1,"message":"573","line":526,"column":38,"nodeType":"574","messageId":"575","endLine":526,"endColumn":40},{"ruleId":"572","severity":1,"message":"573","line":526,"column":59,"nodeType":"574","messageId":"575","endLine":526,"endColumn":61},{"ruleId":"572","severity":1,"message":"573","line":527,"column":40,"nodeType":"574","messageId":"575","endLine":527,"endColumn":42},{"ruleId":"572","severity":1,"message":"573","line":527,"column":63,"nodeType":"574","messageId":"575","endLine":527,"endColumn":65},{"ruleId":"572","severity":1,"message":"573","line":331,"column":42,"nodeType":"574","messageId":"575","endLine":331,"endColumn":44},{"ruleId":"572","severity":1,"message":"573","line":331,"column":63,"nodeType":"574","messageId":"575","endLine":331,"endColumn":65},{"ruleId":"572","severity":1,"message":"573","line":332,"column":44,"nodeType":"574","messageId":"575","endLine":332,"endColumn":46},{"ruleId":"572","severity":1,"message":"573","line":332,"column":67,"nodeType":"574","messageId":"575","endLine":332,"endColumn":69},{"ruleId":"572","severity":1,"message":"573","line":632,"column":32,"nodeType":"574","messageId":"575","endLine":632,"endColumn":34},{"ruleId":"572","severity":1,"message":"573","line":632,"column":47,"nodeType":"574","messageId":"575","endLine":632,"endColumn":49},{"ruleId":"572","severity":1,"message":"573","line":633,"column":34,"nodeType":"574","messageId":"575","endLine":633,"endColumn":36},{"ruleId":"572","severity":1,"message":"573","line":633,"column":51,"nodeType":"574","messageId":"575","endLine":633,"endColumn":53},{"ruleId":"572","severity":1,"message":"573","line":326,"column":42,"nodeType":"574","messageId":"575","endLine":326,"endColumn":44},{"ruleId":"572","severity":1,"message":"573","line":326,"column":63,"nodeType":"574","messageId":"575","endLine":326,"endColumn":65},{"ruleId":"572","severity":1,"message":"573","line":327,"column":44,"nodeType":"574","messageId":"575","endLine":327,"endColumn":46},{"ruleId":"572","severity":1,"message":"573","line":327,"column":67,"nodeType":"574","messageId":"575","endLine":327,"endColumn":69},{"ruleId":"572","severity":1,"message":"573","line":179,"column":30,"nodeType":"574","messageId":"575","endLine":179,"endColumn":32},{"ruleId":"572","severity":1,"message":"573","line":179,"column":40,"nodeType":"574","messageId":"575","endLine":179,"endColumn":42},{"ruleId":"572","severity":1,"message":"591","line":179,"column":40,"nodeType":"574","messageId":"575","endLine":179,"endColumn":42},{"ruleId":"572","severity":1,"message":"591","line":179,"column":61,"nodeType":"574","messageId":"575","endLine":179,"endColumn":63},{"ruleId":"572","severity":1,"message":"573","line":262,"column":89,"nodeType":"574","messageId":"575","endLine":262,"endColumn":91},{"ruleId":"572","severity":1,"message":"573","line":262,"column":119,"nodeType":"574","messageId":"575","endLine":262,"endColumn":121},{"ruleId":"565","severity":1,"message":"620","line":415,"column":19,"nodeType":"567","messageId":"568","endLine":415,"endColumn":30},{"ruleId":"572","severity":1,"message":"573","line":439,"column":34,"nodeType":"574","messageId":"575","endLine":439,"endColumn":36},{"ruleId":"572","severity":1,"message":"573","line":439,"column":49,"nodeType":"574","messageId":"575","endLine":439,"endColumn":51},{"ruleId":"572","severity":1,"message":"573","line":440,"column":36,"nodeType":"574","messageId":"575","endLine":440,"endColumn":38},{"ruleId":"572","severity":1,"message":"573","line":440,"column":53,"nodeType":"574","messageId":"575","endLine":440,"endColumn":55},{"ruleId":"592","severity":1,"message":"593","line":10,"column":24,"nodeType":"582","messageId":"594","endLine":10,"endColumn":26},{"ruleId":"580","severity":1,"message":"581","line":60,"column":12,"nodeType":"582","messageId":"583","endLine":60,"endColumn":19},{"ruleId":"580","severity":1,"message":"581","line":60,"column":23,"nodeType":"582","messageId":"583","endLine":60,"endColumn":30},{"ruleId":"592","severity":1,"message":"599","line":265,"column":15,"nodeType":"582","messageId":"594","endLine":265,"endColumn":17},{"ruleId":"565","severity":1,"message":"621","line":342,"column":36,"nodeType":"567","messageId":"568","endLine":342,"endColumn":43},"no-native-reassign",["622"],"no-negated-in-lhs",["623"],"@typescript-eslint/no-unused-vars","'logo' is defined but never used.","Identifier","unusedVar","'List' is defined but never used.","'Button' is defined but never used.","'SearchOutlined' is defined but never used.","no-mixed-operators","Unexpected mix of '&&' and '||'.","LogicalExpression","unexpectedMixedOperator","@typescript-eslint/no-useless-constructor","Useless constructor.","MethodDefinition","noUselessConstructor","no-self-compare","Comparing to itself is potentially pointless.","BinaryExpression","comparingToSelf","@typescript-eslint/no-use-before-define","'Chart' was used before it was defined.","noUseBeforeDefine","no-loop-func","Function declared in a loop contains unsafe references to variable(s) 'minDistance', 'minDistance', 'closestDatum'.","ArrowFunctionExpression","unsafeRefs","Unexpected mix of '||' and '&&'.","eqeqeq","Expected '!==' and instead saw '!='.","unexpected","getter-return","Expected getter 'nextSibling' to always return a value.","FunctionExpression","expectedAlways","Expected '===' and instead saw '=='.","import/no-anonymous-default-export","Unexpected default export of anonymous function","ExportDefaultDeclaration","no-cond-assign","Expected a conditional expression and instead saw an assignment.","AssignmentExpression","missing","'NodeCallback' is defined but never used.","'NodeSelectorAll' is defined but never used.","new-parens","Missing '()' invoking a constructor.","NewExpression",{"range":"624","text":"625"},{"range":"626","text":"625"},"no-sequences","Unexpected use of comma operator.","SequenceExpression","unexpectedCommaExpression",{"range":"627","text":"625"},"Assign arrow function to a variable before exporting as module default","'outerRadius' is assigned a value but never used.","'logTree' is defined but never used.","no-global-assign","no-unsafe-negation",[541,541],"()",[562,562],[109,109]]